{
    "version": "https://jsonfeed.org/version/1",
    "title": "S1m • All posts by \"复习\" tag",
    "description": "博客记录个人学习笔记,处于不断完善中",
    "home_page_url": "https://github.com/YogMas/YogMas.github.io",
    "items": [
        {
            "id": "https://github.com/YogMas/YogMas.github.io/2023/06/15/cao-zuo-xi-tong-qi-mo-fu-xi/",
            "url": "https://github.com/YogMas/YogMas.github.io/2023/06/15/cao-zuo-xi-tong-qi-mo-fu-xi/",
            "title": "操作系统期末复习",
            "date_published": "2023-06-14T16:00:00.000Z",
            "content_html": "<h1 id=\"操作系统期末复习\"><a class=\"markdownIt-Anchor\" href=\"#操作系统期末复习\">#</a> 操作系统期末复习</h1>\n<p>@author 摆摆哥 JoTang</p>\n<h2 id=\"一-概述\"><a class=\"markdownIt-Anchor\" href=\"#一-概述\">#</a> 一 概述</h2>\n<p><strong>操作系统的目标</strong></p>\n<ul>\n<li>方便性：使计算机易于使用 (抽象计算机资源暴露接口，将高级语言转化成机器语言)</li>\n<li>有效性：以更有效的方式使用计算机资源 (提高系统资源利用率，提高系统的吞吐量)</li>\n<li>可扩展性：在操作系统中，允许有效地开发、测试和引进新的系统功能。</li>\n<li>开放性：实现应用程序的可移植性和互操作性，要求具有统一的开放的环境 (遵循国际规范，使得硬件软件彼此兼容，方便地实现互连)</li>\n</ul>\n<p><strong>操作系统的作用 (大概率不考，因为 ppt 与书上存在部分不一致)</strong></p>\n<ul>\n<li>作为用户与计算机系统之间的接口 (对应方便性)</li>\n<li>作为计算机系统资源的管理者 (对应有效性，更有效地使用计算机资源)  [相互竞争的程序之间有序地控制对硬件设 备的分配，资源管理包括在时间上复用和在空间上复用]</li>\n<li>用作扩充机器 / 实现了对计算机资源的抽象</li>\n</ul>\n<p><strong>操作系统的发展历程</strong></p>\n<p>人工操作模式 -&gt; 脱机 I/O -&gt; 单道批处理 -&gt; 多道批处理 -&gt; 分时系统 -&gt; 实时系统</p>\n<p><strong>操作系统的四个基本特征</strong></p>\n<ul>\n<li>\n<p>并发 (重要)  其他三个以并发为前提</p>\n<p>并行性：是指两个或多个事件在<strong>同一时刻</strong>发生。</p>\n<p>并发性：是指两个或多个事件在<strong>同一时间间隔内</strong>发生。</p>\n<p>进程作为<strong>资源分配</strong>的基本单位</p>\n<p>线程作为<strong>独立运行和调度</strong>的基本单位</p>\n</li>\n<li>\n<p>共享：指系统中的资源可供内存中多个并发执行的进 程共同使用</p>\n<p>互斥共享：系统中的临界资源可以提供给多个进程使用，但一段时间内仅允许一个进程使用</p>\n<p>同时访问：多个进程交替互斥地使用系统中的某资源</p>\n</li>\n<li>\n<p>虚拟：通过某种技术把一个物理实体变为（映射为） 若干个逻辑上的对应物。</p>\n<p>时分复用技术</p>\n<p>空分复用技术</p>\n</li>\n<li>\n<p>异步</p>\n<p>每道程序在何时执行、各自执行的顺序是什么、完成时间的长短等都是不确定的，也是不可预知的 (对应不可再现性，后续的进程同步就是用来解决异步问题的)</p>\n</li>\n</ul>\n<p><strong>操作系统应具有五个方面的功能</strong></p>\n<ul>\n<li>处理机管理（CPU)</li>\n<li>存储器管理</li>\n<li>设备管理</li>\n<li>文件管理</li>\n<li>用户接口</li>\n</ul>\n<p><strong>操作系统的主要任务:</strong></p>\n<p>为多道程序的运行提供良好的运行环境，以保证多道程序能有条不紊地、高效地运行，并且能<strong>最大程度地提高系统中各种资源的利用率和方便用户的使用。</strong></p>\n<h2 id=\"二-进程管理\"><a class=\"markdownIt-Anchor\" href=\"#二-进程管理\">#</a> 二  进程管理</h2>\n<h3 id=\"21前驱图和程序执行\"><a class=\"markdownIt-Anchor\" href=\"#21前驱图和程序执行\">#</a> 2.1 前驱图和程序执行</h3>\n<p>前驱图：描述进程之间的执行的前后关系 (大概率不会考，考的话 可能给程序叫你画前驱图)</p>\n<p><img src=\"https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/image-20230616222540001.png\" alt=\"image-20230616222540001\"></p>\n<p><strong>程序顺序执行时的特征:</strong></p>\n<ul>\n<li>顺序性：处理机的操作严格按照程序的顺序执行</li>\n<li>封闭性：程序运行独占全机资源，其执行结果不受外界因素的影响</li>\n<li>可再现性：环境和初始条件相同，会得到相同的结果</li>\n</ul>\n<p><strong>程序并发执行时的特征:</strong></p>\n<ul>\n<li>间断性：并发程序具有 \"执行 - 暂停 - 执行\" 间断性的活动规律</li>\n<li>失去封闭性：多个程序共享系统中的各种资源，因 而这些资源的状态将由多个程序来改变，致使程序的运行已失去了封闭性。</li>\n<li>不可再现性：程序在并发执行时，由于失去了封闭性， 导致不可再现性</li>\n</ul>\n<h3 id=\"22-进程描述\"><a class=\"markdownIt-Anchor\" href=\"#22-进程描述\">#</a> 2.2 进程描述</h3>\n<p><strong>进程的定义</strong> (不大可能考，定义较多无标准答案): 进程是程序的一次执行，它是系统进行资源分配和调度的一个独立单位</p>\n<p><strong>进程的特征:</strong></p>\n<ul>\n<li>结构特征：由程序段，数据段和 PCB 三部分构成</li>\n<li>动态性：进程实体有一定的生命期</li>\n<li>并发性：多个进程实体同存于内存中，且能在一段时间内同时运行</li>\n<li>独立性：指进程实体是一个能独立运行、独立分配资源和独立接受调度的基本单位</li>\n<li>异步性：指进程按各自独立的、不可预知的速度向前推进</li>\n</ul>\n<p><strong>进程的基本状态及转换</strong></p>\n<p><img src=\"https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/image-20230616223424782.png\" alt=\"三种基本状态\"></p>\n<ul>\n<li>就绪态：进程已获得出 CPU 之外所有资源，只要再获得 CPU 就可以执行</li>\n<li>执行：已经获得 CPU, 正在执行</li>\n<li>阻塞态：正在执行的进程由于发生某事件而暂时无法继续执行时 (资源被其他进程占用)，便放弃处理机而处于暂停状态，把这种暂停状态称为阻塞状态</li>\n</ul>\n<p><img src=\"https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/image-20230617230055620.png\" alt=\"进程的五种状态\"></p>\n<p>阻塞队列分为单阻塞队列和多阻塞队列</p>\n<p><strong>进程的状态转换</strong>（可能出题 描述进程从创建到终止的整个过程的状态转换）</p>\n<ul>\n<li>空 -&gt; 创建状态：新创建的进程首先处于创建状态。</li>\n<li>创建状态 -&gt; 就绪状态：当系统允许增加就绪进程时，操作系统接纳创建状态进程，将它变为就绪状态，插入就绪队列中</li>\n<li>就绪状态 -&gt; 执行状态 当处理机空闲时，将从就绪队列中选择一个进程执行，该选择过程称为进程调度。</li>\n<li>执行状态 -&gt; 终止状态 执行状态的进程执行完毕，或出现诸如访问地址越界、非法指令等错误，而被异常结束</li>\n<li>执行状态 -&gt; 就绪状态 分时系统中，时间片用完，或优先级高的进程到来，将暂停较低优先级进程的执行。进程从执行状态转变为就绪状态，等待下一次调度</li>\n<li>执行状态 -&gt; 阻塞状态 执行进程需要等待某事件发生。通常， 会因为进程需要的系统调用不能立即完成，如读文件、共享虚 拟内存、等待 I/O 操作、等待另一进程与之通信等事件而阻塞</li>\n<li>阻塞状态 -&gt; 就绪状态 当阻塞进程等待的事件发生 (资源满足)，就转换 为就绪状态。进入就绪队列排队，等待被调度执行</li>\n</ul>\n<p><strong>解决多个进程竞争导致的资源紧张和无就绪进程 (全部阻塞等待 I/O) 的解决方法</strong></p>\n<ul>\n<li>交换技术：换出一部分进程到外存，以腾出内存空间 (换出的进程状态为<strong>挂起</strong>)</li>\n<li>虚拟存储技术</li>\n</ul>\n<p><strong>挂起状态</strong>：使执行的进程暂停执行、静止下来。我们把这种静止状态称为挂起状态</p>\n<p><strong>挂起与阻塞的区别</strong>：是否被换出内存  是否在等待特定事件</p>\n<p>挂起状态的转换 (略): 活动阻塞 &lt;-&gt; 静止阻塞  静止阻塞 -&gt; 静止就绪  静止就绪 -&gt; 活动就绪</p>\n<p><strong>进程控制块的作用</strong>：进程存在的唯一标志且<strong>常驻内存</strong></p>\n<p><strong>进程控制块中的信息</strong>:</p>\n<ul>\n<li>进程标识符：唯一标识进程，分为内部和外部</li>\n<li>处理机状态信息：处理机各种寄存器中信息组成</li>\n<li>进程调度信息：状态 优先级等</li>\n<li>进程控制信息：指针，程序和数据地址等</li>\n</ul>\n<p><strong>PCB 的组织方式</strong>:</p>\n<ul>\n<li>线性</li>\n<li>链接</li>\n<li>索引</li>\n</ul>\n<h3 id=\"23-进程控制\"><a class=\"markdownIt-Anchor\" href=\"#23-进程控制\">#</a> 2.3  进程控制</h3>\n<p><strong>进程创建的步骤</strong>:</p>\n<ol>\n<li>申请空白 PCB</li>\n<li>为新进程分配资源</li>\n<li>初始化控制块信息</li>\n<li>将新进程插入就绪队列</li>\n</ol>\n<p><strong>进程的终止过程</strong>： 有正常结束，异常结束，外界干预</p>\n<ol>\n<li>根据标识符，从 PCB 集合中检索出 PCB, 读出该进程的状态</li>\n<li>若处于执行态，则终止执行，并将调度标志改为真</li>\n<li>若进程有子孙进程，则将其子孙进程也终止</li>\n<li>将被终止进程的所有资源返还给其父进程</li>\n<li>将终止进程的 PCB 从所在队列中移除</li>\n</ol>\n<p><strong>进程的阻塞过程</strong>  原因可能有：等待系统服务 (I/O) 暂时无新工作 等待新数据</p>\n<ol>\n<li>调用 block 原语将自己阻塞</li>\n<li>将 PCB 中的现行状态由执行改为阻塞，并插入阻塞队列</li>\n<li>调度程序重新调度，将处理机分配给另外的进程</li>\n</ol>\n<p><strong>进程的唤醒过程</strong></p>\n<p>当等待的事件发生时，调用 wakeup 原语将自己唤醒</p>\n<ol>\n<li>将进程从阻塞队列中移出，PCB 中的现行状态改为就绪</li>\n<li>将该进程 PCB 插入就绪队列中</li>\n</ol>\n<p><strong>进程的挂起</strong>：调用 suspend 原语将进程由内存换到外存</p>\n<p>检查进程的状态 就绪则改成静止就绪  阻塞则改为静止阻塞</p>\n<p><strong>进程的激活</strong></p>\n<p>调用 active 将进程从外存换到内存，更改进程 PCB 的现行状态</p>\n<h3 id=\"24-进程同步\"><a class=\"markdownIt-Anchor\" href=\"#24-进程同步\">#</a> 2.4 进程同步</h3>\n<p><strong>引入进程同步的原因</strong>：使并发执行的诸进程之间能有效地共享资源和相互合作，从而<strong>使程序的执行具有可再现性</strong>。</p>\n<ul>\n<li>间接制约关系：资源共享，多进程访问一个资源 (互斥访问)</li>\n<li>直接制约关系：进程合作 (实现进程之间的顺序关系)</li>\n</ul>\n<p><strong>临界资源</strong>：一次仅允许一个进程访问的资源</p>\n<p><strong>临界区</strong>：每个进程中访问临界资源的那段代码</p>\n<p><strong>同步进程遵循的规则</strong>:</p>\n<ul>\n<li>空闲让进：邻接资源没有进程访问 则访问</li>\n<li>忙则等待：临界资源有进程在访问时 则等待其访问结束</li>\n<li>有限等待：等待的时间应该是有限的 不能陷入饥饿状态</li>\n<li>让权等待：等待的时候应该不占用处理机</li>\n</ul>\n<p>实现进程同步的机制</p>\n<ol>\n<li>硬件机制\n<ul>\n<li>中断：锁测试前关中断，锁测试后上锁开中断  锁测试的时候不相应中断 不会引发调度</li>\n<li>Test and set: 一直测试锁，先将锁变成 true, 再看开始锁是 true 还是 false</li>\n<li>Swap: 交换锁和 key, 直到 key=false;\\</li>\n</ul>\n</li>\n<li>信号量机制\n<ul>\n<li>整型信号量 P,S   如果信号量 &lt; 0 就一直等待   进入则将信号量 - 1 离开则 + 1</li>\n<li>记录性信号量：信号量 &lt; 0 就将自身阻塞并插入阻塞队列 出来时信号量 + 1 如果仍然有阻塞的进程 则唤醒列表的第一个</li>\n<li>AND 型信号量：要么全部分配到进程，要么一个也不配   <code>Swait(s1,s2,s2)</code>  一次请求多个资源  <code>Ssignal（S1，S2， ··· ，Sn）</code></li>\n<li>信号量集：每次请求 d 个资源 且资源数目有下限  <code>Swait（S1，t1，d1，…，Sn，tn，dn）</code>   <code>Ssignal（S1，S2， ··· ，Sn）</code></li>\n</ul>\n</li>\n</ol>\n<p>利用信号量实现进程互斥 信号量初始值为 1    将临界区放在 wait 和 signal 之间</p>\n<ul>\n<li>\n<p>缺少 <code>wait（mutex）</code> 导致系统混乱，不能保证 对临界资源的互斥访问；</p>\n</li>\n<li>\n<p>缺少 <code>signal（mutex）</code> 会使临界资源永远不释放， 等待该资源的进程不能被唤醒。</p>\n</li>\n</ul>\n<p>利用信号量实现前驱关系：信号量初始值为 0 先执行的进程先 signal  后执行的进程 wait  因为要 signal 之后信号量变为 1  wait 才能访问</p>\n<h3 id=\"25-管程略\"><a class=\"markdownIt-Anchor\" href=\"#25-管程略\">#</a> 2.5 管程 (略）</h3>\n<p>使用面向对象的方法</p>\n<p>管程由四部分组成 (想象 Java 的一个类记忆， 有类名 (名字) 变量 (数据结构的说明) 函数 (对数据结构操作的一组过程)  构造函数 (对数据设置初始值的语句))</p>\n<ul>\n<li>名字</li>\n<li>共享数据结构的说明</li>\n<li>对数据结构操作的一组过程</li>\n<li>对局部与管程的数据设置初始值的语句</li>\n</ul>\n<p>管程的主要特点：</p>\n<ul>\n<li>局部数据变量只能被管程的过程访问，任何外部过程都不 能访问</li>\n<li>一个进程通过调用管程的一个过程进入管程</li>\n<li>在任何时候，只能有一个进程在管程中执行，调用管程的 任何其他进程都被挂起，以等待管程变成可用的</li>\n</ul>\n<h3 id=\"26-经典进程同步问题\"><a class=\"markdownIt-Anchor\" href=\"#26-经典进程同步问题\">#</a> 2.6 经典进程同步问题</h3>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token comment\">// 生产者消费者问题</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">producer</span><span class=\"token punctuation\">(</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">do</span><span class=\"token punctuation\">{</span>\n    …\n    Produce an item in nextp<span class=\"token punctuation\">;</span>\n    …\n    <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span>empty<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//进程同步 - 间接制约 先看empty有没有空的  其实就是要资源 empty这个资源还有没有</span>\n    <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//互斥访问  对共享缓冲区操作时 应该互斥访问</span>\n    <span class=\"token function\">buffer</span><span class=\"token punctuation\">(</span>in<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span><span class=\"token operator\">=</span>nextp<span class=\"token punctuation\">;</span>\n    in<span class=\"token operator\">:</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span>in<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> mod n<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span>full<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//我生产了一个  所以full资源应该+1</span>\n    <span class=\"token punctuation\">}</span><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>TRUE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">consumer</span><span class=\"token punctuation\">(</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">do</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span>full<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    nextc<span class=\"token operator\">:</span><span class=\"token operator\">=</span><span class=\"token function\">buffer</span><span class=\"token punctuation\">(</span>out<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    out<span class=\"token operator\">:</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span>out<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> mod n<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span>empty<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    consumer the item in nextc<span class=\"token punctuation\">;</span>\n    …\n\t<span class=\"token punctuation\">}</span><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>TRUE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token comment\">//哲学家问题</span>\nsemaphore chopstick<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">do</span><span class=\"token punctuation\">{</span>\n    ……<span class=\"token punctuation\">;</span>\n    think<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">Sswait</span><span class=\"token punctuation\">(</span>chopstick<span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>chopstick<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">//只有同时可以获得左手和右手的 才可以进食 避免了死锁  (破坏了请求和等待)</span>\n    eat；\n    <span class=\"token function\">Ssignal</span><span class=\"token punctuation\">(</span>chopstick<span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>chopstick<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>TRUE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token comment\">//读者写者问题</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">reader</span><span class=\"token punctuation\">(</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span>rmutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> readcount<span class=\"token operator\">=</span><span class=\"token number\">0</span> then <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span>wmutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    readcount<span class=\"token operator\">:</span><span class=\"token operator\">=</span>readcount<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span>rmutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    …\n    perform read operation\n    …\n    <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span>rmutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    readcount<span class=\"token operator\">:</span><span class=\"token operator\">=</span>readcount<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> readcount<span class=\"token operator\">=</span><span class=\"token number\">0</span> then <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span>wmutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span>rmutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>TRUE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token comment\">//end reader\t</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>例题</p>\n<p>有一个理发师，一把理发椅和 n 把供等候理发的顾客坐的椅子。如果没有顾客，理发师便在理发椅上睡觉；当一个顾客到来时，必须唤醒理发师进行理发；如果理发师正在理发时又有顾客到来，则如果有空椅子可坐，他就坐下来等，如果没有空椅子，他就离开。为理发师和 客各编一段程序描述他们的行为。</p>\n<p>semaphere</p>\n<h3 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h3>\n<p>本章应该<strong>大部分考概念</strong>，最后的<strong>经典进程同步问题考伪代码</strong></p>\n<h2 id=\"三-处理机调度与死锁\"><a class=\"markdownIt-Anchor\" href=\"#三-处理机调度与死锁\">#</a> 三 处理机调度与死锁</h2>\n<h3 id=\"31-处理机调度的层次和目标\"><a class=\"markdownIt-Anchor\" href=\"#31-处理机调度的层次和目标\">#</a> 3.1 处理机调度的层次和目标</h3>\n<ul>\n<li>高级调度（作业调度）: 运用调度算法将作业由外存调度进入内存 -&gt; 创建 PCB -&gt; 插入就绪队列</li>\n<li>低级调度 (进程调度): 运用调度算法将处理机分配给就绪队列上的进程</li>\n<li>中级调度 (内存调度): 把外存上那些已经具备运行条件的就绪进程重新 载入内存。从静止就绪到活动就绪</li>\n</ul>\n<h3 id=\"32-作业调度算法\"><a class=\"markdownIt-Anchor\" href=\"#32-作业调度算法\">#</a> 3.2 作业调度算法</h3>\n<p>可能考题：给出作业 / 进程到达时间，给出算法 画出周转时间 带权周转时间 平均带权周转时间</p>\n<ul>\n<li>先来先服务 对短作业不公平 吞吐量小</li>\n<li>短作业优先  缺点：对长作业不利 可能产生饥饿现象</li>\n<li>优先级调度算法：赋予程序优先级 选择优先级高的进行调度  （静态优先级算法和动态优先级算法）</li>\n<li>高响应比优先调度算法：优先权 = （等待时间 + 要求服务时间） / 要求服务时间 = 响应时间 / 要求服务时间</li>\n</ul>\n<p>例题</p>\n<p><img src=\"https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/image-20230618004344064.png\" alt=\"例题\"></p>\n<p><img src=\"https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/image-20230618004404748.png\" alt=\"例题\"></p>\n<h3 id=\"33-进程调度\"><a class=\"markdownIt-Anchor\" href=\"#33-进程调度\">#</a> 3.3 进程调度</h3>\n<p>选取合适的进程 -&gt; 保护现场 -&gt; 分配处理器</p>\n<p><img src=\"https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/image-20230618004224210.png\" alt=\"进程调度\"></p>\n<p><strong>进程调度的方式</strong></p>\n<ul>\n<li>非抢占式方式：一旦进程投入运行，除了进程完成或者需要阻塞外，不 能剥夺其处理机</li>\n<li>抢占方式：允许系统根据某种原则，暂停正在执行的进程，重新分配处理机 (优先权，时间片)</li>\n</ul>\n<p><strong>抢占式调度算法</strong></p>\n<ul>\n<li>轮转调度算法 (RR): 每个进程仅运行一个时间片即被抢占 CPU  FCFS + 时间片 + 中断</li>\n</ul>\n<p>时间片大小</p>\n<ul>\n<li>\n<p>太小：增大调度和上下文切换，增加系统开销</p>\n</li>\n<li>\n<p>太大：退化成 FCFS</p>\n</li>\n<li>\n<p>最好：略大于一次典型的交互所需要的时间，使大多数交互式进程能在一个时间片内完成</p>\n</li>\n<li>\n<p>多级反馈队列调度算法：时间片轮转 + 优先级调度</p>\n<p>设置多个就绪队列，并为各个队列赋予不同的 优先级。 第一个最高，以后依次降低。</p>\n<p>每个队列中进程执行时间片的大小也各不相同， 进程所在队列的优先级越高，其相应的时间片就越短。</p>\n<p><img src=\"https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/image-20230618004952388.png\" alt=\"多级反馈队列算法\"></p>\n<p><strong>未执行完时间片的进程被抢占后如何处理</strong>：不降级，到队列末尾，且下一次运行时仍然是一 个完整时间片</p>\n<p>（1）短作业一次完成，响应时间性能好； （2）中型作业周转时间不长； （3）大型作业不会长期不处理。</p>\n</li>\n</ul>\n<h3 id=\"34-实时调度略\"><a class=\"markdownIt-Anchor\" href=\"#34-实时调度略\">#</a> 3.4 实时调度 (略)</h3>\n<h3 id=\"35-死锁\"><a class=\"markdownIt-Anchor\" href=\"#35-死锁\">#</a> 3.5 死锁</h3>\n<p><strong>死锁</strong>：多个进程在运行过程中因争夺资源而造成的一种僵局），当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进</p>\n<p><strong>死锁</strong>：如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的。</p>\n<ul>\n<li>可重用资源：可供用户重复使用多次的资源</li>\n<li>可消耗性资源：可消耗资源的单元数目在进程运行期间是可以不断变化的。(消息)</li>\n<li>可抢占性资源：一个进程在使用某个资源时，系统可以剥夺其使用权，将该资源分配给其他进程 (CPU, 内存)</li>\n<li>不可抢占性资源：某个资源一旦分配给某个进程，则系统不能剥夺进程的使用权，只能由进程释放资源，或者进程终止运行 (打印机)</li>\n</ul>\n<p>产生死锁的原因：</p>\n<ul>\n<li>竞争资源：竞争可重用资源 (打印机等) 和可消耗性资源 (临时资源：比如信号量，消息等)</li>\n<li>进程间推进顺序非法</li>\n</ul>\n<p><strong>发生死锁的四个必要条件</strong></p>\n<ul>\n<li>互斥条件:</li>\n<li>请求和保持：进程已经保持了一个资源，又提出新的请求       (破坏：必须一次性申请在整个运行过程中的所有资源)</li>\n<li>不剥夺：进程已获得的资源在未使用完之前 不能被剥夺        (破坏：当资源得不到满足时，必须释放已持有的资源)</li>\n<li>环路等待：发生死锁时 必然存在一个进程 - 资源的环形链      (破坏：对资源赋予序号，必须严格按照资源递增的次序提出)</li>\n</ul>\n<p>处理死锁的方法</p>\n<ul>\n<li>预防死锁：破坏四个必要条件中的一个或几个</li>\n<li>避免死锁：防止系统进入不安全状态</li>\n<li>检测死锁：及时地检测死锁是否发生 并定位进程和资源</li>\n<li>解除死锁：将进程从死锁中脱离出来</li>\n</ul>\n<h3 id=\"36-预防死锁\"><a class=\"markdownIt-Anchor\" href=\"#36-预防死锁\">#</a> 3.6 预防死锁</h3>\n<p>破坏四个必要条件第 2,3,4 其中的一个 前面已阐述</p>\n<ul>\n<li>请求和保持：资源被严重浪费 进程延迟运行</li>\n<li>不剥夺：反复申请释放，消耗大量系统资源，且释放后可能被导致前段时间的工作失效，实现起来也比较复杂</li>\n<li>环路等待：限制了新设备的增加，增加了程序设计难度</li>\n</ul>\n<h3 id=\"37-避免死锁\"><a class=\"markdownIt-Anchor\" href=\"#37-避免死锁\">#</a> 3.7 避免死锁</h3>\n<p><strong>安全状态</strong>：指系统能按某种进程顺序，依次为 n 个进程分配其所需资源，直至其最大需求，使每个进程都可顺利地完成，称系统处于安全状态。</p>\n<p>** 安全序列:** 能够满足安全状态中的序列就是安全序列</p>\n<p><strong>银行家算法</strong></p>\n<p>Available Max Need Allocation     拥有资源， 最大需求   现在需要  已经分配</p>\n<p>先判断 Request (请求资源) 是否合法    需要不大于 Need  不大于 Available   申请的资源不能比需要的大  申请的资源不能大于系统有的资源</p>\n<p>如果申请合法 则尝试分配</p>\n<p>检查分配后 系统是否仍然是安全状态，如果是安全状态则分配 否则不予分配</p>\n<p><strong>安全性检查算法</strong></p>\n<p>Work Finish</p>\n<p>从集合中找到一个  <code>Finish[i]=false</code>  (还没有完成)  <code>Need[i,j]≤work[j]</code> (需求量没有超过系统所拥有量) 的进程，将资源分配给他，直到他执行完成并返回资源，然后继续寻找下一个进程，如果所有进程都满足 <code>Finish[i]=true</code>  则表示系统处于安全状态</p>\n<p>例题</p>\n<p><img src=\"https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/image-20230618131932575.png\" alt=\"例题\"></p>\n<p><img src=\"https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/image-20230618132009332.png\" alt=\"例题\"></p>\n<h2 id=\"四-存储器管理\"><a class=\"markdownIt-Anchor\" href=\"#四-存储器管理\">#</a> 四 存储器管理</h2>\n<h3 id=\"41-存储器结构层次\"><a class=\"markdownIt-Anchor\" href=\"#41-存储器结构层次\">#</a> 4.1  存储器结构层次</h3>\n<p>寄存器 -&gt; 高速缓存 -&gt; 主存 -&gt; 磁盘缓存 -&gt; 磁盘</p>\n<p>高速缓存：利用局部性原理 将主存中一些经常访问的信息存放在高速缓存中</p>\n<p>磁盘缓存：利用局部性原理 …  磁盘缓存不是一种磁盘介质 而是利用主存中的存储空间来暂存从磁盘读入的信息</p>\n<p><strong>CPU 只能从主存储器中取得指令和数据</strong></p>\n<h3 id=\"42-程序的装入和链接\"><a class=\"markdownIt-Anchor\" href=\"#42-程序的装入和链接\">#</a> 4.2 程序的装入和链接</h3>\n<p>源程序 -&gt; 可执行程序：编译 -&gt; 链接 -&gt; 装入</p>\n<p>编译：由编译程序（Compiler）将用户源代码转换成若个目标模块</p>\n<p>链接：由链接程序（Linker）将编译后形成的一组目标模块，以及它们所需要的库函数链接在一起， 形成一个完整的装入模块</p>\n<p>装入：由装入程序（Loader）将装入模块装入内存</p>\n<p><img src=\"https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/image-20230618133141557.png\" alt=\"image-20230618133141557\"></p>\n<h4 id=\"421-程序的装入\"><a class=\"markdownIt-Anchor\" href=\"#421-程序的装入\">#</a> 4.2.1 程序的装入</h4>\n<p>分为三种</p>\n<ul>\n<li>绝对装入方式</li>\n<li>可重定位装入方式</li>\n<li>动态运行时装入方式</li>\n</ul>\n<ol>\n<li>\n<p><strong>绝对装入方式</strong></p>\n<p>如果知道程序将驻留在内存的什么位置，那么， 编译程序将产生<strong>绝对地址</strong>的目标代码，此时逻辑地址和绝对地址完全相同，<strong>装入程序不需要对程序和数据的地址进行更改</strong></p>\n<p>只合适单道程序环境</p>\n</li>\n<li>\n<p><strong>可重定位装入方式</strong></p>\n<p>装入程序将装入模块装入内存后，装入模块中程序所访问的所有逻辑地址与实际装入内存的物理地址不同 ，必须进行变换</p>\n<p>把在装入时对目标程序中指令和数据的变换过程称为重定位。因为<strong>地址变换是在装入时一次完成的，以后不再改变</strong>，故称为静态重定位</p>\n</li>\n<li>\n<p><strong>动态运行时装入</strong></p>\n<p>装入程序将目标模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序执行时进行，在硬件地址变换机构的支持下，随着对每条指令或数据的访 问自动进行地址变换，故称为动态重定位</p>\n</li>\n</ol>\n<h4 id=\"422-程序的链接\"><a class=\"markdownIt-Anchor\" href=\"#422-程序的链接\">#</a> 4.2.2 程序的链接</h4>\n<p>分为三种</p>\n<ul>\n<li>\n<p>静态链接</p>\n</li>\n<li>\n<p>装入时动态链接</p>\n</li>\n<li>\n<p>运行时动态链接</p>\n<ol>\n<li>\n<p><strong>静态链接</strong></p>\n<p>直接将编译产生的模块和库函数模块链接在一起</p>\n<p>然后对其中的<strong>相对位置进行修改</strong>并<strong>变换外部调用符号</strong></p>\n</li>\n<li>\n<p>装入时动态链接</p>\n<p>在装入时 边装入边链接</p>\n<p>装入一个目标模块时，若发生一个外部模块调用事件，将引起装入程序去找出相应的外部目标模块，并将它装入内存</p>\n<p>便于修改和更新</p>\n<p>便于实现对目标模块的共享</p>\n</li>\n<li>\n<p>运行时动态链接</p>\n<p>指对某些目标模块的链接，是在程序执行中需要该目标模块时，由 OS 去找到该模块并将之装入内存并把它链接到调用者模块上</p>\n<p>可以加快程序的装入过程，节省大量内存空间</p>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"43-连续分配方式\"><a class=\"markdownIt-Anchor\" href=\"#43-连续分配方式\">#</a> 4.3 连续分配方式</h3>\n<p><strong>单一连续分配</strong>：将内存分为系统区和用户区 系统区给 OS 用户区给用户  用户区作为一整块给用户使用</p>\n<p><strong>固定分区分配</strong>：将内存用户空间划分成若若干个固定大小的区域，每个分区装入一道作业，有几个分区就可以同时有几道作业并发执行</p>\n<ul>\n<li>分区大小相等</li>\n<li>分区大小不等</li>\n</ul>\n<p>按分区大小排队，建立一张分区使用表</p>\n<ul>\n<li>内零头：分配给用户 但是用户没有使用</li>\n<li>外零头：因为太小而无法分配给用户</li>\n</ul>\n<p><strong>动态分区分配</strong></p>\n<p>分区分配中 分为空闲分区表和空闲分区链</p>\n<p><strong>分区分配算法</strong></p>\n<p><strong>首次适应算法</strong>：分配内存时，从<strong>链首开始顺序查找</strong>，直至找到一个大小能 满足要求的空闲分区为止；然后按照作业大小在该区划分所需空间，余下部分仍然放在空闲分区链中</p>\n<p><strong>循环首次适应算法</strong>：不从链首开始，<strong>从上次找到的空闲分区的下一 个空闲分区开始查找</strong>，找到为止； 将所有的空闲分区构成一个循环链表。采用 环查找方式，设置一个起始查寻指针，用于指示下一次起始查寻的空闲分区</p>\n<p>最佳适应算法：该算法要求将所有的空闲分区<strong>按其容量以从小到大的顺序</strong>形成一空闲分区链，每次找到刚好满足其容量的分区</p>\n<p><strong>分区回收</strong>：当进程运行完毕释放内存时，需合并相邻的空闲分区， 形成大的分区，称为合并技术。</p>\n<p><strong>伙伴系统</strong></p>\n<p>无论已分配分区或空闲分区，其 大小均为 2 的 k 次幂，k 为整数</p>\n<p>可重定位分区分配</p>\n<p>紧凑：将内存中的所有作业进行移动，使它们全都相邻接，这样， 可把原来分散的多个小分区合成一 个大分区的方法</p>\n<p>真正的访问地址 = 相对地址 + 重定位寄存器的地址 地址变换在访问时自动进行，所以称为动态重定位</p>\n<p>动态重定位分区分配算法：动态分区分配算法 + 紧凑</p>\n<h3 id=\"44-对换\"><a class=\"markdownIt-Anchor\" href=\"#44-对换\">#</a> 4.4 对换</h3>\n<p>对换：指把内存中暂时不能运行的进程或者暂时不用的程序和数据，调出到外存上， 以便腾出足够的内存空间，再把已具备运行条件的进程或进程所需要的程序和数据，调入内存</p>\n<p>要实现三个方面的功能</p>\n<ul>\n<li>对换空间的管理</li>\n<li>进程的换出</li>\n<li>进程的换入</li>\n</ul>\n<p>在外存中分为对换区和内存区，文件区采用<strong>离散分配方式</strong> (提高存储空间的利用率), 对换区采用<strong>连续分配方式</strong> (提高进程换入换出的速度)</p>\n<ul>\n<li>进程的换出：系统选择处于阻塞（或就绪）状态且优先级最低的进程作为换出进程，将该进程的程序和数据传送到磁盘的对换区上。便可回收该进程所占用的内存空间， 并对该进程的进程控制块 (PCB) 做相应的修改</li>\n<li>系统定时地查看所有进程的状态，从中找出 “就绪” 状态但已换出的进程，将其中换出时间最久的进程作为换入进程，将之换入</li>\n</ul>\n<h3 id=\"45-分页存储管理方式\"><a class=\"markdownIt-Anchor\" href=\"#45-分页存储管理方式\">#</a> 4.5 分页存储管理方式</h3>\n<p>页面：将一个进程的逻辑地址空间分成若干个大小相等的片</p>\n<p>物理块：把内存空间分成与页面相同大小的若干个存储块</p>\n<p>页面小：会提供内存利用率 但是会导致页面过长    使系统开销增大</p>\n<p>页面大：会增大页内碎片</p>\n<p>地址长度 32 位，0~11 位为页内地址，即每页大小为 4KB， 12~31 位为页号</p>\n<p>页表：实现从页号到物理块号的地址映射</p>\n<p>地址变换机构：实现从逻辑地址到物理地址的转换</p>\n<p>基本的：在系统中只设置一个<strong>页表寄存器 PTR</strong>，在其中存放页表在内存的始 址和页表的长度</p>\n<p>具有快表的：企图少访问一次内存，现在快表中看是否有当前页号 没有再去内存中找</p>\n<p>两级页表</p>\n<p><img src=\"https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/image-20230618145916929.png\" alt=\"两级页表\"></p>\n<h3 id=\"46-分段存储管理方式\"><a class=\"markdownIt-Anchor\" href=\"#46-分段存储管理方式\">#</a> 4.6 分段存储管理方式</h3>\n<p>满足用户和程序员的需要</p>\n<ul>\n<li>方便编程</li>\n<li>信息共享：在实现对程序和数据的共享时，是以信息的逻辑单位为基础的。</li>\n<li>信息保护：分段管理方式能更有效和方便地实现信息保护功能。</li>\n<li>动态增长：分段存储管理方式却能较好地解决数据段增长 。</li>\n<li>动态链接：先装入主程序段 然后当需要的时候才装入其他段</li>\n</ul>\n<p>其逻辑地址由段号（段名）和 段内地址所组成</p>\n<p>每个段在表中占有一个表项，其中记录了该段在 内存中的起始地址（又称为 “基址”）和段的长 度。</p>\n<p><img src=\"https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/image-20230618153845438.png\" alt=\"段\"></p>\n<p>分页和分段的主要区别:</p>\n<ul>\n<li>页是信息的物理单位，分页是为实现离散分配方 式，以消减内存的外零头，提高内存的利用率</li>\n<li>段则是信息的逻辑单位，它含有一组其意义相对 完整的信息。分段的目的是为了能更好地满足用 户的需要。</li>\n<li>页的大小固定且由系统决定，** 由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，** 因而在系统中只能有一种大小的页面</li>\n<li>段的长度却不固定，决定于用户所编写的程序， 通常由编译程序在对源程序进行编译时，根据信息的性质来划分。</li>\n<li>分页的作业地址空间是一维的，即单一的线性地址空间，程序员只需利用一个记忆符， 即可表示一个地址</li>\n<li>分段的作业地址空间则是二维的，程序员在 标识一个地址时，既需给出段名，又需给出 段内地址。</li>\n</ul>\n<p><strong>段页式系统</strong></p>\n<p>先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名</p>\n<p><strong>地址结构由段号、 段内页号 、页内地址三部分构成</strong></p>\n<p><img src=\"https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/image-20230618163642901.png\" alt=\"段页式\"></p>\n<p><img src=\"https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/image-20230618163730548.png\" alt=\"image-20230618163730548\"></p>\n<h3 id=\"47-虚拟存储期\"><a class=\"markdownIt-Anchor\" href=\"#47-虚拟存储期\">#</a> 4.7 虚拟存储期</h3>\n<p><strong>局部性原理:</strong></p>\n<ul>\n<li>程序执行时，除了少部分的转移和过程调用 指令外，在大多数情况下仍是顺序执行的</li>\n<li>过程调用将会使程序的执行轨迹由一部分区域转至另一部分区域，但经研究看出，过程调用的深度在大多数情况下都不超过 5 层。这就是说， <strong>程序将会在一段时间内都局限在这些过程的范围内运行</strong>。</li>\n<li>程序中存在许多循环结构，这些虽然只 由少数指令构成，但是它们将多次执行</li>\n<li>程序中还包括许多对数据结构的处理， 如对数组进行操作，它们往往都局限于很 小的范围内。</li>\n</ul>\n<p>局限性又分为<strong>时间局限性</strong>和<strong>空间局限性</strong></p>\n<p>时间局限因为程序存在大量的循环操作 空间局限程序在一定时间内所访问的地址都局限在小范围内</p>\n<p>虚拟存储器：具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统，其逻辑容量由内存容量和外存容量之和所决定，其运行速度接近于内存速度，而每位的成本却又接近于外存</p>\n<p>虚拟存储器的特征</p>\n<ul>\n<li>多次性:<strong> 一个作业被分成多次调入内存运行</strong>，在作业运行时只需将当前要运行的那部分程序和数据装入内存即可；当要运行时尚未调入的那部分程序 时，再将它调入</li>\n<li>对唤性:</li>\n<li>虚拟性：从逻辑上扩充内存容量</li>\n</ul>\n<h4 id=\"473-请求分页系统\"><a class=\"markdownIt-Anchor\" href=\"#473-请求分页系统\">#</a> 4.7.3 请求分页系统</h4>\n<p>程序只装入部分页面的程序和数据，然后启动运行，等运行到没有装入的程序和数据时再将页面装入内存</p>\n<p>实现请求分页系统需要提供硬件和软件支持</p>\n<ul>\n<li>页表机制增加若干项，表示页表的状态</li>\n<li>缺页中断机制</li>\n<li>地址变换机构</li>\n<li>软件：页面置换和请求调页</li>\n</ul>\n<h4 id=\"474-请求分段系统\"><a class=\"markdownIt-Anchor\" href=\"#474-请求分段系统\">#</a> 4.7.4 请求分段系统</h4>\n<p>先装入主程序段，然后通过调段功能和置换功能将不运行的段调出，再调入相应段</p>\n<p>与请求分页类似的硬件和软件支持</p>\n<h3 id=\"48-请求分页存储管理方式\"><a class=\"markdownIt-Anchor\" href=\"#48-请求分页存储管理方式\">#</a> 4.8 请求分页存储管理方式</h3>\n<p>页表添加字段</p>\n<ul>\n<li>状态位 P: 指示该页是否调入内存</li>\n<li>访问字段 A: 记录本页有多久未被访问</li>\n<li>修改位 M: 调入内存后是否被修改过</li>\n<li>外存地址：该页在外存上的地址</li>\n</ul>\n<p>缺页中断与普通中断的区别：</p>\n<ul>\n<li>在指令执行期间产生</li>\n<li>一条指令执行期间可以产生多次缺页中断</li>\n</ul>\n<h4 id=\"482-内存分配策略和分配算法\"><a class=\"markdownIt-Anchor\" href=\"#482-内存分配策略和分配算法\">#</a> 4.8.2 内存分配策略和分配算法</h4>\n<p>最小物理块数：最小为 2  有间接寻址最小为 3</p>\n<p>物理块的分配策略</p>\n<ul>\n<li>\n<p>固定分配局部置换</p>\n</li>\n<li>\n<p>可变分配全局置换</p>\n</li>\n<li>\n<p>可变分配局部置换</p>\n<ol>\n<li>\n<p><strong>固定分配局部置换</strong></p>\n<p>为每个进程分配确定数目的物理块，在整个运行期间都不再改变。</p>\n<p>如果进程在运行中发现缺页，则只能从该进程在内 存的 n 个页面中选出一页换出，然后再调入一页， 保证分配给进程的内存空间总量不变</p>\n<p>此时分配物理块，又包含了平均分配和按比例分配以及考虑优先权</p>\n<p>平局分配：将物理块平均分配给进程</p>\n<p>按比例分配：根据进程的大小按比例分配</p>\n<p>优先权：一部分按比例分，另一部分根据优先权分</p>\n</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li>\n<p><strong>可变分配全局置换</strong></p>\n<p>先为系统中的每个进程分配一定数目的物理块， 而 OS 自身也保持一个空闲物理块队列。</p>\n<p>当某进程缺页时，由系统从空闲物理块队列中， 取出一个物理块分配给该进程，并将欲调入的 （缺）页装入其中。这样，凡产生缺页（中断） 的进程，都将获得新的物理块</p>\n</li>\n<li>\n<p><strong>可变分配局部置换</strong></p>\n<p>为每个进程分配一定数目的物理块，但当某进程发现缺页时，只允许从该进程在内存的页面中选 出一页换出，这样就不会影响其它进程的运行。</p>\n<p>如果进程在运行中频繁地发生缺页中断，则系统 须再为该进程分配若干附加的物理块，直至该进 程的缺页率减少到适当程度为止。 若一个进程在运行过程中的缺页率特别低，则此 时可适当减少分配给该进程的物理块数，但不应 引起其缺页率的明显增加。</p>\n</li>\n</ol>\n<h4 id=\"483-调页策略\"><a class=\"markdownIt-Anchor\" href=\"#483-调页策略\">#</a> 4.8.3 调页策略</h4>\n<p><strong>何时调入页面</strong></p>\n<ul>\n<li>预调页：调入预计之后会访问的页面</li>\n<li>请求调页：收到调页请求就调一页</li>\n</ul>\n<p><strong>从何处调入页面</strong></p>\n<p>从对换区调入：对换区充足时，从对换区调入加快速度</p>\n<p>从文件区调入：对换区不充足时，如果没有修改从文件区调，修改了从对换区调</p>\n<p>调页过程：发中断 -&gt; 保留 CPU 环境 -&gt; 内存满了就先换出再调 -&gt; 修改页表项 P 为 1</p>\n<p>缺页率 f = 访问页面失败次数 / 总的访问次数</p>\n<h3 id=\"49-页面置换算法\"><a class=\"markdownIt-Anchor\" href=\"#49-页面置换算法\">#</a> 4.9 页面置换算法</h3>\n<p><strong>最佳置换算法</strong>:</p>\n<p>所选择被淘汰的页面，将是以后永不使用的，或许是在最长时间内不再被访问的页面。</p>\n<p>性能好，但是难以实现</p>\n<p><strong>先进先出算法:</strong></p>\n<p>总是淘汰在内存中驻留最久的页面</p>\n<p>把一个进程已调入内存的页面，按先后次序链接成一个队列，设置一个替换指针， 使它总是指向最老的页面</p>\n<p><strong>最近最少使用置换算法</strong>:</p>\n<p>该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 t，当需淘汰一 个页面时，选择现有页面中其 t 值最大的，即最近最久未使用的页面予以淘汰</p>\n<p>寄存器:</p>\n<p>用二进制，每 100ms 右移一位，每次访问将寄存器首位置 1, 如此最小的就是最近最少使用</p>\n<p>栈:</p>\n<p>每次被访问就从栈中取出并压入栈顶  栈底就是最近最少使用</p>\n<p><strong>Clock 置换算法</strong>:</p>\n<p>当采用简单 clock 算法时，只需为每页设置一位访问位， 再将内存中的所有页面都通过链接指针链接成一个循环队列。</p>\n<p>当某页被访问时，其访问位被置 1。置换算法在选择一页淘汰时，只需检查页的访问位。如果是 0，就选择该页换出；若为 1，则重新将它置 0，暂不换出，而给该页第二次驻留内存的机会，再按照 FIFO 算法检查下一个页面。</p>\n<p>相当于先进先出算法的更新版本，设置标志位给予继续驻留内存的机会</p>\n<p>改进 Clock</p>\n<p>设置标志位 A 和 M, 分别是访问过和修改过没</p>\n<p>（1）从指针所指示的当前位置开始，扫描循环队列，寻找 A=0 且 M=0 的第一类页面，将所遇到的第一个页面作为所 选中的淘汰页。在第一次扫描期间不改变访问位 A。</p>\n<p>（2）如果第一步失败，即查找一周后未遇到第一类页面， 则开始第二轮扫描，寻找 A=0 且 M＝1 的第二类页面，将 所遇到的第一个这类页面作为淘汰页。在第二轮扫描期间， 将所有扫描过的页面的访问位都置为 0。</p>\n<p>（3）如果第二步也失败，亦即未找到第二类页面，则将指 针返回到开始的位置，并将所有的访问位复 0。然后重复 第一步，如果仍失败，必要时再重复第二步，此时就一定 能找到被淘汰的页</p>\n<h3 id=\"410-请求分段存储管理方式\"><a class=\"markdownIt-Anchor\" href=\"#410-请求分段存储管理方式\">#</a> 4.10 请求分段存储管理方式</h3>\n<p>同样扩展其段表设置标志位</p>\n<p><img src=\"https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/image-20230618172210353.png\" alt=\"image-20230618172210353\"></p>\n<p><strong>分段的共享</strong></p>\n<p>添加共享段表，第一次申请共享段时，先给段分配物理区，并写入共享段表，第二次申请时候只需要将 count++ 并在共享段中增加表项</p>\n<p>共享段的回收，将 count-1 若 count=0 则回收此物理区</p>\n<p><strong>分段保护</strong></p>\n<p>越界检查 (通过段的长度)</p>\n<p>存取控制检查</p>\n<p>环保护机构</p>\n<h2 id=\"五-输入输出系统\"><a class=\"markdownIt-Anchor\" href=\"#五-输入输出系统\">#</a> 五 输入输出系统</h2>\n<p><img src=\"https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/image-20230618172748732.png\" alt=\"image-20230618172748732\"></p>\n<p>IO 系统的基本功能</p>\n<ul>\n<li>设备分配</li>\n<li>设备映射</li>\n<li>设备驱动</li>\n<li>I/O 缓冲区的管理</li>\n</ul>\n<p><img src=\"https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/image-20230618172832524.png\" alt=\"IO系统的层次结构\"></p>\n<p><img src=\"https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/image-20230618172900115.png\" alt=\"中断相关概念\"></p>\n<p>中断：指令完成后执行测试是否有中断请求 -&gt; 保存处理机环境 -&gt; 转入相应执行程序 -&gt; 执行中断处理 -&gt; 恢复被中断的现场</p>\n<p>对 I/O 设备的控制方式分为四种</p>\n<ul>\n<li>使用轮询的可编程 I/O</li>\n<li>使用中断的可编程 I/O</li>\n<li>直接存储器访问</li>\n<li>I/O 通道控制方式</li>\n</ul>\n<ol>\n<li>\n<p>使用轮询的可编程 I/O</p>\n<p>处理机向控制器发出一条 I/O 指令启动输入设备输 入数据时，同时把 busy 置为 1，并不断循环测试 busy。当 busy 为 0 说明读取完毕完成一次 I/O</p>\n<p><img src=\"https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/image-20230618173339834.png\" alt=\"image-20230618173339834\"></p>\n</li>\n<li>\n<p>中断方式</p>\n<p><img src=\"https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/image-20230618173400491.png\" alt=\"image-20230618173400491\"></p>\n</li>\n<li>\n<p>DMA 直接存储器访问</p>\n<p>只有在开始传输和结束传输的时候才需要 CPU 干预，其他时候都由 DMA 控制传输，每次传送至少一个数据块</p>\n</li>\n<li>\n<p>I/O 通道控制方式</p>\n<p>是 DMA 的发展，对一个数据块的读（或写）为单位的干预， 减少为对一组数据块的读（或写）及有关的控制和管理为单位的干预。</p>\n</li>\n</ol>\n<p>读取磁盘时间分为 寻道时间 + 旋转延迟时间 + 传输时间</p>\n<p><strong>磁盘调度</strong></p>\n<ul>\n<li>先来先服务：根据请求磁盘的先后顺序</li>\n<li>最短寻道优先：访问与当前磁头所在磁道最近的磁道</li>\n<li>扫描算法：先自里向外，直到没有更外面的需要访问再自外向里</li>\n<li>循环扫描算法：单向自里向外一直移动，到达最外面后再到最里面</li>\n</ul>\n<h2 id=\"六-文件系统\"><a class=\"markdownIt-Anchor\" href=\"#六-文件系统\">#</a> 六 文件系统</h2>\n<p><strong>文件</strong>：文件是由创建者所定义的、具有文件名的一组相关元素的集合</p>\n<p><strong>文件系统</strong>的：操作系统中的各类文件、管理文件的软件，以及管理文件所涉及到的数据结构等信息的集合。</p>\n<p><strong>文件系统的功能</strong>:</p>\n<ul>\n<li>有效地管理文件的存储空间；</li>\n<li>管理文件目录；</li>\n<li>完成文件的读 / 写操作；</li>\n<li>实现文件共享与保护；</li>\n<li>为用户提供交互式命令接口和程序调用接口。</li>\n</ul>\n<p>文件的逻辑结构：从用户观点出发所观察到的文件组织形式</p>\n<p>文件的物理结构：文件在外存上的存储组织形式</p>\n<p>存储空间的管理</p>\n<ul>\n<li>\n<p>连续分配’</p>\n<p>每一个文件分配一组相邻的盘块   连续读写多个数据块内容时性能较好</p>\n<p>优点：顺序访问容易，顺序访问速度快</p>\n<p>缺点：必须实现知道文件的大小 不利于文件大小的变化</p>\n</li>\n<li>\n<p>链接分配</p>\n<p>采用链接分配方式时，可通过在每个盘块上的链接指针，将同属于一个文件的多个离散的盘块链接成一 个链表，把这样形成的物理文件称为链接文件</p>\n<p>隐式链接：文件目录的每个目录项中 都含有指向第一个盘块和最后一个盘块的指针，在每个盘块中都含有指向下一个盘块的指针</p>\n<p>显示链接：这是指把用于链接文件各物理块的指针，显式地存放在内存的一张链接表中。 整个磁盘仅设置一张文件分配表（FAT）</p>\n<p><img src=\"https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/image-20230618175759390.png\" alt=\"image-20230618175759390\"></p>\n<p>因为查找过程在内存中进行，提高了检索速度</p>\n</li>\n<li>\n<p>索引分配</p>\n<p>FAT 不支持高效的直接存取 (需要顺序查找很多盘块号),FAT 占用较大的内存空间 (需要全部调入内存)</p>\n<p>为每个文件分配一个索引表，将盘块号记录在索引表中，只需要在目录项中填上指向该索引块的指针</p>\n<p>可以有多级索引</p>\n</li>\n</ul>\n<h3 id=\"63-文件存储空间的管理\"><a class=\"markdownIt-Anchor\" href=\"#63-文件存储空间的管理\">#</a> 6.3 文件存储空间的管理</h3>\n<p><strong>空闲分区表</strong></p>\n<p>系统也为外存上的所有空闲区建立一张空闲表，每个空闲区对应于一个空闲表项（对应连续分配）</p>\n<p>顺序查找空闲分区表中的表项直到找到第一个大小适合的空闲分区</p>\n<p><img src=\"https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/image-20230618180346272.png\" alt=\"image-20230618180346272\"></p>\n<p>优点：很快可以找到分区</p>\n<p>缺点：空闲分区表可能很大</p>\n<p>交换分区采用连续分配，文件较小采用连续分配，文件较大采用离散分配</p>\n<p><strong>空闲链表法</strong></p>\n<p>空闲链表法是将所有空闲盘区连成一条空闲链</p>\n<ul>\n<li>\n<p>空闲盘块链</p>\n<p><img src=\"https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/image-20230618180555164.png\" alt=\"image-20230618180555164\"></p>\n</li>\n<li>\n<p>空闲盘区链</p>\n<p><img src=\"https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/image-20230618180632885.png\" alt=\"image-20230618180632885\"></p>\n</li>\n</ul>\n<p>位示图法：利用二进制位 0、1 表示存储空间中存储块的使用状 态。空闲分区：0，已分配分区：1（或者相反）</p>\n<p><img src=\"https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/image-20230618180716069.png\" alt=\"image-20230618180716069\"></p>\n<p><img src=\"https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/image-20230618180728016.png\" alt=\"image-20230618180728016\"></p>\n<p><img src=\"https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/image-20230618180733876.png\" alt=\"image-20230618180733876\"></p>\n<h3 id=\"64-文件目录\"><a class=\"markdownIt-Anchor\" href=\"#64-文件目录\">#</a> 6.4 文件目录</h3>\n<p>文件控制块：用于描述和控制文件的数据结构</p>\n<p>文件目录：文件控制块的有序集合</p>\n<p>FCB 的内容</p>\n<ul>\n<li>基本信息</li>\n<li>地址信息</li>\n<li>访问控制信息</li>\n<li>使用信息</li>\n</ul>\n<p>文件的索引节点</p>\n<p>磁盘上建立了一个 i 节点表，其中的每个 i 节点对应一个文件，用于存放文件的属性参数：大小、类型、保护 模式、所有者、修改时间等。 文件被打开使用时，将文件的 i 节点从磁盘调入内存。 内存 i 节点除了包含磁盘 i 节点的所有内容外，还包含文 件当前的状态信息：是否上锁、修改标志、访问计数等。 文件使用完毕后，将该文件在内存中的 i 节点写回到磁 盘上保存</p>\n<p>目录的结构</p>\n<p>目录文件：一个目录也被看做是一个文件，即目录文件。 目录文件是由多个文件的目录项构成的一种特殊文件</p>\n<p>目录项的两种组织方式</p>\n<ul>\n<li>FCB 存储全部目录内容</li>\n<li>存储部分内容，其他部分存储在索引节点中</li>\n</ul>\n<p>目录的结构</p>\n<ul>\n<li>\n<p>单极目录结构：所有用户的全部文件目录保存在一张目录表中， 每个文件的目录项占用一个表项</p>\n<p>缺点：查找速度慢，不允许重名，不便于实现文件共享</p>\n</li>\n<li>\n<p>两级目录结构：包括主文件目录和用户文件目录</p>\n</li>\n<li>\n<p>多级目录结构：将目录将树一样组织起来</p>\n</li>\n</ul>\n<p>相对路径：从当前目录开始的路径名</p>\n<p>绝对路径：从根目录开始的路径名</p>\n<p>目录查询技术：线性检索和 hash</p>\n<h3 id=\"65-文件共享和访问控制\"><a class=\"markdownIt-Anchor\" href=\"#65-文件共享和访问控制\">#</a> 6.5 文件共享和访问控制</h3>\n<ul>\n<li>控制同时存取：允许多个用户同时读，但不允许同时修改，修改文件时应该作为临界资源加锁</li>\n<li>控制存取权限:</li>\n</ul>\n<p>实现文件共享的方式</p>\n<ul>\n<li>链接目录项实现法</li>\n<li>索引节点实现法</li>\n<li>符号链实现法</li>\n</ul>\n<ol>\n<li>\n<p>链接目录项实现法</p>\n<p><img src=\"https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/image-20230618204929542.png\" alt=\"image-20230618204929542\"></p>\n</li>\n<li>\n<p>索引节点实现法</p>\n<p><img src=\"https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/image-20230618205002483.png\" alt=\"image-20230618205002483\"></p>\n</li>\n<li>\n<p>符号链实现法</p>\n<p><img src=\"https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/image-20230618205115062.png\" alt=\"image-20230618205115062\"></p>\n</li>\n</ol>\n<h2 id=\"十一-进程与线程\"><a class=\"markdownIt-Anchor\" href=\"#十一-进程与线程\">#</a> 十一 进程与线程</h2>\n<ul>\n<li>进程：操作系统中拥有资源和独立运行的基本单位。</li>\n<li>进程的引入：实现单处理机环境下多程序并发的功能。</li>\n<li>线程的引入：提高多处理机环境下程序的并发程度。</li>\n</ul>\n<p>线程是一个被调度和分派的基本单位并可独立运行的实体</p>\n<p><img src=\"https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/image-20230618210245189.png\" alt=\"image-20230618210245189\"></p>\n<h1 id=\"linux\"><a class=\"markdownIt-Anchor\" href=\"#linux\">#</a> Linux</h1>\n<h2 id=\"常用指令\"><a class=\"markdownIt-Anchor\" href=\"#常用指令\">#</a> 常用指令</h2>\n<p>(1)  <code>ctrl c</code> : 取消命令，并且换行<br>\n (2)  <code>ctrl u</code> : 清空本行命令<br>\n (3)  <code>tab键</code> ：可以补全命令和文件名，如果补全不了快速按两下 tab 键，可以显示备选选项<br>\n (4)  <code>ls</code> : 列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件<br>\n (5)  <code>pwd</code> : 显示当前路径<br>\n (6)  <code>cd XXX</code> : 进入 XXX 目录下，cd … 返回上层目录<br>\n (7)  <code>cp XXX YYY</code> : 将 XXX 文件复制成 YYY，XXX 和 YYY 可以是一个路径，比如…/dir_c/a.txt，表示上层目录下的 dir_c 文件夹下的文件 a.txt<br>\n(8)  <code>mkdir XXX</code> : 创建目录 XXX<br>\n(9)  <code>rm XXX</code> : 删除普通文件；rm XXX -r: 删除文件夹<br>\n (10)  <code>mv XXX YYY</code> : 将 XXX 文件移动到 YYY，和 cp 命令一样，XXX 和 YYY 可以是一个路径；重命名也是用这个命令<br>\n (11)  <code>touch XXX</code> : 创建一个文件<br>\n (12)  <code>cat XXX</code> : 展示文件 XXX 中的内容</p>\n<h2 id=\"shell语法\"><a class=\"markdownIt-Anchor\" href=\"#shell语法\">#</a> shell 语法</h2>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">if…then形式\n\n单层if\n命令格式：\n\nif condition\nthen\n    语句1\n    语句2\n    ...\nfi\n示例：\n\na=3\nb=4\n\nif [ \"$a\" -lt \"$b\" ] &amp;&amp; [ \"$a\" -gt 2 ]\nthen\n    echo ${a}在范围内\nfi\n输出结果：\n\n3在范围内\n单层if-else\n命令格式\n\nif condition\nthen\n    语句1\n    语句2\n    ...\nelse\n    语句1\n    语句2\n    ...\nfi\n示例：\n\na=3\nb=4\n\nif ! [ \"$a\" -lt \"$b\" ]\nthen\n    echo ${a}不小于${b}\nelse\n    echo ${a}小于${b}\nfi\n输出结果：\n\n3小于4\n多层if-elif-elif-else\n命令格式\n\nif condition\nthen\n    语句1\n    语句2\n    ...\nelif condition\nthen\n    语句1\n    语句2\n    ...\nelif condition\nthen\n    语句1\n    语句2\nelse\n    语句1\n    语句2\n    ...\nfi\n示例：\n\na=4\n\nif [ $a -eq 1 ]\nthen\n    echo ${a}等于1\nelif [ $a -eq 2 ]\nthen\n    echo ${a}等于2\nelif [ $a -eq 3 ]\nthen\n    echo ${a}等于3\nelse\n    echo 其他\nfi\n输出结果：\n\n其他\ncase…esac形式\n类似于C/C++中的switch语句。\n\n命令格式\n\ncase $变量名称 in\n    值1)\n        语句1\n        语句2\n        ...\n        ;;  # 类似于C/C++中的break\n    值2)\n        语句1\n        语句2\n        ...\n        ;;\n    *)  # 类似于C/C++中的default\n        语句1\n        语句2\n        ...\n        ;;\nesac\n示例：\n\na=4\n\ncase $a in\n    1)\n        echo ${a}等于1\n        ;;  \n    2)\n        echo ${a}等于2\n        ;;  \n    3)                                                \n        echo ${a}等于3\n        ;;  \n    *)\n        echo 其他\n        ;;  \nesac<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">for…in…do…done\n命令格式：\n\nfor var in val1 val2 val3\ndo\n    语句1\n    语句2\n    ...\ndone\n示例1，输出a 2 cc，每个元素一行：\n\nfor i in a 2 cc\ndo\n    echo $i\ndone\n示例2，输出当前路径下的所有文件名，每个文件名一行：\n\nfor file in `ls`\ndo\n    echo $file\ndone\n示例3，输出1-10\n\nfor i in $(seq 1 10)\ndo\n    echo $i\ndone\n示例4，使用{1..10} 或者 {a..z}\n\nfor i in {a..z}\ndo\n    echo $i\ndone\nfor ((…;…;…)) do…done\n命令格式：\n\nfor ((expression; condition; expression))\ndo\n    语句1\n    语句2\ndone\n示例，输出1-10，每个数占一行：\n\nfor ((i=1; i&lt;=10; i++))\ndo\n    echo $i\ndone\nwhile…do…done循环\n命令格式：\n\nwhile condition\ndo\n    语句1\n    语句2\n    ...\ndone\n示例，文件结束符为Ctrl+d，输入文件结束符后read指令返回false。\n\nwhile read name\ndo\n    echo $name\ndone\nuntil…do…done循环\n当条件为真时结束。\n\n命令格式：\n\nuntil condition\ndo\n    语句1\n    语句2\n    ...\ndone\n示例，当用户输入yes或者YES时结束，否则一直等待读入。\n\nuntil [ \"${word}\" == \"yes\" ] || [ \"${word}\" == \"YES\" ]\ndo\n    read -p \"Please input yes/YES to stop this program: \" word\ndone\nbreak命令\n跳出当前一层循环，注意与C/C++不同的是：break不能跳出case语句。\n\n示例\n\nwhile read name\ndo\n    for ((i=1;i&lt;=10;i++))\n    do\n        case $i in\n            8)\n                break\n                ;;\n            *)\n                echo $i\n                ;;\n        esac\n    done\ndone\n该示例每读入非EOF的字符串，会输出一遍1-7。\n该程序可以输入Ctrl+d文件结束符来结束，也可以直接用Ctrl+c杀掉该进程。\n\ncontinue命令\n跳出当前循环。\n\n示例：\n\nfor ((i=1;i&lt;=10;i++))\ndo\n    if [ `expr $i % 2` -eq 0 ]\n    then\n        continue\n    fi\n    echo $i\ndone<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">每个进程默认打开3个文件描述符：\n\nstdin标准输入，从命令行读取数据，文件描述符为0\nstdout标准输出，向命令行输出数据，文件描述符为1\nstderr标准错误输出，向命令行输出数据，文件描述符为2\n可以用文件重定向将这三个文件重定向到其他文件中。\n\n重定向命令列表\n命令\t说明\ncommand &gt; file\t将stdout重定向到file中\ncommand &lt; file\t将stdin重定向到file中\ncommand &gt;&gt; file\t将stdout以追加方式重定向到file中\ncommand n&gt; file\t将文件描述符n重定向到file中\ncommand n&gt;&gt; file\t将文件描述符n以追加方式重定向到file中\n输入和输出重定向\necho -e \"Hello \\c\" &gt; output.txt  # 将stdout重定向到output.txt中\necho \"World\" &gt;&gt; output.txt  # 将字符串追加到output.txt中\n\nread str &lt; output.txt  # 从output.txt中读取字符串\n\necho $str  # 输出结果：Hello World\n同时重定向stdin和stdout\n创建bash脚本：\n\n#! /bin/bash\n\nread a\nread b\n\necho $(expr \"$a\" + \"$b\")\n创建input.txt，里面的内容为：\n\n3\n4\n执行命令：\n\nacs@9e0ebfcd82d7:~$ chmod +x test.sh  # 添加可执行权限\nacs@9e0ebfcd82d7:~$ ./test.sh &lt; input.txt &gt; output.txt  # 从input.txt中读取内容，将输出写入output.txt中\nacs@9e0ebfcd82d7:~$ cat output.txt  # 查看output.txt中的内容\n7<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n",
            "tags": [
                "复习"
            ]
        }
    ]
}