{
    "version": "https://jsonfeed.org/version/1",
    "title": "YogMas学习站 • All posts by \"c语言\" tag",
    "description": "",
    "home_page_url": "http://yogmas-wang.top",
    "items": [
        {
            "id": "http://yogmas-wang.top/2021/11/06/c-yu-yan/",
            "url": "http://yogmas-wang.top/2021/11/06/c-yu-yan/",
            "title": "C语言",
            "date_published": "2021-11-05T16:00:00.000Z",
            "content_html": "<h1 id=\"c语言\"><a class=\"markdownIt-Anchor\" href=\"#c语言\">#</a> C 语言</h1>\n<!-- The Article Made by YogMas -->\n<h2 id=\"the-article-made-by-yogmas\"><a class=\"markdownIt-Anchor\" href=\"#the-article-made-by-yogmas\">#</a> The Article Made by YogMas</h2>\n<p>推荐用书: C Primer Plus (本文章绝大部分内容来自于关于此书的学习过程中记录 还有部分来自于 C 语言程序设计第二版 以及 UESTC MOOC)</p>\n<h3 id=\"c语言的执行过程\"><a class=\"markdownIt-Anchor\" href=\"#c语言的执行过程\">#</a> C 语言的执行过程</h3>\n<p>1. 预处理：可以给程序添加内容也可以修改程序 (例如: #include&lt;stdio.h&gt; 就会在预处理中运用 stdio.h 中的内容对源代码进行处理)<br>\n 2. 编译：将预处理过的语言转变为机器指令.<br>\n3. 链接：把编译器产生的目标代码和所需的其他附加代码整合到一起，产生最终完全可执行的程序.<br>\n(这三个过程是自动实现的)</p>\n<h3 id=\"c语言开始\"><a class=\"markdownIt-Anchor\" href=\"#c语言开始\">#</a> C 语言开始</h3>\n<h4 id=\"基本结构\"><a class=\"markdownIt-Anchor\" href=\"#基本结构\">#</a> 基本结构</h4>\n<blockquote>\n<p>指令<br>\n int main (void)<br>\n{<br>\n语句<br>\n}</p>\n</blockquote>\n<h4 id=\"指令\"><a class=\"markdownIt-Anchor\" href=\"#指令\">#</a> 指令</h4>\n<p>例如 #include &lt;stdio.h&gt; 这条指令说明在编译前将 &lt; stdio.h &gt; 中的信息包含到程序中</p>\n<h4 id=\"函数\"><a class=\"markdownIt-Anchor\" href=\"#函数\">#</a> 函数</h4>\n<p>函数分为两类，一类是程序员写的函数，一类是作为 C 语言实现的一部分提供的函数，我们把后者称为库函数。</p>\n<h4 id=\"语句\"><a class=\"markdownIt-Anchor\" href=\"#语句\">#</a> 语句</h4>\n<p>一种是调用语句 例如 printf (\"\"); 就是调用打印函数，将内容打印在屏幕上</p>\n<p>一种是返回语句<br>\n<strong> C 语言的每条语句都要以；结尾</strong></p>\n<h4 id=\"注释\"><a class=\"markdownIt-Anchor\" href=\"#注释\">#</a> 注释</h4>\n<blockquote>\n<pre><code>/*     */ \n</code></pre>\n</blockquote>\n<p>注释中的内容不会计入到程序中，只是方便程序员观看理解内容</p>\n<p>“盒子形状” 注释</p>\n<blockquote>\n<pre><code>    /*************************\n    *                        *\n    *                        *\n    *************************/\n</code></pre>\n</blockquote>\n<p>如此可以方便程序员更好地观察到注释</p>\n<p>C99 提供了另一种注释的方法</p>\n<blockquote>\n<pre><code>// XXXXXXXXX\n  双斜杠注释\n   这种风格的注释会在行末自动终止，注释第二行还应该添加双斜杠\n</code></pre>\n</blockquote>\n<p>优点：多行 // 可以让注释更加醒目，由于每一行都必须添加 // 可以有效防止注释吞没程序的事情发生</p>\n<h4 id=\"变量和赋值\"><a class=\"markdownIt-Anchor\" href=\"#变量和赋值\">#</a> 变量和赋值</h4>\n<p>程序进行一系列的运算，会有一种临时存储数据的方法，这种储存单元被称为变量</p>\n<h4 id=\"类型\"><a class=\"markdownIt-Anchor\" href=\"#类型\">#</a> 类型</h4>\n<p>每个变量都有一个类型，来说明所储存的数据的种类<br>\n列入 int (整数) 类型和 float (小数) 类型</p>\n<p>同时 float 类型可以储存的数可以比 int 大很多，但是坏处就是 float 的计算可能更加缓慢，而且会造成一定量的误差</p>\n<h4 id=\"声明\"><a class=\"markdownIt-Anchor\" href=\"#声明\">#</a> 声明</h4>\n<p>声明变量首先确定变量的类型，然后说明变量的名字<br>\n eg int height<br>\nint 就是变量的类型，而 height 就是变量的名字<br>\n<strong> main 的声明要放在语句之前</strong></p>\n<h4 id=\"赋值\"><a class=\"markdownIt-Anchor\" href=\"#赋值\">#</a> 赋值</h4>\n<p>变量通过赋值语句获得值</p>\n<blockquote>\n<pre><code>eg: height=8\n</code></pre>\n</blockquote>\n<p>这种确定的数值称为常量<br>\n赋值右侧可以是一个含有常量，变量和运算符的公式，在 C 语言中称为<strong>表达式</strong></p>\n<h4 id=\"显示变量的值\"><a class=\"markdownIt-Anchor\" href=\"#显示变量的值\">#</a> 显示变量的值</h4>\n<blockquote>\n<p>eg:pritnf(\"%d \\n\",height)</p>\n</blockquote>\n<p>这里 % d 是一个占位符，用来指明在显示过程中变量 height 的显示位置</p>\n<p>% d 只用于 int     % f 用于 float 类型变量 f 显示小数点后六位，没有的用 0 补齐<br>\n<strong>注意声明和赋值可以同时进行</strong></p>\n<blockquote>\n<p>eg: int weight=8</p>\n</blockquote>\n<p>需要注意的是，以下这种情况只有 width 拥有初始化器 10</p>\n<blockquote>\n<p>int height,length,width=10</p>\n</blockquote>\n<h4 id=\"宏定义给常量命名\"><a class=\"markdownIt-Anchor\" href=\"#宏定义给常量命名\">#</a> 宏定义给常量命名</h4>\n<blockquote>\n<p>eg:#define INCHES 166</p>\n</blockquote>\n<p>在后面的程序中所有的 INCHES 都会被替换成 166，这里需要注意的，一般宏定义的名称都用大写字母表示，这里没有硬性规定，但这是程序员遵循了几十年的基本准则，可以方便程序更方便的阅读<br>\n同样后面的 166 也可以为一个表达式，表达式建议用括号括上<br>\n<strong>注意 C 语言四舍五入时向下取整</strong></p>\n<h4 id=\"标识符\"><a class=\"markdownIt-Anchor\" href=\"#标识符\">#</a> 标识符</h4>\n<p>在编写程序时，需要进行大量的命名，这些名字被称为<strong>标识符</strong>，在 C 语言中标识符可以有字母，数字，和下划线，但是必须<strong>以字母或者下划线开头</strong></p>\n<p>同时标识符是区分大小写的也就是说 JOB 和 job 是两个完全不同的标识符</p>\n<h4 id=\"关键字\"><a class=\"markdownIt-Anchor\" href=\"#关键字\">#</a> 关键字</h4>\n<p>关键字对 C 编译器有着特殊的意义，因此这些关键字不能作为标识符来使用</p>\n<p><a href=\"https://imgtu.com/i/IQ9uZQ\"><img src=\"https://z3.ax1x.com/2021/11/06/IQ9uZQ.md.jpg\" alt=\"IQ9uZQ.md.jpg\"></a></p>\n<h4 id=\"书写规范\"><a class=\"markdownIt-Anchor\" href=\"#书写规范\">#</a> 书写规范</h4>\n<p>语句可以分开放在任意多行内。<br>\n记号间的宫格可以让我们更容易区分记号，基于这个原因，我通常会在每个运算符的前后都放上一个空格</p>\n<blockquote>\n<pre><code> eg volume = height * width * length\n</code></pre>\n</blockquote>\n<p>缩进有助于轻松识别程序嵌套</p>\n<p>空行可以把程序分为逻辑单元，从而使读者更容易辨别程序的结构，没有空行的程序很难阅读，就像不分章节的书一样.</p>\n<h3 id=\"格式化输入输出\"><a class=\"markdownIt-Anchor\" href=\"#格式化输入输出\">#</a> 格式化输入 / 输出</h3>\n<h4 id=\"printf函数\"><a class=\"markdownIt-Anchor\" href=\"#printf函数\">#</a> printf 函数</h4>\n<blockquote>\n<pre><code>   printf(\" i = %d , j = %d\",i,j);\n   printf(格式化字符串,表达式1，表达式2,...;)\n</code></pre>\n</blockquote>\n<p>格式化字母串包含<strong>普通字符</strong>和<strong>转换说明</strong><br>\n转换说明以 % 开头，% 后面的信息指定了把数值从内部形式转换为打印字母的方法<br>\n eg:% d 表示把 int 型数值从二进制转换成十进制的字符串</p>\n<p>注意编译器不会检测格式串中转换说明的数量是否和输出项的数量相匹配，但是如果多于或者少于会让程序简单地无意义地输出<br>\n如果转换说明的个数小于变量数，多的变量就无法显示出来<br>\n变量和占位符不匹配时，就是显示出一个无意义的数值.<br>\n<a href=\"https://imgtu.com/i/IQ9FPI\"><img src=\"https://z3.ax1x.com/2021/11/06/IQ9FPI.png\" alt=\"IQ9FPI.png\"></a></p>\n<h5 id=\"转换说明\"><a class=\"markdownIt-Anchor\" href=\"#转换说明\">#</a> 转换说明</h5>\n<h5 id=\"标志\"><a class=\"markdownIt-Anchor\" href=\"#标志\">#</a> 标志</h5>\n<p>-: 左对齐，也就是加空格或 0 时加在后面<br>\n不加 - 默认为右对齐，也就是加空格或 0 时加在前面</p>\n<p>0: 加 0 表示用空格代替 0，不加 0 时输出的值多的用空格代替</p>\n<h6 id=\"最小栏宽m\"><a class=\"markdownIt-Anchor\" href=\"#最小栏宽m\">#</a> 最小栏宽 m</h6>\n<p>最小栏宽 m 指定了要显示的最少字符数量 (<strong>m 表示了输出的数最少占几列</strong>)，如果要系那是的字符数少于 m，那么值在字段内是右对齐的 (换句话说，在值得前面显示空格)<br>\n 例如 %4d 将以<strong>空格 123</strong> 的形式显示数 123，如果要显示的值所需字符多于 m，那么栏宽会自动拓展为所需的尺寸。因此，转换说明 %4d 将以 12345 的形式显示数 12345，而不会丢失数字。在 m 前放上一个负号，会导致左对齐；转换说明 %-4d 将以<strong> 123 空格</strong>的形式显示 123</p>\n<h6 id=\"精度p\"><a class=\"markdownIt-Anchor\" href=\"#精度p\">#</a> 精度 p</h6>\n<p>精度的含义很难 6+<br>\n+ 描述，因为他依赖于转换指定符号<br>\n d:p 指明了待限制数字的最少个数 (包括空格)<br>\n, 如果省略 p，则默认它的值为 1<br>\ne: 表示科学计数法形式的浮点数。p 指明了小数点后应该出现的数字个数 (默认值为 6) 如果 p 为 0 则不显示小数点<br>\n g: 自动选 f 格式或 e 格式中较短的一种输出，且不输出无意义的 0<br>\no：无符号数转化为八进制数<br>\n x：无符号数转化为十六进制数<br>\n<a href=\"https://imgtu.com/i/IQ9ARP\"><img src=\"https://z3.ax1x.com/2021/11/06/IQ9ARP.png\" alt=\"IQ9ARP.png\"></a><br>\n<a href=\"https://imgtu.com/i/IQ9Exf\"><img src=\"https://z3.ax1x.com/2021/11/06/IQ9Exf.png\" alt=\"IQ9Exf.png\"></a></p>\n<h5 id=\"转义序列\"><a class=\"markdownIt-Anchor\" href=\"#转义序列\">#</a> 转义序列</h5>\n<p>警报响铃符:    \\a<br>\n 回退符:     \\b<br>\n 换行符:     \\n<br>\n 水平制表符：   \\t<br>\n“:”( \\  + 特殊字符 = 特殊字符 )</p>\n<h4 id=\"scanf函数\"><a class=\"markdownIt-Anchor\" href=\"#scanf函数\">#</a> scanf 函数</h4>\n<blockquote>\n<p>scanf (\"&amp;d\", 变量名)</p>\n</blockquote>\n<p>scanf 函数起到读取用户输入到屏幕的数据<br>\n pritnf 函数起到将程序中的数据显示到屏幕上的作用<br>\n scanf 与 prinf 函数是相对的<br>\n scanf 函数的工作原理 这里不一一叙述<br>\n可见程序与设计第 32 页 3.2.1</p>\n<p>另外 % i 也可以充当整数的占位符，在 printf 中与 % d 没有区别，但是在 scanf 中 % i 可以储存 10 进制，8 进制，16 进制的数字，而 % d 只能储存 10 进制的数字，如果输入的数前面有 0 那么 % i 会当成 8 进制处理，如果前面有 0x 那么输入的数会当成 16 进制处理，所以一般情况下我们坚持使用 % d，防止因为在数字前面加入 0 而导致数据识别错误</p>\n<h4 id=\"表达式\"><a class=\"markdownIt-Anchor\" href=\"#表达式\">#</a> 表达式</h4>\n<h5 id=\"算术运算符\"><a class=\"markdownIt-Anchor\" href=\"#算术运算符\">#</a> 算术运算符</h5>\n<blockquote>\n<p>一元运算符: + 正号  - 负号<br>\n二元运算符: + 加法 - 减法  * 乘法  / 除法 % 求余</p>\n</blockquote>\n<p>可能产生的意外结果</p>\n<blockquote>\n<p>两个操作数都是整数时，结果会进行四舍五入，例如 1/2 的结果是 0 而不是 0.5<br>\n% 要求操作数是整数 如果两个操作数中有一个不是整数，程序将无法编译通过<br>\n根据 C89 标准，如果两个运算符中有一个为负数，那么结果不确定，可能向上取整，也可能向下取整<br>\n在 C99 标准中 除法的结果总是趋向 0 截取    i% j 的结果的值得负号与 i 相同 例如 - 9%7 的结果为 - 2</p>\n</blockquote>\n<h5 id=\"优先级和结合性\"><a class=\"markdownIt-Anchor\" href=\"#优先级和结合性\">#</a> 优先级和结合性</h5>\n<blockquote>\n<p>最高优先级: + - (一元运算符)  *  /  %<br>\n 最低优先级:    +  -  (二元运算符)</p>\n</blockquote>\n<p>当有多个相同优先级的符号时，从左到右依次结合.<br>\n<a href=\"https://imgtu.com/i/IQ99VH\"><img src=\"https://z3.ax1x.com/2021/11/06/IQ99VH.png\" alt=\"IQ99VH.png\"></a></p>\n<h5 id=\"赋值运算符\"><a class=\"markdownIt-Anchor\" href=\"#赋值运算符\">#</a> 赋值运算符</h5>\n<p>求出表达式的值后，将值储存在变量中，就需要对变量进行赋值</p>\n<p>如果变量表示的含义和所输入的数字不同，将会把数字改成变量所对应的数字<br>\n例如: int i=72.999   这个时候 i 对应的值就是 72 而不是 72.999</p>\n<p>多个运算符可以串联在一起<br>\n i = j = k = 0;<br>\n 需要注意的是，赋值表达式是从右开始赋值的<br>\n i = (j = (k = 0))</p>\n<h5 id=\"左值\"><a class=\"markdownIt-Anchor\" href=\"#左值\">#</a> 左值</h5>\n<p>大多数 C 语言运算符允许他们的操作数是变量，常量，或者是其他运算符表达式，但是他们的<strong>左值</strong>必须是对象</p>\n<p>目前为止<strong>变量</strong>是唯一的左值</p>\n<h5 id=\"复合赋值\"><a class=\"markdownIt-Anchor\" href=\"#复合赋值\">#</a> 复合赋值</h5>\n<blockquote>\n<p>复合运算符 -=,*=,/=,%=,+=<br>\n 另外 5 种赋值运算符将在后面的章节中介绍</p>\n</blockquote>\n<p>v += e 表示 v 加上 e 再把结果储存在 v 中<br>\n这并不等价于 v = v+e 例如变量 i*=j+k 就不等于 i= i*j + k</p>\n<p>复合赋值运算符同样也是右结合的<br>\n语句 i += j += k 表示 i += (j += k)</p>\n<p>最常使用的两种运算是 自增和自减<br>\n例如 i = i + 1 而复合运算符可以缩短这串代码 可以改写为 i += 1</p>\n<h5 id=\"自增运算符和自减运算符\"><a class=\"markdownIt-Anchor\" href=\"#自增运算符和自减运算符\">#</a> 自增运算符和自减运算符</h5>\n<p>C 语言还允许使用 ++ (自增) 和 – (自减) 运算符将这些语句缩得更短<br>\n实际上自增和自减运算符的使用非常复杂，原因是 ++ 和 -- 既可以作为前缀，也可以作为后缀，根据实际使用情况而定</p>\n<p>而这种情况实际上是有副作用的，副作用的效果就是自增 i</p>\n<p>前缀自增和后缀自增的区别：前缀自增表示先自增 i 再将变量 i 代入表达式中，后缀自增表示先把变量 i 代入表达式中，再自增 i</p>\n<p>并且在同一个句子中多次使用 ++ 和 -- 往往难以理解，例如<br>\n i = 1; j = 2 ; k = <ins>i + j</ins>;</p>\n<p>后缀<ins>和 -- 优先级 比正号和负号高，并且都是左结合<br>\n前缀</ins>和 -- 优先级和正号负号相同，并且都是右结合</p>\n<h4 id=\"选择语句\"><a class=\"markdownIt-Anchor\" href=\"#选择语句\">#</a> 选择语句</h4>\n<h5 id=\"逻辑表达式\"><a class=\"markdownIt-Anchor\" href=\"#逻辑表达式\">#</a> 逻辑表达式</h5>\n<p>测试表达式的结果是 \"真\" 还是 \"假\"，这类表达式只有这两个效果，翻译为电脑语言就是这个表示只会输出两个值 0 或者 1<br>\n<a href=\"https://imgtu.com/i/IQ9ZM8\"><img src=\"https://z3.ax1x.com/2021/11/06/IQ9ZM8.png\" alt=\"IQ9ZM8.png\"></a><br>\n 逻辑运算符对操作数进行短路计算，这些运算符首先计算出左操作数的值，然后计算出右操作数的值，如果做操作数的值可以直接推导表达式的值，那么将不计算右操作数的值</p>\n<p>运算符！的优先级等于一元正负号的优先级，而运算符 &amp;&amp; 和 || 的优先级低于关系运算符和判等运算符，运算符！是右结合的，而运算符 &amp;&amp; 和运算符 || 是左结合的.</p>\n<h5 id=\"关系运算符\"><a class=\"markdownIt-Anchor\" href=\"#关系运算符\">#</a> 关系运算符</h5>\n<p><a href=\"https://imgtu.com/i/IQ9PIA\"><img src=\"https://z3.ax1x.com/2021/11/06/IQ9PIA.png\" alt=\"IQ9PIA.png\"></a></p>\n<p>需要注意的是 i &lt; j &lt; k 并不是所想象的 j 处在 i 和 k 的中间值得意思，表达式是左结合的<br>\n所以原式式 (i &lt; j) &lt; k  先对 i &lt; j 进行判定，输出 0 或者 1 来和 k 进行比较</p>\n<h5 id=\"判等运算符\"><a class=\"markdownIt-Anchor\" href=\"#判等运算符\">#</a> 判等运算符</h5>\n<p><a href=\"https://imgtu.com/i/IQ9esS\"><img src=\"https://z3.ax1x.com/2021/11/06/IQ9esS.png\" alt=\"IQ9esS.png\"></a></p>\n<p>i &lt;j == j &lt; k 等价于 (i &lt; j) == (j &lt; k)<br>\n 只有当 两边同为真或者同为假的时候 输出结果为真</p>\n<h5 id=\"运算顺序\"><a class=\"markdownIt-Anchor\" href=\"#运算顺序\">#</a> 运算顺序</h5>\n<p>C 语言对括号的运算顺序没有进行规定，所以因为编译器的不同可能出现不同的结果<br>\n例如 a = 5 ;<br>\nc = (b = a + 2 ) - ( a = 1 )<br>\n 先算 b = a + 2 还是先算 a = 1 不同的编译器有着不一样的算法，所以如果编译器不同，可能产生不一样的结果</p>\n<p>注意不要依赖特定的运算顺序</p>\n<p>例如: i = 2 ;  j = i * i++;<br>\n 大部分人可能会认为输出的结果是 4，其实也可能为 6，不同的编译器有时候会出现不同的结果<br>\n最好的方法就是将长的运算表达式转化为短的运算表达式，如此就可以适应不同的编译器.</p>\n<h4 id=\"if语句\"><a class=\"markdownIt-Anchor\" href=\"#if语句\">#</a> if 语句</h4>\n<blockquote>\n<p>if (表达式) 语句</p>\n</blockquote>\n<p>注意表达式两边的括号是必须的<br>\n计算时先计算括号内表达式的值，如果表达式的值非零也就是真值，那么接着执行括号后面的语句.<br>\n 一定要注意区分 ==(判等) 和 =(赋值)<br>\n 前面我们说了例如 i &lt; j &lt; k 这样的写法是不行的，为了判定变量是否落在某个数值范围内，例如为了判定 0≤ i &lt; n 我们可以写成</p>\n<blockquote>\n<p>if (0 &lt;= i &amp;&amp; i&lt; n) …</p>\n</blockquote>\n<p>|| 运算符也是相同的道理</p>\n<h5 id=\"复合语句\"><a class=\"markdownIt-Anchor\" href=\"#复合语句\">#</a> 复合语句</h5>\n<p>在 if 语句模板中，语句是一条语句而不是多条语句，如果想用 if 语句处理多条语句，我们引入了复合语句.<br>\n 复合语句由一对花括号和语句混合而成，可以有多个声明和多个语句，也可以什么都没有<br>\n为了表示清楚，通常将一条语句放在多行内，每行有一条语句，如下所示:<br>\n{<br>\nline_num = 0;<br>\npage_num++;<br>\n}<br>\n 注意，每条内部语句依然以<strong>分号</strong>结尾</p>\n<h5 id=\"else子句\"><a class=\"markdownIt-Anchor\" href=\"#else子句\">#</a> else 子句</h5>\n<p>if 语句可以有 else 子句</p>\n<blockquote>\n<p>if (表达式) 语句 else 语句</p>\n</blockquote>\n<p>注意，出现的语句末尾都要以<strong>分号</strong>结尾</p>\n<p>通常来说为了布局美观，和清楚显示代码，我们将 if 和 else 放在同一列，其内的内部语句同样进行缩进<br>\n可以为复合语句增加花括号，这不是必需的但是能够使复合语句更加清楚.</p>\n<h4 id=\"条件表达式\"><a class=\"markdownIt-Anchor\" href=\"#条件表达式\">#</a> 条件表达式</h4>\n<blockquote>\n<p>表达式 1 ? 表达式 2 : 表达式 3</p>\n</blockquote>\n<p>表达式 1,2,3 可以是任何类型的表达式，同时条件表达式被经常称为三元运算符.</p>\n<p>条件表达式读作 如果表达式 1 成立，那么表达式 2，否则表达式 3<br>\n 求值步骤为：首先计算出表达式 1 的值，如果此值不为 0，那么计算表达式 2 的值，并且计算出来的值就是整个表达式的值，如果表达式 1 的值为 0，那么表达式 3 的值是整个条件表达式的值</p>\n<p>条件表达式通常运用于 printf 中进行简化代码</p>\n<p>例如 if (i&gt; j ) printf (\"% d \\n\",i); else printf (\"% d \\n\",j);<br>\n 可以简化为  printf (\"% d \\n\",i&gt;j?i:j);<br>\n 同时在 return 中也经常使用，使用场景类似</p>\n<h4 id=\"switch语句\"><a class=\"markdownIt-Anchor\" href=\"#switch语句\">#</a> switch 语句</h4>\n<p>通常来说可以用 switch 语句来代替级联式 if 语句</p>\n<blockquote>\n<p>switch (表达式) {<br>\ncase 常量表达式：语句<br>\n…<br>\ncase 常量表达式：语句<br>\n default : 语句<br>\n}</p>\n</blockquote>\n<p>同样这里的语句也要以<strong>分号</strong>结尾<br>\n<a href=\"https://imgtu.com/i/IQ9mqg\"><img src=\"https://z3.ax1x.com/2021/11/06/IQ9mqg.jpg\" alt=\"IQ9mqg.jpg\"></a></p>\n<p>switch 语句实际上是一种给予计算的跳转。对控制表达式求值时， 控制会跳转到与 switch 表达式的值相匹配的分支标号处。在执行完一个分支后，程序控制向下跳转到下一个分支的第一条语句上，如果没有 break 语句，控制将从一个分支继续流向下一个分支。例如<br>\n switch (grade) {<br>\ncase 4 :printf (“Excellent”);<br>\ncase 3 :printf (“Good”);<br>\ncase 2 :printf (“Average”);<br>\ncase 1 :printf (“poor”);<br>\ncase 0 :printf (“Falling”);<br>\ndefault : printf (“Illegal grade”)<br>\n}<br>\n 当你输入 3 时，显示的消息是：GoodAveragePoorFailingIllegal grade</p>\n<h3 id=\"循环\"><a class=\"markdownIt-Anchor\" href=\"#循环\">#</a> 循环</h3>\n<h4 id=\"while语句\"><a class=\"markdownIt-Anchor\" href=\"#while语句\">#</a> while 语句</h4>\n<blockquote>\n<pre><code>[while语句]:    while (表达式) 语句\n例如: while(i&lt;n) i=i*2;\n</code></pre>\n</blockquote>\n<p>因为 while 语句中有循环，为了让循环更简单，我们可以将 i++ 或者 i–直接加到 printf 中来使代码更加简洁</p>\n<blockquote>\n<pre><code>例如: while(i&gt;0) printf(\"%d \\n\",i--)\n这串代码可以一直输出0~i的数字，是不是这样更加简洁\n</code></pre>\n</blockquote>\n<h4 id=\"do语句\"><a class=\"markdownIt-Anchor\" href=\"#do语句\">#</a> do 语句</h4>\n<p>do 语句在本质上其实就是 while 语句只不过其控制表达式是在每次执行完循环体之后进行判定.</p>\n<blockquote>\n<pre><code>[do语句]: do 语句  while(表达式):\n</code></pre>\n</blockquote>\n<p>do 语句的循环体必须是一条语句和 while 一样，当然如果想用多条语句可以用复合语句.</p>\n<p>执行 do 语句时，先执行循环体，再计算控制表达式的值</p>\n<h4 id=\"for语句\"><a class=\"markdownIt-Anchor\" href=\"#for语句\">#</a> for 语句</h4>\n<blockquote>\n<pre><code>[for语句]    for(表达式1或者声明;表达式2;表达式3)\n</code></pre>\n</blockquote>\n<p><a href=\"https://imgtu.com/i/IQpd8P\"><img src=\"https://z3.ax1x.com/2021/11/06/IQpd8P.png\" alt=\"IQpd8P.png\"></a></p>\n<p>对于向上增或向下减的循环来说，for 语句通常是最好的选择</p>\n<p>从 0 向上加到 n-1</p>\n<blockquote>\n<pre><code>for (i=0;i&lt;n;i++)\n</code></pre>\n</blockquote>\n<p>从 1 向上加到 n</p>\n<blockquote>\n<pre><code>for(i=1;i&lt;=n,i++)\n</code></pre>\n</blockquote>\n<p>等等同理</p>\n<p>如果所需要的语句没有那么多，for 语句允许省略语句，注意，即使省略了表达式，括号中也许有两个<strong>分号</strong><br>\n当 for 语句同时省略第一个和第三个表达式时，那么他和 while 语句没有任何区别<br>\n省略第一个语句时，程序会默认为真值，会一直循环下去</p>\n<p>在 C99 中第一个表达式可以替换成一个声明，但在 for 语言中的声明，仅可以在 for 语句内部使用，在 for 循环的外部不可用</p>\n<p>同时 for 语言中可以声明多个变量，但是他们的类型需要相同</p>\n<h4 id=\"逗号运算符\"><a class=\"markdownIt-Anchor\" href=\"#逗号运算符\">#</a> 逗号运算符</h4>\n<blockquote>\n<pre><code>[逗号表达式] 表达式1,表达式2\n</code></pre>\n</blockquote>\n<p>第一步计算出表达式 1 的值，抛弃。第二部计算出表达式 2 的值，并将表达式 2 的值作为整个表达式的值，需要注意的是这里并不是说表达式 1 的值并没有用，表达式 1 中例如 i++，i–等仍然会对表达式 2 中的 i 和 j 造成一定的影响</p>\n<p>逗号运算符是左结合的，并且逗号运算符的优先级比其他所有运算符的优先级都更低</p>\n<p>for 语句是唯一可以发现逗号运算符的地方.<br>\nfor 语句可以利用逗号表达式来声明更多的变量</p>\n<h3 id=\"跳出循环\"><a class=\"markdownIt-Anchor\" href=\"#跳出循环\">#</a> 跳出循环</h3>\n<h4 id=\"break语句\"><a class=\"markdownIt-Anchor\" href=\"#break语句\">#</a> break 语句</h4>\n<p>前面讨论过 break 语句跳出 switch 语句，同时 break 语句还可以用于跳出 while,do,for 循环</p>\n<p>需要注意的时，如果有嵌套的情况存在，break 语句只能跳出一层循环</p>\n<h4 id=\"continue语句\"><a class=\"markdownIt-Anchor\" href=\"#continue语句\">#</a> continue 语句</h4>\n<p>continue 语句与 break 语句的区别在于，break 语句把程序控制转移到循环体末尾之后，而 continue 语句刚好把程序控制转移到循环体末尾之前.<br>\ncontinue 语句会把程序控制留在循环内，而 break 语句会使程序控制跳出循环<br>\n continue 语句只能用于循环，而 break 语句可以用于 switch 语句和循环</p>\n<p>continue 语句不会跳出循环，但会直接跳过 continue 之后的一系列语句，重新开始循环</p>\n<h4 id=\"goto语句\"><a class=\"markdownIt-Anchor\" href=\"#goto语句\">#</a> goto 语句</h4>\n<p>goto 语句可以跳转到函数中任何有<strong>标号</strong>的语句处</p>\n<blockquote>\n<pre><code>[标号语句]  标识符:语句\n[goto语句]  goto 标识符;\n</code></pre>\n</blockquote>\n<p>两个语句必须在同一个函数中<br>\n goto 语句对于嵌套循环的退出是很有用的</p>\n<h4 id=\"空语句\"><a class=\"markdownIt-Anchor\" href=\"#空语句\">#</a> 空语句</h4>\n<blockquote>\n<pre><code>eg:for(XX;XX;XX);\n</code></pre>\n</blockquote>\n<p>空语句的一个好处：编写空循环体的循环.<br>\nC 程序员习惯性地把空语句单独放置在一行</p>\n<h3 id=\"基本类型\"><a class=\"markdownIt-Anchor\" href=\"#基本类型\">#</a> 基本类型</h3>\n<p>C 语言支持两种根本的数据类型 分别是 整数类型 和浮点数类型  简单来说 整数和其他数 (包括小数等等) 的区别</p>\n<h4 id=\"整数类型\"><a class=\"markdownIt-Anchor\" href=\"#整数类型\">#</a> 整数类型</h4>\n<p>正说类型 分为 有符号整数和无符号整数</p>\n<p>有符号整数：如果整数为正数或者 0 那么最左边的符号位为 0; 如果为负数 那么最左边的符号位为 1 储存的时候都是按有符号整数来储存 如果要当成无符号整数来储存 需要声明整数类型为 unsigned<br>\n 无符号整数：最左边的位是数值的一部分</p>\n<p>C 语言的整数类型 有着不同的大小 int 类型通常为 32 位   有些数字很大 所以 C 语言还提供了 长整型 和 需要很小空间来储存的数 这样的数称为短整型</p>\n<p>整型分为 4 种 long short signed unsigned 他们之间可以互相组合</p>\n<blockquote>\n<pre><code>short int\nunsigned short int\nint\nunsigned int\nlong int\nunsigned long int\n</code></pre>\n</blockquote>\n<p>其他组合都是上述组合的同义词<br>\n C 语言允许通过省略单词 int 来缩写整数类型的名字<br>\n但很多基于 c 语言的程序 甚至不允许程序员写 short int 这样的名字 而必须写成 short 或者 long<br>\n 不同类型的取值范围也可能一样<br>\n eg: long int 可能和 int 有相同的取值范围  但是 long int 永远不可能比 int 的取值范围短<br>\n<a href=\"https://imgtu.com/i/IQpcUs\"><img src=\"https://z3.ax1x.com/2021/11/06/IQpcUs.png\" alt=\"IQpcUs.png\"></a><br>\n<a href=\"https://imgtu.com/i/IQpsbQ\"><img src=\"https://z3.ax1x.com/2021/11/06/IQpsbQ.png\" alt=\"IQpsbQ.png\"></a><br>\n<a href=\"https://imgtu.com/i/IQp0v8\"><img src=\"https://z3.ax1x.com/2021/11/06/IQp0v8.png\" alt=\"IQp0v8.png\"></a><br>\n 但是这种范围会随着编译器的不同而不同 好的解决方法是检查 &lt;limis.h&gt; 头文件定义了每种整数类型的最大值和最小值的宏<br>\n C99 新增了 2 个 long long int 和 unsigned long long int</p>\n<h5 id=\"整数常量\"><a class=\"markdownIt-Anchor\" href=\"#整数常量\">#</a> 整数常量</h5>\n<p>常量：在程序中以文本形式出现的数，而不是读，写，计算出来的数.C 语言允许用十进制，八进制，十六进制来表示常量</p>\n<p>十进制不能以 0 开头 八进制必须以 0 开头 十六进制总是以 0x 开头<br>\n这里需要注意的是  这些只是书写数的方式 并不会对数的储存方式产生英雄 数都是以二进制储存的 所以我们进行计算的时候甚至可以将他们三个混合使用 程序仍然能够识别 并且计算出值<br>\n十进制整数常量的类型同城为 nit 但如果常量的值大得无法储存在 int 型中 那就用 long int 类型。如果出现 long int 还不够用的罕见情况 编译器会用 unsigned long int 做最后的尝试<br>\n八进制和十六进制 会从范围最小的整数型开始尝试 直至找到能表示该常量的类型</p>\n<p>要强制编译器把常量作为长整数来处理，只需要在后边加上一个字母 L/l  <strong>大小写无所谓</strong><br>\n同样 要指明是无符号变量 可以在常量后边加上字母 U/u<br>\n<strong>L 和 U 可以混合使用 顺序和大小都无所谓</strong></p>\n<h5 id=\"c99中的整型变量\"><a class=\"markdownIt-Anchor\" href=\"#c99中的整型变量\">#</a> C99 中的整型变量</h5>\n<p>在 C99 中 出现了 LL (long long) 在 ll 前面 U 的通常是 unsigned long long  需要注意的是 <strong>这里两个 l 的大小写需要一致</strong><br>\n十进制储存 按照 int      long int   long long int 中的最小的能适合的方式储存<br>\n而八进制和十六进制 按照 int        unsigned int          long int           unsigned long int   ……</p>\n<h5 id=\"整数溢出\"><a class=\"markdownIt-Anchor\" href=\"#整数溢出\">#</a> 整数溢出</h5>\n<p>对整数执行算数运算时，其结果有可能因为太大而无法显示，这时候就会发生整数溢出<br>\n有符号整数溢出时 会出现没有定义的情况 无法预估最后会发生的情况<br>\n无符号整数溢出时 结果会有定义的：正确答案对 2 的 n 次方取模 例如 65535+1 的结果 (能够被 2 除尽) 其结果可以保证为 0</p>\n<h5 id=\"读写整数\"><a class=\"markdownIt-Anchor\" href=\"#读写整数\">#</a> 读 / 写整数</h5>\n<p>通常我们发生整数溢出时，会马上去更换整数类型 但单单这样做是不够的 我们还必须检查数据类型的改变对程序其他部分的影响</p>\n<p>读写无符号整数时 使用 u,o,x 代替转换说明中的 d<br>\nu 表示十进制 o 表示八进制 x 表示十六进制</p>\n<p>读写短整数时 在 d,o,x 或者 u 前面加上字母 h</p>\n<p>读写长整数时，在 d,o,x 或者 u 前面加上字母 l</p>\n<p>读写尝尝整数时，在 d,o,x 或者 u 前面加上字母 ll</p>\n<h4 id=\"浮点类型\"><a class=\"markdownIt-Anchor\" href=\"#浮点类型\">#</a> 浮点类型</h4>\n<p>float: 单精度浮点数<br>\n double: 双精度浮点数<br>\n long double: 扩展精度浮点数</p>\n<p>C 语言没有明确的说明精度到底是多少 不同的计算机可以以不同的方法储存浮点数</p>\n<p>数值是由三部分组成：符号，指数和小数 指数部分的位数说明了数值可能大小程度 而小数部分的位数说明了精度<br>\n<a href=\"https://imgtu.com/i/IQpwgf\"><img src=\"https://z3.ax1x.com/2021/11/06/IQpwgf.png\" alt=\"IQpwgf.png\"></a><br>\nlong double 类型没有出现在表中 因为它的长度随着机器的不同而变化 最常见的大小是 80 位和 128 位</p>\n<p>C99 中 浮点类型分为两种 一种是实浮点类型 包括 float,double,long double 类型<br>\n另一种是 C99 新增的复数类型  包括 float ,_Complex ,double ,_Complex ,long double _Complex</p>\n<h5 id=\"浮点常量\"><a class=\"markdownIt-Anchor\" href=\"#浮点常量\">#</a> 浮点常量</h5>\n<p>浮点常量必须包括小数点或者指数 其中指数指明了对前面的数进行缩放所需的 10 的幂次 如果有指数 则需要在指数数值前放置字母 E 或者 e 可选符号 + 或者 - 可以出现在字母 E 或者 e 的后边 为了表明只需要单精度 可以在常量的末尾处加上字母 F/f; 而为了说明常量必须以 long double 的形式储存可以在常量的末尾处 加上字母 L 或者 l</p>\n<h5 id=\"读写浮点数\"><a class=\"markdownIt-Anchor\" href=\"#读写浮点数\">#</a> 读写浮点数</h5>\n<p>前面已讨论过，转换说明 % e,% f 和 % g 用于读写单精度浮点数 读写 double 和 long double 类型的值所需的转换说明略有不同<br>\n读写 double 类型的值时，在 e,f,g 前面放置字母 l   <strong>注意只能在字符串 scanf 中使用 在 printf 函数调用中使用额 e,f,g 可以用来写 float 类型或者 double 类型的值</strong><br>\n读写 long double 类型时，在 e,f,g 前面放置字母 L<br>\n<strong> 注意 double 和 long double 这里有字母大小写的区别</strong></p>\n<h4 id=\"字符类型char\"><a class=\"markdownIt-Anchor\" href=\"#字符类型char\">#</a> 字符类型 char</h4>\n<p>当前最常用的字符集是 ASCII 字符集，用 7 位代码表示 128 个字符<br>\n char 类型的变量可以用任意单字符赋值</p>\n<h5 id=\"字符操作\"><a class=\"markdownIt-Anchor\" href=\"#字符操作\">#</a> 字符操作</h5>\n<p>C 语言将字符当做整数进行处理 毕竟所有的字符都是以二进制的形式进行编码的</p>\n<blockquote>\n<pre><code>char ch;\nch = 65      此时ch是A\nch = ch+1    此时ch是B\n</code></pre>\n</blockquote>\n<h5 id=\"有符号字符和无符号字符\"><a class=\"markdownIt-Anchor\" href=\"#有符号字符和无符号字符\">#</a> 有符号字符和无符号字符</h5>\n<p>char 类型像整数类型一样存在符号性和无符号性两种 通常有符号型的取值是 - 128~127 而无符号字符的取值是 0~255<br>\n 所有 C 语言允许单词 signed 和 unsigned 来修饰 char 类型</p>\n<h4 id=\"算数类型\"><a class=\"markdownIt-Anchor\" href=\"#算数类型\">#</a> 算数类型</h4>\n<p><a href=\"https://imgtu.com/i/IQp6Ej\"><img src=\"https://z3.ax1x.com/2021/11/06/IQp6Ej.png\" alt=\"IQp6Ej.png\"></a></p>\n<h4 id=\"转义序列-2\"><a class=\"markdownIt-Anchor\" href=\"#转义序列-2\">#</a> 转义序列</h4>\n<p>转义序列分为字符转义序列和数字转义序列</p>\n<h5 id=\"字符转义序列\"><a class=\"markdownIt-Anchor\" href=\"#字符转义序列\">#</a> 字符转义序列</h5>\n<p><a href=\"https://imgtu.com/i/IQprDg\"><img src=\"https://z3.ax1x.com/2021/11/06/IQprDg.png\" alt=\"IQprDg.png\"></a></p>\n<h5 id=\"数字转义序列\"><a class=\"markdownIt-Anchor\" href=\"#数字转义序列\">#</a> 数字转义序列</h5>\n<p>字符转义序列没有包含所有无法打印的 ASCII 字符 字符转义序列也无法包含 128 个 ASICC 字符以外的字符 而数字转义字符可以表示任何字符 所有它可以解决上述问题</p>\n<p>作为字符常量来使用时，<strong> 转义序列必须用一堆单引号括起来</strong></p>\n<h4 id=\"字符处理函数\"><a class=\"markdownIt-Anchor\" href=\"#字符处理函数\">#</a> 字符处理函数</h4>\n<p>例如 toupper 函数可以将小写字母转化为大写字母 但要调用这类使用的字符处理函数 需要在顶部放置 #include &lt;ctype.h&gt; 这一条指令</p>\n<h5 id=\"用scanf-和printf读写字符\"><a class=\"markdownIt-Anchor\" href=\"#用scanf-和printf读写字符\">#</a> 用 scanf 和 printf 读写字符</h5>\n<p>scanf 读写字符时 并不会跳过空白字符 为了强制 scanf 在读入字符前跳过空白字符，需要在格式串中的转换说明 % C 前面加上一个空格</p>\n<h5 id=\"用getchar和putchar用于读写字符\"><a class=\"markdownIt-Anchor\" href=\"#用getchar和putchar用于读写字符\">#</a> 用 getchar 和 putchar 用于读写字符</h5>\n<p>getchar 函数和 putchar 函数可以用来取代 scanf 和 printf 函数 putchar 函数用于写单个字符<br>\n每次调用时他会读写一个字符并将其返回 为了保存这个字符 必须使用赋值操作将其储存在变量中<br>\n当混用 getchar 函数和 scanf 函数要小心 scanf 函数仅消耗掉匹配的输入数据 其余部分仍然留在缓冲区 (包括换行符)</p>\n<h4 id=\"类型转换\"><a class=\"markdownIt-Anchor\" href=\"#类型转换\">#</a> 类型转换</h4>\n<h5 id=\"隐式类型转换规则\"><a class=\"markdownIt-Anchor\" href=\"#隐式类型转换规则\">#</a> 隐式类型转换规则</h5>\n<p>较低级向较高级转换 (按存储长度)<br>\n 其中有一个操作数是浮点型时 把整型操作数往浮点型转换 而浮点型往精度更高的浮点型转换<br>\n两个操作数都不是浮点数时，如果有 char 或者 short int 类型 首先对两个操作数进行整型提升<br>\n<strong>特例</strong>:long int 和 unsigned int 数据类型长度相同时 则两个操作数均转换为 unsigned long<br>\n<a href=\"https://imgtu.com/i/IQ9FPI\"><img src=\"https://z3.ax1x.com/2021/11/06/IQ9FPI.png\" alt=\"IQ9FPI.png\"></a><br>\n 赋值中的类型转换：把赋值运算符右侧表达式的值转换为左侧变量的类型.</p>\n<h5 id=\"强制类型转换\"><a class=\"markdownIt-Anchor\" href=\"#强制类型转换\">#</a> 强制类型转换</h5>\n<blockquote>\n<pre><code>(类型)变量   eg(char)i  表示把i的类型强制转换为char的类型\n(类型)(表达式)\n</code></pre>\n</blockquote>\n<p>这些转换类型只是一次有效的 不会改变变量定义时的数据类型<br>\n C 语言把类型名视为一元运算符</p>\n<h4 id=\"类型定义\"><a class=\"markdownIt-Anchor\" href=\"#类型定义\">#</a> 类型定义</h4>\n<blockquote>\n<pre><code>typedef 数据类型 别名\n</code></pre>\n</blockquote>\n<p>用于对另一个数据类型创建一个别名<br>\n注意并没有创建一个新的类型 仅仅是对某个已有的类型增加一个别名<br>\n可以让程序更加易于理解 可读性更高</p>\n<h4 id=\"sizeof-运算符\"><a class=\"markdownIt-Anchor\" href=\"#sizeof-运算符\">#</a> sizeof 运算符</h4>\n<p>取数据类型 常量 变量或者表达式值得存储长度的运算符 (以字节为单位)</p>\n<blockquote>\n<pre><code>sizeof(数据类型说明符/表达式)\n用于类型名 sizeof(类型名)\n用于表达式 sizeof 表达式\n</code></pre>\n</blockquote>\n<h3 id=\"第八章-字符输入输出和输入验证\"><a class=\"markdownIt-Anchor\" href=\"#第八章-字符输入输出和输入验证\">#</a> 第八章 字符输入 / 输出和输入验证</h3>\n<h4 id=\"单字符io-getchar和putchar\"><a class=\"markdownIt-Anchor\" href=\"#单字符io-getchar和putchar\">#</a> 单字符 I/O getchar () 和 putchar ()</h4>\n<h4 id=\"缓冲区\"><a class=\"markdownIt-Anchor\" href=\"#缓冲区\">#</a> 缓冲区</h4>\n<p>用户输入的字符被收集并存储在一个被称为缓冲区的临时存储区 按下 enter 键后 程序才可以使用用户输入的字符<br>\n某些交互式系统无缓冲区 比如游戏中按下一个键需要立即执行按下的操作<br>\n缓冲区分为完全缓冲和行缓冲</p>\n<blockquote>\n<pre><code>完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区\n行缓冲指的是在出现换行时刷新缓冲区(键盘输入)\n</code></pre>\n</blockquote>\n<p>是否能进行无缓冲输入取决于计算机系统 大部分直接规定输入都会缓冲输入</p>\n<h4 id=\"结束键盘输入\"><a class=\"markdownIt-Anchor\" href=\"#结束键盘输入\">#</a> 结束键盘输入</h4>\n<h5 id=\"文件流和键盘输入\"><a class=\"markdownIt-Anchor\" href=\"#文件流和键盘输入\">#</a> 文件，流和键盘输入</h5>\n<h5 id=\"文件结尾\"><a class=\"markdownIt-Anchor\" href=\"#文件结尾\">#</a> 文件结尾</h5>\n<p>方法 1 文件末尾放置一个特殊字符 来标记末尾<br>\n方法 2 存储文件大小的信息。如果程序有 3000 字节 那么程序在读到 3000 字节的时候便达到文件末尾</p>\n<p>在 C 语言中 用 getchar 或者 scanf 检测文件末尾时都将放回一个特殊值 即 EOF</p>\n<h3 id=\"第九章函数\"><a class=\"markdownIt-Anchor\" href=\"#第九章函数\">#</a> 第九章函数</h3>\n<h4 id=\"复习函数\"><a class=\"markdownIt-Anchor\" href=\"#复习函数\">#</a> 复习函数</h4>\n<h5 id=\"创建并使用简单函数\"><a class=\"markdownIt-Anchor\" href=\"#创建并使用简单函数\">#</a> 创建并使用简单函数</h5>\n<blockquote>\n<pre><code>#include &lt;stdio.h&gt;\n#define NAME \"GIGATHINK,INC\"\n#define ADDRESS \"101 Megabuck plaza\"\n#define PLACE \"MEGAPOLIS,CA 94904\"\n#define WIDTH 40\n\nvoid starbar(void);\n\nint main(void)\n{\n    starbar();\n    printf(\"%s \\n\", NAME);\n    printf(\"%s \\n\", ADDRESS);\n    printf(\"%s \\n\", PLACE);\n    starbar(); //使用函数\n    return 0;\n}\n\nvoid starbar(void) //定义函数\n{\n    int count;\n    for (count = 1; count &lt;= WIDTH; count++)\n    {\n        putchar('*');\n    }\n    putchar('\\n');\n}\n</code></pre>\n</blockquote>\n<h5 id=\"分析程序\"><a class=\"markdownIt-Anchor\" href=\"#分析程序\">#</a> 分析程序</h5>\n<p>函数原型：告诉编译器函数的类型<br>\n函数调用：表明在此处执行函数<br>\n函数定义：明确地指出函数要做什么</p>\n<p>函数和变量有一样有多种类型 任何程序在使用函数之前都要声明该函数的类型</p>\n<blockquote>\n<pre><code>void starbar(void);\n圆括号表示starbar是一个函数名 第一个void是函数类型 void类型表明函数没有返回值 第二个void(圆括号中)表明该函数不带参数。分号表示这是在申明函数不是在定义函数 \n这行表明了程序将使用一个名为starbar(),没有返回值,没有参数的函数,并告诉编译器在别处查找该函数的定义\n</code></pre>\n</blockquote>\n<p>一般而言 函数原型指明了函数的返回值类型和函数接受的参数类型 这些信息称为函数的<strong>签名</strong><br>\n这里对于 starbar () 函数而言 其签名是该函数没有返回值，没有参数<br>\n starbar () 原型放在任何位置都可以<br>\n执行顺序:<br>\n 在 main () 中 当计算机执行到 starbar () 函数时，会找到该函数的定义并执行其中的内容，执行完 starbar () 中的代码后，计算机返回主调函数继续执行下一行<br>\n函数头包括函数类型，函数名和圆括号，接着是左花括号，变量声明，函数表达式语句，最后以又花括号结束<br>\n ** 注意函数头中的 starbar () 没有分号 这是在告诉编译器这是定义 starbar ()，而不是调用函数或者声明函数类型<br>\n starbar () 函数中的 count 变量是局部变量，意思是该变量只属于 starbar () 函数，可以在程序中的其他地方使用 count 这并不会引起名称冲突 他们是同名的不同函数</p>\n<h5 id=\"函数参数\"><a class=\"markdownIt-Anchor\" href=\"#函数参数\">#</a> 函数参数</h5>\n<blockquote>\n<pre><code>void show_n_char(char ch,int num);   \nshou_n_char('*',12)\n</code></pre>\n</blockquote>\n<h5 id=\"定义带形式参数的函数\"><a class=\"markdownIt-Anchor\" href=\"#定义带形式参数的函数\">#</a> 定义带形式参数的函数</h5>\n<p>第一行告知编译器 show_n_char 使用两个参数 ch 和 num,ch 是 char 类型 num 是 int 类型。这两个变量被称为形式参数，简称形参。和定义在函数中变量一样 形参也是局部变量属于该函数私有。这以为着在其他函数中使用同名变量不会引起名称冲突 每次调用函数 就会给这些变量赋值<br>\n值得一提的是 虽然 show_n_char () 接受来自 main () 的值 但是它没有返回值。因此，show_n_char () 的类型是 void</p>\n<h5 id=\"声明带形式参数函数的原型\"><a class=\"markdownIt-Anchor\" href=\"#声明带形式参数函数的原型\">#</a> 声明带形式参数函数的原型</h5>\n<p>使用函数之前要声明函数原型: void shou_n_char (char ch,int num) 当然根据个人喜好 你也可以省略变量名<br>\n在原型中使用变量名并没有实际创建变量，char 仅代表了一个 char 类型的变量</p>\n<h5 id=\"调用带实际参数的函数\"><a class=\"markdownIt-Anchor\" href=\"#调用带实际参数的函数\">#</a> 调用带实际参数的函数</h5>\n<p>在函数的调用中 实际参数 (简称实参) 提供了 ch 和 num 的值 比如 show_n_char (’*’,12); 这两个值被赋值给函数中的形式参数<br>\n简而言之形式参数是被调函数中的变量 实际参数是主调函数赋值给被调函数的具体值 实际参数可以是常量变量甚至是更复杂的表达式 无论实际参数是何种形式都要被求值 然后该值被拷贝给被调函数相应的形式参数.</p>\n<h5 id=\"使用return从函数中返回值\"><a class=\"markdownIt-Anchor\" href=\"#使用return从函数中返回值\">#</a> 使用 return 从函数中返回值</h5>\n<blockquote>\n<pre><code>int imin(int n , int m)\nint imin(int n , int m)\n{\nint min ;\nif (n&lt;m) min=n;\nelse min = m;\nreturn min;\n}\nint a = imin(1,2)\n</code></pre>\n</blockquote>\n<p>关键字 return 后面的表达式的值就是函数的返回值 在该例中，函数的返回值就是变量 min 的值<br>\n变量 min 属于 imin () 函数私有 但是 return 语句把 min 的值传回了主调函数<br>\n return; return 语句还可以这样使用 这样使用 retrun 语句将会终止函数并把控制返回给主调函数</p>\n<h5 id=\"函数类型\"><a class=\"markdownIt-Anchor\" href=\"#函数类型\">#</a> 函数类型</h5>\n<p>声明函数必须声明函数的类型 带返回值的函数类型应该与其返回值得类型相同 没有返回值的函数声明为 void 类型<br>\n<strong>值得注意的是 函数类型指的是函数返回值的类型 而不是参数的类型</strong><br>\n函数的前置声明可以放在主调函数外面也可以放在主调函数里面<br>\n ANSIC 标准库中，函数被封城了多个系列，每一个系列都有各自的头文件，这些头文件中包含了本系列所有函数的声明。例如 stdio.h 头文件中包括了标准的 I/O 库函数 (如 printf he scanf 函数) 的声明</p>\n<h4 id=\"ansi-c-函数类型\"><a class=\"markdownIt-Anchor\" href=\"#ansi-c-函数类型\">#</a> ANSI C 函数类型</h4>\n<p>旨在说明老式声明函数的问题所在和解决方案 这里不做过多描述 可自行搜索</p>\n<p>ANSI C 使用了逗号分割的类型列表 eg imax (int a , int b) 如此 编译器可以检查函数调用是否和函数原型匹配 参数的数量是否匹配 参数的类型是否匹配</p>\n<h5 id=\"无参数和未指定参数\"><a class=\"markdownIt-Anchor\" href=\"#无参数和未指定参数\">#</a> 无参数和未指定参数</h5>\n<blockquote>\n<pre><code>void print_name()\n</code></pre>\n</blockquote>\n<p>接受 ANSI C 的编译器截石位 print_name () 不接受任何参数，然后在调用该函数时，编译器会检查来确保没有使用参数</p>\n<h5 id=\"函数原型的优点\"><a class=\"markdownIt-Anchor\" href=\"#函数原型的优点\">#</a> 函数原型的优点</h5>\n<p>使用函数原型会让编译器捕获在使用函数时可能出现的许多错误或疏漏，如果编译器没有发现这些问题，就很难觉察出来.<br>\n 有一种方法可以省略函数原型却保留函数原型的优点<br>\n把整个函数定义放在第一次调用该函数之前，也有相同的效果 此时函数定义也相当于函数原型。对于代码量较少的函数 这种用法很普遍</p>\n<blockquote>\n<pre><code>int imax(int a , int b ) {return a&gt;b?a:b}\n</code></pre>\n</blockquote>\n<h4 id=\"递归\"><a class=\"markdownIt-Anchor\" href=\"#递归\">#</a> 递归</h4>\n<p>C 允许函数调用他自己 这种调用过程称为<strong>递归</strong><br>\n难点：结束递归 (如果递归代码中没有终止递归的条件测试部分，一个调用自己的函数就会无限递归)<br>\n 注：可以使用循环的地方<strong>通常</strong>都可以使用递归</p>\n<h5 id=\"演示递归\"><a class=\"markdownIt-Anchor\" href=\"#演示递归\">#</a> 演示递归</h5>\n<p><a href=\"https://imgtu.com/i/IlPHk4\"><img src=\"https://z3.ax1x.com/2021/11/06/IlPHk4.jpg\" alt=\"IlPHk4.jpg\"></a><br>\n<a href=\"https://imgtu.com/i/IlPbtJ\"><img src=\"https://z3.ax1x.com/2021/11/06/IlPbtJ.jpg\" alt=\"IlPbtJ.jpg\"></a></p>\n<h5 id=\"递归的基本原理\"><a class=\"markdownIt-Anchor\" href=\"#递归的基本原理\">#</a> 递归的基本原理</h5>\n<p>1. 每级函数调用都有自己的变量 也就是说第一级的 n 和第二的 n 不一样 当程序最终返回第一级的时候 最初的 n 仍然是它的初值 1 (局部变量)<br>\n 2. 每次幻术调用都会返回一次 当函数执行完毕后 控制权将被传回上一级递归。程序必须按照顺序逐级返回递归 不能跳级<br>\n 3. 递归函数中位于递归调用之前的语句 均按被调函数的顺序执行<br>\n 4. 递归函数中位于递归调用之后的语句 均按被调函数的<strong>相反</strong>顺序执行<br>\n 5. 虽然每级递归都有自己的变量 但是并没有拷贝函数的代码，所以程序按顺序执行函数中的代码 而递归调用就相当于又从头开始执行函数的代码 除了为每次递归调用创建变量外 递归调用非常类似于一个循环语句<br>\n 6. 递归函数必须包含能让递归调用停止的语句。通常递归函数都使用 if 或者其他等价的测试条件在函数形参等于某个特定值时终止递归。为此 每次递归调用的形参都要使用不同的值</p>\n<h5 id=\"尾递归\"><a class=\"markdownIt-Anchor\" href=\"#尾递归\">#</a> 尾递归</h5>\n<p>将递归放置在函数的末尾 即正好在 return 语句之前 这种形式的递归被称为尾递归 相当于循环</p>\n<h5 id=\"递归和倒序计算\"><a class=\"markdownIt-Anchor\" href=\"#递归和倒序计算\">#</a> 递归和倒序计算</h5>\n<p>在处理这类倒序问题时  递归比循环简单</p>\n<h5 id=\"递归的优缺点\"><a class=\"markdownIt-Anchor\" href=\"#递归的优缺点\">#</a> 递归的优缺点</h5>\n<p>优点：为某些编程问题提供了最简单的解决方案，缺点是一些递归算法会快速消耗计算机的内存资源 另外递归不方便阅读和维护<br>\n<strong>在程序中使用递归要格外注意 尤其是效率优先的程序</strong></p>\n<h4 id=\"编译多源代码文件的程序\"><a class=\"markdownIt-Anchor\" href=\"#编译多源代码文件的程序\">#</a> 编译多源代码文件的程序</h4>\n<p>使用多个函数最简单的方法是把他们都放在同一个文件中 然后像编译只有一个函数的文件那样编译该文件即可。其他方法因操作系统而异，下面将举例说明.</p>\n<h5 id=\"unix\"><a class=\"markdownIt-Anchor\" href=\"#unix\">#</a> UNIX</h5>\n<p>假设 filel.c 和 file2.c 是两个内涵 C 函数的文件 下面的命令将编译两个文件并生成一个名为 a.out 的可执行文件:<br>\ncc filel.c file2.c<br>\n 另外还生成两个名为 file1.o 和 file2.o 的目标文件。如果后来改动了 filel.c 而 file2.c 不变 可以使用以下命令编译第一个文件 并与第二个文件的目标代码合并<br>\n cc filel.c file2.o</p>\n<h5 id=\"linux\"><a class=\"markdownIt-Anchor\" href=\"#linux\">#</a> Linux</h5>\n<p>假定 linux 系统安装了 GNU C 编译器 GCC 假设 filel.c 和 file2.c 是两个内含 C 函数的文件 下面的命令将编译两个文件并生成名为 a.out 的可执行文件<br>\n gcc filel.c file2.c<br>\n 另外还生成两个名为 file1.o 和 file2.o 的目标文件。如果后来改动了 filel.c 而 file2.c 不变 可以使用以下命令编译第一个文件 并与第二个文件的目标代码合并<br>\n gcc filel.c file2.o</p>\n<h5 id=\"dos命令行编译器\"><a class=\"markdownIt-Anchor\" href=\"#dos命令行编译器\">#</a> DOS 命令行编译器</h5>\n<p>绝大多数 DIS 命令行编译器的工作员刘和 UNIX 的 CC 命令类似 只不过使用不同的名称而已 其中一个区别是 对象文件的扩展名是.obj 而不是.o 一些编译器生成的不是目标代码文件 而是汇编语言或其他特殊代码的中间文件</p>\n<h5 id=\"windows和苹果的ide编译器\"><a class=\"markdownIt-Anchor\" href=\"#windows和苹果的ide编译器\">#</a> windows 和苹果的 IDE 编译器</h5>\n<p>windows 和 Macintosh 系统使用的集成开发环境中的编译器是面向项目的<br>\n项目 描述的是特定程序使用的资源 (资源包括源代码文件)<br>\n 这种 IDE 中的编译器要创建项目来运行单文件程序 对于多文件程序 要使用相应的菜单命令 把源代码文件加入到一个项目中 要确保所有的源代码文件都在项目列表中列出 许多 IDE 都不用在项目列表中列出头文件 (扩展名为.h 的文件) 因为项目只管理使用的源代码文件源代码文件中的 #include 指令管理该文件中使用的头文件 但是 Xcode 要在项目中添加头文件</p>\n<h5 id=\"使用头文件\"><a class=\"markdownIt-Anchor\" href=\"#使用头文件\">#</a> 使用头文件</h5>\n<p>如果把 main () 放在第一个文件中 把函数定义放在第二个文件中 那么第一个文件仍然要使用函数原型<br>\n把函数原型放在头文件中 就不用再每次使用函数文件时都要写出函数的原型</p>\n<h4 id=\"查找地址-运算符\"><a class=\"markdownIt-Anchor\" href=\"#查找地址-运算符\">#</a> 查找地址: &amp; 运算符</h4>\n<p>指针是 C 语言中最重要的概念之一 用于存储变量的地址。前面使用的 scanf () 函数中就是用地址最为参数<br>\n一元运算符 &amp; 给出变量的存储地址，如果 posh 是变量名那么 &amp; posh 就是变量的地址 可以把地址看做是变量在内存中的位置<br>\n不同的变量所处的位置是不同的</p>\n<h4 id=\"更改主调函数中的变量\"><a class=\"markdownIt-Anchor\" href=\"#更改主调函数中的变量\">#</a> 更改主调函数中的变量</h4>\n<p>例如要更改两个数 x,y 的位置 简单地 x = y, y = x 并没有作用<br>\n下面实现简单地交换值得功能</p>\n<blockquote>\n<pre><code>void interchange(int u ,int v ) {\nint temp;\ntemp = u\nu = v\nv = temp\n}\n</code></pre>\n</blockquote>\n<p>虽然这个函数表面上实现了交换的功能 但事实上 调用函数输出结果的时候 并不会交换这两个数值<br>\n因为在 interchange () 传回的变量并不是 main () 中的变量 (局部变量问题：在函数中的变量虽然表面上和 main 中的变量一样 但是实际上这两个变量是完全不同的 存储地址也不一样的两个变量). 因此交换 u 和 v 的值 对 x 和 y 的值没有影响<br>\n可以使用 return 语句把值传回 main () 比如 在函数末尾加上 return (u), 然后修改 main 中而定调用 x = interchange (x,y) 但是这只能改变 x 的值 return 语句只能把被调函数中的一个值传回主调函数 但是现在要传回两个值 这就需要指针了 下面开始概述指针</p>\n<h4 id=\"指针简介\"><a class=\"markdownIt-Anchor\" href=\"#指针简介\">#</a> 指针简介</h4>\n<p>指针：一个值为内存地址的变量 (或数据对象)<br>\n<strong> 例如:int 类型变量的值为整数 char 类型变量的值为字符 而指针变量的值为地址</strong></p>\n<blockquote>\n<pre><code>ptr = &amp;pooh\n</code></pre>\n</blockquote>\n<p>其中 表示 ptr\"指向\"pooh ptr 和 &amp; pooh 的区别是 ptr 是变量 而 &amp;pooh 是常量<br>\n这样 ptr 的值 就是 pooh 的地址<br>\n创建指针变量 要先声明指针变量的类型</p>\n<h5 id=\"间接运算符解引用运算符\"><a class=\"markdownIt-Anchor\" href=\"#间接运算符解引用运算符\">#</a> 间接运算符 (解引用运算符) *</h5>\n<p>间接运算符可以找出存储在内存地址下的值<br>\n注意分清楚 间接运算符 和 二元乘号运算符 虽然他们长得一样</p>\n<blockquote>\n<pre><code>val = *ptr\nptr = &amp;bhb\n上面这串代码就相当于是 val = bhb\n&amp;后跟一个变量名 表示该变量名的地址\n*后跟一个地址 或者指针名 表示存储在指针指向地址上的值\n</code></pre>\n</blockquote>\n<h5 id=\"声明指针\"><a class=\"markdownIt-Anchor\" href=\"#声明指针\">#</a> 声明指针</h5>\n<blockquote>\n<pre><code>int * pi         pi是指向int类型变量的指针\nchar * p         p是指向char类型变量的指针\nfloat * pf,*pg   pf,pg是指向float类型变量的指针\n</code></pre>\n</blockquote>\n<p>其中 * 表明声明的变量是一个指针 前面表示指针指向的类型<br>\n pi 指向的值是 int 类型 pi 本身叫做 指向 int 类型的指针 pi 的值是一个地址</p>\n<h5 id=\"使用指针在函数间通信\"><a class=\"markdownIt-Anchor\" href=\"#使用指针在函数间通信\">#</a> 使用指针在函数间通信</h5>\n<blockquote>\n<pre><code>void interchange(int * u, int * v)\n{\nint temp;\ntemp = *u;\n*u = *v;\n*v = temp;\n}\ninterchange(&amp;x,&amp;y)\n</code></pre>\n</blockquote>\n<p>该函数传递的就不是 x 和 y 的值 而是存储 x 和 y 的值的地址<br>\n函数中的第二个语句表示 把 u 地址中的值给 temp 第三个语句表示把 V 地址中存储的值赋值给 U 这样 U 地址存储的值变成了 V 地址存储的值第四个语句同样</p>\n<h5 id=\"小结来自c-primer-plus\"><a class=\"markdownIt-Anchor\" href=\"#小结来自c-primer-plus\">#</a> 小结 (来自 C primer Plus)</h5>\n<p><a href=\"https://imgtu.com/i/IlXp9K\"><img src=\"https://z3.ax1x.com/2021/11/07/IlXp9K.jpg\" alt=\"IlXp9K.jpg\"></a><br>\n<a href=\"https://imgtu.com/i/IlOxtx\"><img src=\"https://z3.ax1x.com/2021/11/07/IlOxtx.jpg\" alt=\"IlOxtx.jpg\"></a></p>\n<h4 id=\"关键概念\"><a class=\"markdownIt-Anchor\" href=\"#关键概念\">#</a> 关键概念</h4>\n<p>想用 C 编出高效灵活的程序，必须理解函数.<br>\n 函数是如何把信息从一个函数传递到另一函数 理解函数参数和返回值之间的工作原理<br>\n明白函数形参和其他局部变量属于函数私有因此 声明在不同函数中的同名变量是完全不同的变量<br>\n函数无法直接访问在其他函数中的变量 这样限制访问保护了数据的完整性<br>\n但是 当确实需要在函数中访问另一个函数的数据时 可以把指针作为函数的参数</p>\n<h4 id=\"本章小结\"><a class=\"markdownIt-Anchor\" href=\"#本章小结\">#</a> 本章小结</h4>\n<p>函数使用参数把值传给函数 使用关键字 return 把值返回函数 必须在函数定义和函数原型中指定函数的原型，如果需要在被调函数中修改主调函数的变量，使用地址或指针作为参数<br>\n ANSI C 提供了函数原型 允许编译器验证函数调用中使用的参数个数和类型是否正确<br>\n C 函数可以调用本身 即递归 一些编程问题要用递归来解决 但是递归消耗内存多 效率不高 而且费时</p>\n<h3 id=\"第十章数组和指针\"><a class=\"markdownIt-Anchor\" href=\"#第十章数组和指针\">#</a> 第十章数组和指针</h3>\n<h4 id=\"数组\"><a class=\"markdownIt-Anchor\" href=\"#数组\">#</a> 数组</h4>\n<p>数组：数据类型相同的一系列元素组成 通过声明告诉编译器数组中含有多少元素和这些元素的类型</p>\n<blockquote>\n<pre><code>float candy[365];\nchar code[12];\nint states[50];\n</code></pre>\n</blockquote>\n<p>方括号中的数组是数组中的元素个数.<br>\n 访问数组中的元素通过数组索引表示数组中的各元素。数组元素的标号从 0 开始 'candy [0]' 表示 candy 数组的第一个元素</p>\n<h5 id=\"初始化数组\"><a class=\"markdownIt-Anchor\" href=\"#初始化数组\">#</a> 初始化数组</h5>\n<p>标量变量：只存储单个值的变量</p>\n<blockquote>\n<pre><code>int fix = 1 ;\n</code></pre>\n</blockquote>\n<p>C 语言用新的语法来初始化数组</p>\n<blockquote>\n<pre><code>int power[8] = {1,2,4,6,8,6,4,2}\n</code></pre>\n</blockquote>\n<p>用以逗号分隔的值列表 (用花括号括起来) 来初始化数组，各值之间用逗号分割.<br>\n 使用 const 声明数组:<br>\n 有时需要把数组设置为只读，如此 程序只能从数组中检索值，不能把新值写入数组，此时就应该用 const 声明和初始化数组</p>\n<blockquote>\n<pre><code>const int days[12] = {31,28,31,30,31,30,31,31,30,31,30,31}\n</code></pre>\n</blockquote>\n<p><strong>使用数组之前必须初始化</strong><br>\n当初始化列表中的值少于数组元素个数时，编译器会把剩余的元素都初始化为 0, 但是如果不初始化数组，数组中存储的将会是不确定的垃圾值.<br>\n 但是如果初始化列表中的值多于数组元素个数时候编译器会进行报错<br>\n如果省略方括号中的数组编译器会根据初始化列表中的项数来确定数组的大小<br>\n通常使用 sizeof 运算符给出他的运算对象的大小 (单位为字节)</p>\n<blockquote>\n<pre><code>int days[] = {1,2,3};\nsizeof days[0] 表示数组中第一个元素的字节大小 //这里是4字节 因为一个int类型占据4字节\nsizeof days 表示数组中所有元素所占的字节大小\n我们通常使用数组中所有元素所占的字节大小来除以每一个元素的字节大小 得到数组中的元素数目\nsizeof days / sizeof days[0]\n</code></pre>\n</blockquote>\n<h5 id=\"指定初始化器c99\"><a class=\"markdownIt-Anchor\" href=\"#指定初始化器c99\">#</a> 指定初始化器 (C99)</h5>\n<p>C99 增加的新特性：指定初始化器 利用该特性可以初始化指定的数组元素</p>\n<blockquote>\n<pre><code>int arr[6] = {[5]=212}; 把arr[5]初始化为212\n</code></pre>\n</blockquote>\n<p>在初始化一个元素后 未初始化的元素都会被设置为 0<br>\n 如果初始化器后面有更多的值</p>\n<blockquote>\n<pre><code>[4] = 31,32,33   在days[4]被转化成31后 后面的数组会根据顺序转化 也就是说days[5]=32 以此类推\n</code></pre>\n</blockquote>\n<p>如果再次初始化元素 最后的初始化将会取代前面的初始化<br>\n数组中除了指定的初始化元素，其他的将会按照顺序排序</p>\n<blockquote>\n<p>int days [12] = {31,28,[4]=31} 此时 days [0] 就是 31 days [1] 就是 28<br>\n 如果没有指定元素大小 例如  int days [] = {[1]=2}<br>\n 此时园一期会把数组的大小设置为足够装得下初始化的值</p>\n</blockquote>\n<h5 id=\"给数组元素赋值\"><a class=\"markdownIt-Anchor\" href=\"#给数组元素赋值\">#</a> 给数组元素赋值</h5>\n<p>AA<br>\n 声明数组后，可以借助数组下标 (或索引) 给数组元素赋值<br>\n C 语言中只能使用循环给数组的元素依次赋值 不允许把数组作为一个单元赋给另一个数组<br>\n只有初始化允许使用花括号列表的形式赋值</p>\n<blockquote>\n<pre><code>int yaks[5];\nyaks[5] = {1,2,3,4,5};\n这样赋值是不起作用的\n</code></pre>\n</blockquote>\n<h5 id=\"数组边界\"><a class=\"markdownIt-Anchor\" href=\"#数组边界\">#</a> 数组边界</h5>\n<p>使用数组时，必须确保下标是有效的值 不能超出边界<br>\n编译器不会检查数组下标是否使用得当，结果是未定义的</p>\n<h5 id=\"指定数组的大小\"><a class=\"markdownIt-Anchor\" href=\"#指定数组的大小\">#</a> 指定数组的大小</h5>\n<p>声明数组只能在在方括号中使用整型常量表达式 另外表达式的值必须大于 0<br>\n<a href=\"https://imgtu.com/i/IBGPoQ\"><img src=\"https://z3.ax1x.com/2021/11/12/IBGPoQ.jpg\" alt=\"IBGPoQ.jpg\"></a></p>\n<h4 id=\"多维数组\"><a class=\"markdownIt-Anchor\" href=\"#多维数组\">#</a> 多维数组</h4>\n<p>声明:flaot rain [5][12]; //rain 是一个内涵 5 个元素的数组 每个元素的类型都是 float [12]<br>\n rain 的每个元素本身都是一个内涵 12 个 float 类型值的数组<br>\n例如:rain [0][0] 表示 rain 中的首个元素数组的首个元素</p>\n<blockquote>\n<pre><code>#include &lt;stdio.h&gt;\n#define MONTHS 12    // number of months in a year\n#define YEARS   5    // number of years of data\nint main(void)\n{\n    // initializing rainfall data for 2010 - 2014\n    const float rain[YEARS][MONTHS] =\n    {\n        {4.3,4.3,4.3,3.0,2.0,1.2,0.2,0.2,0.4,2.4,3.5,6.6},\n        {8.5,8.2,1.2,1.6,2.4,0.0,5.2,0.9,0.3,0.9,1.4,7.3},\n        {9.1,8.5,6.7,4.3,2.1,0.8,0.2,0.2,1.1,2.3,6.1,8.4},\n        {7.2,9.9,8.4,3.3,1.2,0.8,0.4,0.0,0.6,1.7,4.3,6.2},\n        {7.6,5.6,3.8,2.8,3.8,0.2,0.0,0.0,0.0,1.3,2.6,5.2}\n    };\n    int year, month;\n    float subtot, total;\n    \n    printf(\" YEAR    RAINFALL  (inches)\\n\");\n    for (year = 0, total = 0; year &lt; YEARS; year++)\n    {             // for each year, sum rainfall for each month\n        for (month = 0, subtot = 0; month &lt; MONTHS; month++)\n            subtot += rain[year][month];\n        printf(\"%5d %15.1f\\n\", 2010 + year, subtot);\n        total += subtot; // total for all years\n    }\n    printf(\"\\nThe yearly average is %.1f inches.\\n\\n\",\n           total/YEARS);\n    printf(\"MONTHLY AVERAGES:\\n\\n\");\n    printf(\" Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct \");\n    printf(\" Nov  Dec\\n\");\n    \n    for (month = 0; month &lt; MONTHS; month++)\n    {             // for each month, sum rainfall over years\n        for (year = 0, subtot =0; year &lt; YEARS; year++)\n            subtot += rain[year][month];\n        printf(\"%4.1f \", subtot/YEARS);\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}\n</code></pre>\n</blockquote>\n<p>重点学习数组初始化和计算方案</p>\n<h5 id=\"初始化二维数组\"><a class=\"markdownIt-Anchor\" href=\"#初始化二维数组\">#</a> 初始化二维数组</h5>\n<blockquote>\n<pre><code>sometype arl[5] = {val1,val2,val3,val4,val5}\n</code></pre>\n</blockquote>\n<p>val1 等是 sometype 类型的值</p>\n<blockquote>\n<pre><code>    const float rain[YEARS][MONTHS] =\n    {\n        {4.3,4.3,4.3,3.0,2.0,1.2,0.2,0.2,0.4,2.4,3.5,6.6},\n        {8.5,8.2,1.2,1.6,2.4,0.0,5.2,0.9,0.3,0.9,1.4,7.3},\n        {9.1,8.5,6.7,4.3,2.1,0.8,0.2,0.2,1.1,2.3,6.1,8.4},\n        {7.2,9.9,8.4,3.3,1.2,0.8,0.4,0.0,0.6,1.7,4.3,6.2},\n        {7.6,5.6,3.8,2.8,3.8,0.2,0.0,0.0,0.0,1.3,2.6,5.2}\n    };\n</code></pre>\n</blockquote>\n<p>初始化时候可以省略内部的花括号只需要保存最外部的花括号就行了，前提是每个元素都必须写上 并且数目不足，像这样内外花括号 可以使 元素书小于定义数时 编译器自动以 0 填充<br>\n如果省略内部花括号 编译器会按照先后顺序逐行初始化 直到用完所有的值，后面没有初始化元素被统一初始化为 0</p>\n<h5 id=\"其他多维数组\"><a class=\"markdownIt-Anchor\" href=\"#其他多维数组\">#</a> 其他多维数组</h5>\n<p>三维数组: int box [10][20][30];<br>\n 一维数组是一行数据 二维数组是数据表 三维数组是一叠数据表<br>\n处理几维数组就需要使用到几维嵌套循环</p>\n<h4 id=\"指针和数组\"><a class=\"markdownIt-Anchor\" href=\"#指针和数组\">#</a> 指针和数组</h4>\n<p>系统中 地址按字节编扯，short 类型占用 2 字节等；在 C 中 指针加 1 指的是增加一个存储单元。对数组而言 这意味着 + 1 后的地址是下一个元素的地址；而不是下一个字节的地址 这卆为什么必须声明指针所指对象类型的原因之一 自算计要知道存储对象需要多少字节</p>\n<blockquote>\n<pre><code>dates+2 == &amp;dates[2];\n*(dates+2) ==dates[2];\n</code></pre>\n</blockquote>\n<p>** 注意间接运算符 * 的优先级要大于 +** 所以这里必须打括号</p>\n<p>例如数组名是 days   那么 days 也表示数组首元素的地址</p>\n<h4 id=\"函数数组和指针\"><a class=\"markdownIt-Anchor\" href=\"#函数数组和指针\">#</a> 函数，数组和指针</h4>\n<blockquote>\n<pre><code>int sum(int * ar,int n)\n{\nint i;\nint total 0;\nfor(i=0;i&lt;n;i++)\ntotal +=ar[i] 或者 *( ar + i );\nreturn total;\n}\n</code></pre>\n</blockquote>\n<p>第一个形参告诉该函数数组的地址和数据类型 第二个形参告诉函数该数组中的元素个数<br>\n关于函数的形参 还有一点要注意 只有在函数原型或函数定义头中才可以用 int ar [] 来代替 int * ar;<br>\nint * ar 和 int ar [] 都表示 ar 是一个指向 int 的指针 但是 int ar [] 只能用于声明形式函数但是他可以提醒读者 ar 指向的不仅仅是一个 int 类型值还是一个 int 类型数组的元素<br>\n函数原型可以省略参数名<br>\n但是在函数定义中不能省略参数名<br>\n我们的系统中用 8 字节存储地址 所以指针变量的大小是 8 字节 (其他系统中地址的大小可能不是 8 字节)</p>\n<h5 id=\"使用指针形参\"><a class=\"markdownIt-Anchor\" href=\"#使用指针形参\">#</a> 使用指针形参</h5>\n<p>函数要处理数组必须知道何时开始，何时结束<br>\n上面 sum 函数用一个整数形参表示待处理元素的元素个数和数据类型 但是这并不是给函数传递必备信息的唯一方法<br>\n还有一种方法是传递两个指针 第 1 个指针指明数组的开始处 (与前面用法相同), 第 2 个指针指明数组的结束处.</p>\n<blockquote>\n<pre><code>#include &lt;stdio.h&gt;\n#define SIZE 10\nint sump(int * start, int * end);\nint main(void)\n{\n    int marbles[SIZE] = {20,10,5,39,4,16,19,26,31,20};\n    long answer;\n    \n    answer = sump(marbles, marbles + SIZE);\n    printf(\"The total number of marbles is %ld.\\n\", answer);\n    \n    return 0;\n}\n\n/* use pointer arithmetic   */\nint sump(int * start, int * end)\n{\n    int total = 0;\n    \n    while (start &lt; end)\n    {\n        total += *start; // add value to total\n        start++;         // advance pointer to next element\n    }\n    \n    return total;\n}\n</code></pre>\n</blockquote>\n<p>指针 start 指向 marbles 数组的首元素 所以赋值表达式 total += *start 把首元素 (20) 加给 total 然后表达式 start++ 递增指针变量 start 使其指向数组的下一个元素 因为 start 是指向 int 的指针 start 递增 1 相当于其值递增 int 类型的大小<br>\n注意这里 sump () 函数用另一种方法结束加法循环 sump () 函数使用第二个指针 start &lt; end 来结束循环<br>\n whild 循环的测试条件是一个不相等的关系 所以循环最后处理的一个元素是 end 所指向位置的前一个元素 这意味着 end 指向的位置实际上在数组最后一个元素后面 C 保证在给数组分配空间时 之下宁数组后面第一个位置的指针仍然是有效的指针 这使得 while 循环的测试条件是有效的，因为 start 在循环最后的值是 end<br>\nanswer = sump(marbles, marbles + SIZE);<br>\n 下标从 0 开始 marbles+SIZE 指向数组末尾的下一个位置 如果 end 指向数组的最后一个元素而不是数组末尾的下个位置 则必须 - 1<br>\n 这种写法不简洁也不好记 很容易导致标称错误<br>\n **C 语言虽然保证了 marbles+SIZE 有效 但是对 marbles [SIZE](即存储在该位置上的值) 未作任何保证 所以程序不能访问该位置<br>\n循环体可以压缩成一行代码 total += *start++;<br>\n* 和 ++ 的优先级相同 结合律是从右往左 所以 start++ 先求值 然后才是 * start 也就是说 start 先递增后指向 使用后缀形式 start++ 而不是 ++start 意味着先把指针指向位置上的值加到 total 上然后再递增指针切记 (*start)++ 是完全错误的这表示先使用 start 指向的指 然后再递增该值 而不是递增指针 这样指针将一直指向同一个位置 但是在该位置上的值发生了变化 虽然 * start++ 的写法比较常用 但是 *(start++) 这样写更清楚</p>\n<h5 id=\"指针表示法和数组表示法\"><a class=\"markdownIt-Anchor\" href=\"#指针表示法和数组表示法\">#</a> 指针表示法和数组表示法</h5>\n<p>对于 C 语言而言 ar [i\\ 和 *(ar + i) 这两个表达式都是等价的无论 ar 是数组名还是指针变量 这两个表达式都没问题 但是只要有当 ar 是指针变量的时候才能使用 arr++ 这样的表达式<br>\n指针表示法更接近机器语言 因此一些编译器在编译时能生成效率更高的代码</p>\n<h4 id=\"指针操作\"><a class=\"markdownIt-Anchor\" href=\"#指针操作\">#</a> 指针操作</h4>\n<p><strong>赋值</strong>：可以把地址赋给指针 注意地址应该和指针类型兼容 也就是说不能把 double 类型的地址赋给指向 int 的指针至少要避免不明智的类型转换 C99/C11 已经不云讯这样做<br>\n<strong>解引用</strong>:* 运算符给出指针指向地址上存储的值<br>\n<strong>取址</strong>：和所有变量一样指针变量也有自己的地址和值 同样使用 &amp; 给出指针本身的地址<br>\n<strong>指针和整数相加</strong>：可以使用 + 运算符把指针和整数相加 或整数和指针相加 无论哪种情况 整数都会和指针指向类型的大小 (以字节为单位) 相乘然后把结果和初始位置相加 如果相加的结果超出了初始指针指向的数组范围 计算结果则是未定义的 除非正好超过数组末尾第一个位置<br>\n<strong>递增指针</strong>：递增指向数组元素的指针可以让该指针移动至数组的下一个元素，但是指针自己的地址是不会发生变化的毕竟变量不会因为值发生变化就移动位置<br>\n<strong>指针减去一个整数</strong>：大概和加法相同 但是这里和加法不同 <strong>指针必须是第 1 个运算对象 整数是第 2 个运算对象</strong><br>\n<strong>递减指针</strong>：类比递增指针<br>\n<strong>指针求差</strong>：通常求差的两个指针分别指向同一个数组的不同元素，通过计算求出两元素之间的距离 差值的单位和数组类型的单位相同 只要两个指针都指向相同的数组 (或者其中一个指针指向数组后面的第 1 个地址) C 都能保证相减运算有效<br>\n<strong>比较</strong>使用关系运算符可以比较两个指针的值 前提是两个指针都指向相同类型的对象<br>\n<strong> FBI WARNING 注意注意注意注意注意注意注意注意注意注意 FBI WARNING</strong><br>\n 这里的减法有两种 一个指针减去另一个指针得到一个整数 或者用一个指针减去一个整数得到另一个指针<br>\n递增递减指针时还要注意一些问题 编译器不会检查指针是否指向数组元素 C 只能保证指向数组任意元素的指针和指向数组后面第一个位置的指针有效。但是如果递增或者递减一个指针后超出了这个范围则是未定义的 另外 可以解引用指向数组任意元素的指针但是即使指针指向数组后面一个位置是有效的也不能保证可以解引用这样的越界指针<br>\n创建一个指针时 系统只分配了存储指针本身的内存 并未分配存储数据的内存在使用指针之前必须先用已分配的地址初始化它</p>\n<h4 id=\"处理数组中的数据\"><a class=\"markdownIt-Anchor\" href=\"#处理数组中的数据\">#</a> 处理数组中的数据</h4>\n<p>C 通常都按值传递数据 因为这样做可以保证数据的完整性 如果函数使用的是原始数据的副本 就不会意外修改原始数据 但是处理数组的函数通常都需要使用原始数据因此这样的函数可以修改原数组 有时这正是我们需要的<br>\n然而其他函数并不需要修改数据 这样变成错误就可能会破坏原始数据</p>\n<h5 id=\"对形式参数使用const\"><a class=\"markdownIt-Anchor\" href=\"#对形式参数使用const\">#</a> 对形式参数使用 const</h5>\n<p>ANSI C 提供了一种预防手段 如果函数的意图不是修改数组中的数据内容 那么在函数原型和函数定义中声明形式参数时使用关键字 const<br>\n 这样如果在函数中不小心使用了错误的表达式使原数组发生了改变，编译器会捕获这个错误并且生成一条错误信息.<br>\n 使用 const 并不是要求原数组是常量而是该函数在处理数组时将其视为常量不可更改<br>\n一般而言如果编写的函数不用修改数组 那么在声明数组形参时最好使用 const</p>\n<h5 id=\"const的其他内容\"><a class=\"markdownIt-Anchor\" href=\"#const的其他内容\">#</a> const 的其他内容</h5>\n<p>虽然用 #define 指令可以创建类似功能的符号常量 但是 const 的用法更加灵活 可以创建 const 数组 const 指针和指向 const 的指针<br>\n指向 const 的指针通常用语函数形参中 表明该函数不会使用指针改变数据<br>\n把 const 数据或非 const 数据的地址初始化为指向 const 的指针或为其赋值是合法的<br>\n然后只能把非 const 数据的地址赋给普通指针<br>\n因此对函数的形参使用 const 不仅能保护数据 还能让函数处理 const 数组<br>\n C 标准规定使用非 const 标识符改修 const 数据导致的结果是未定义的<br>\n const 还可以声明并初始化一个<strong>不能指向别处</strong>的指针</p>\n<blockquote>\n<pre><code>double rates[5] = {};\ndouble * const pc = rates;\npc = &amp;rates[2]; 不逊于 因为该指针不能指向别处\n</code></pre>\n</blockquote>\n<p>可以用这种指针修改它所指向的值 但是它只能指向初始化时设置的地址</p>\n<blockquote>\n<pre><code>const double * const pc = rates;\n</code></pre>\n</blockquote>\n<p>在创建指针时使用两次 const 该指针既不能更改他所指向的地址 也不能更改它所指向地址上的值</p>\n<h4 id=\"指针和多维数组\"><a class=\"markdownIt-Anchor\" href=\"#指针和多维数组\">#</a> 指针和多维数组</h4>\n<blockquote>\n<pre><code>int zippo[4][2];  /内涵int数组的数组/\n</code></pre>\n</blockquote>\n<ol>\n<li>数组名 zippo 是该数组首元素的地址 zippo 的首元素一个内含 2 个 int 值得数组 所以 zippo 是这个内涵两个 int 值的数组的地址</li>\n<li>zippo 是数组首元素的地址 zippo [0] 那么就是数组首元素数组的首元素的值 zippo [0] 是一个占用一个 int 大小对象的地址 而 zippo 是一个占用两个 int 大小对象的地址 由于这个整数和内涵两个整数的数组都开始与同一个地址所以 zippo 和 zippo [0] 的值相同</li>\n<li>给指针或地址加 1 其值会增加对应类型的大小 <strong>在这方面 zippo 和 zippo [0] 不同</strong> 因为 zippo 指向的对象占用了两个 int 大小 而 zippo [0] 指向的的对象只占用一个 int 大小</li>\n<li>在解引用一个指针或在数组名后使用带下标的 [] 运算符，得到解引用对象代表的值 *zippo 代表的是 zippo 首元素的值 而 zippo 首元素的值是一个数组那么这个数组的值就是 zippo 首元素数组的首元素的地址 这样来说 **zippo 和 *&amp;zippo [0][0] 等价简而言之 zippo 是地址的地址，必须解引用两次才能获得原始值 地址的地址 或者指针的指针就是双重间接</li>\n</ol>\n<blockquote>\n<pre><code>#include &lt;stdio.h&gt;\nint main(void)\n{\n     int zippo[4][2] = { { 2, 4 }, { 6, 8 }, { 1, 3 }, { 5, 7 } };\n\n     printf(\"   zippo = %p,    zippo + 1 = %p\\n\",zippo, zippo + 1);\n     printf(\"zippo[0] = %p, zippo[0] + 1 = %p\\n\",zippo[0], zippo[0] + 1);\n     printf(\"  *zippo = %p,   *zippo + 1 = %p\\n\",*zippo, *zippo + 1);\n     printf(\"zippo[0][0] = %d\\n\", zippo[0][0]);\n     printf(\"  *zippo[0] = %d\\n\", *zippo[0]);\n     printf(\"    **zippo = %d\\n\", **zippo);\n     printf(\"      zippo[2][1] = %d\\n\", zippo[2][1]);\n     printf(\"*(*(zippo+2) + 1) = %d\\n\", *(*(zippo + 2) + 1));\n\n     return 0;\n}\n</code></pre>\n</blockquote>\n<p><strong>完整理解整个程序的输出结果</strong><br>\n特别注意与 zippo [2][1] 等价的指针表示法是 *(*(zippo+2)+1)<br>\n 这张视图演示了数组地址 数组内容和指针之间的关系<br>\n<a href=\"https://imgtu.com/i/Ic4B0s\"><img src=\"https://z3.ax1x.com/2021/11/14/Ic4B0s.png\" alt=\"Ic4B0s.png\"></a></p>\n<h5 id=\"指向多维数组的指针\"><a class=\"markdownIt-Anchor\" href=\"#指向多维数组的指针\">#</a> 指向多维数组的指针</h5>\n<blockquote>\n<pre><code>int (*pz) [2]  //表示pz指向一个内含两个int类型值得数组\n</code></pre>\n</blockquote>\n<p>以上代码把 pz 声明为指向一个数组的指针 该数组含有两个 int 类型值<br>\n<strong>括号的原因是 [] 的优先级高于 *</strong></p>\n<blockquote>\n<pre><code>int * pax[2]   此时pax是一个内涵两个指针元素的数组 每个元素都指向int的指针\n</code></pre>\n</blockquote>\n<hr>\n<blockquote>\n<pre><code>#include &lt;stdio.h&gt;\nint main(void)\n{\n     int zippo[4][2] = { { 2, 4 }, { 6, 8 }, { 1,   &gt;     3 }, { 5, 7 } };\n     int(*pz)[2];\n     pz = zippo;\n\n     printf(\"   pz = %p,    pz + 1 = %p\\n\",    pz,   &gt;     pz + 1);\n     printf(\"pz[0] = %p, pz[0] + 1 = %p\\n\",    pz  &gt;     [0], pz[0] + 1);\n     printf(\"  *pz = %p,   *pz + 1 = %p\\n\",      &gt;     *pz, *pz + 1);\n     printf(\"pz[0][0] = %d\\n\", pz[0][0]);\n     printf(\"  *pz[0] = %d\\n\", *pz[0]);\n     printf(\"    **pz = %d\\n\", **pz);\n     printf(\"      pz[2][1] = %d\\n\", pz[2][1]);\n     printf(\"*(*(pz+2) + 1) = %d\\n\", *(*(pz + 2) +   &gt;     1));\n\n     return 0;\n}\n</code></pre>\n</blockquote>\n<p>虽然 pz 是一个指针 不是数组名但是也可以用 pz [2][1] 这样的写法 可以用数组表示法或指针表示法来表示一个数组元素 既可以用数组名 也可以用指针名</p>\n<h5 id=\"指针的兼容性\"><a class=\"markdownIt-Anchor\" href=\"#指针的兼容性\">#</a> 指针的兼容性</h5>\n<p>指针之间的赋值比数值类型之间的赋值要严格<br>\n不用类型转换就可以吧 int 类型的值赋给 double 类型的变量但是两个类型的指针不能这样做</p>\n<blockquote>\n<pre><code>int x = 20;\nconst int y = 23;\nint * p1 = &amp;x;\nconst int * p2 = &amp;y;\nconst int ** pp2;\np1 = p2;        // 不安全 -- 把const指针赋给非const指针\np2 = p1;        // 有效 -- 把非const指针赋给const指针\npp2 = &amp;p1;      // 不安全 –- 嵌套指针类型赋值\n</code></pre>\n</blockquote>\n<hr>\n<blockquote>\n<pre><code>int * pt;\nint (*pa)[3];\nint ar1[2][3];\nint ar2[3][2];\nint **p2;    // 一个指向指针的指针\n</code></pre>\n</blockquote>\n<hr>\n<blockquote>\n<pre><code>pt = &amp;ar1[0][0];     // 都是指向int的指针\npt = ar1[0];         // 都是指向int的指针\npt = ar1;            // 无效\npa = ar1;            // 都是指向内含3个int类型元素数组的指针\npa = ar2;            // 无效\np2 = &amp;pt;            // 都是指向int *的指针\n*p2 = ar2[0];        // 都是指向int的指针\np2 = ar2;            // 无效\n</code></pre>\n</blockquote>\n<p>理解以上的代码</p>\n<h5 id=\"函数和多维数组\"><a class=\"markdownIt-Anchor\" href=\"#函数和多维数组\">#</a> 函数和多维数组</h5>\n<p>编写一个处理二维数组的函数 一种方法是 利用 for 循环把处理一维数组的函数应用到二维数组的每一行</p>\n<blockquote>\n<pre><code>int junk[3][4] = {{2,4,5,8},{3,5,6,9},{12,10,8,6}};\nint i ,j;\nint total = 0;\nfor(i=0;i&lt;3;i++) \ntotal +=sum(junk[i],4);\n</code></pre>\n</blockquote>\n<p>junk 是二维数组 那么 junk [i] 就是一堆数组 可将其视为二维数组的一行 sum () 函数计算二维数组的每行的综合 然后 for 循环再把每行的总和加起来<br>\n这种方法无法记录行和列的信息 用这种方法计算总和  行和列的信息并不重要 但如果每行代表一年 每列代表一个月 就还需要一个函数计算某列的综合 可以通过声明正确的形参变量来完成 以便函数能正确地传递数组</p>\n<blockquote>\n<pre><code>void somefunction(int (*pt)[4]);\nvoid somefunction(int pt[][4]);  //当且仅当pt是一个函数的形式参数时可以这样声明\n</code></pre>\n</blockquote>\n<p>第一个方括号是空的  表示 pt 是一个指针</p>\n<blockquote>\n<pre><code>// array2d.c -- 处理二维数组的函数\n#include &lt;stdio.h&gt;\n#define ROWS 3\n#define COLS 4\nvoid sum_rows(int ar[][COLS], int rows);\nvoid sum_cols(int [][COLS], int);        // 省略形参名，没问题\nint sum2d(int(*ar)[COLS], int rows);     // 另一种语法\nint main(void)\n{\n     int junk[ROWS][COLS] = {\n               { 2, 4, 6, 8 },\n               { 3, 5, 7, 9 },\n               { 12, 10, 8, 6 }\n     };\n\n     sum_rows(junk, ROWS);\n     sum_cols(junk, ROWS);\n     printf(\"Sum of all elements = %d\\n\", sum2d(junk, ROWS));\n\n     return 0;\n}\n\nvoid sum_rows(int ar[][COLS], int rows)\n{\n     int r;\n     int c;\n     int tot;\n\n     for (r = 0; r &lt; rows; r++)\n     {\n          tot = 0;\n          for (c = 0; c &lt; COLS; c++)\n               tot += ar[r][c];\n          printf(\"row %d: sum = %d\\n\", r, tot);\n     }\n}\n\nvoid sum_cols(int ar[][COLS], int rows)\n{\n     int r;\n     int c;\n     int tot;\n\n     for (c = 0; c &lt; COLS; c++)\n     {\n          tot = 0;\n          for (r = 0; r &lt; rows; r++)\n               tot += ar[r][c];\n          printf(\"col %d: sum = %d\\n\", c, tot);\n     }\n}\n\nint sum2d(int ar[][COLS], int rows)\n{\n     int r;\n     int c;\n     int tot = 0;\n\n     for (r = 0; r &lt; rows; r++)\n          for (c = 0; c &lt; COLS; c++)\n               tot += ar[r][c];\n\n     return tot;\n}\n</code></pre>\n</blockquote>\n<hr>\n<p>输出结果</p>\n<blockquote>\n<pre><code>row 0: sum = 20\nrow 1: sum = 24\nrow 2: sum = 36\ncol 0: sum = 17\ncol 1: sum = 19\ncol 2: sum = 21\ncol 3: sum = 23\nSum of all elements = 80\n</code></pre>\n</blockquote>\n<p>一般而言 声明一个指向 N 维数组的指针时只能省略最左边方括号中的值<br>\n第一个方括号只用于表示这是一个指针 而其他方括号则用于描述指针所指向数据对象的类型</p>\n<h4 id=\"变长数组vla\"><a class=\"markdownIt-Anchor\" href=\"#变长数组vla\">#</a> 变长数组 (VLA)</h4>\n<p>是否发现上面在处理二维数组的函数中 只把数组的行数作为函数的形参 而列数却内置在函数体内<br>\n因为 C 规定 数组的位数必须是常量 不能用变量来代替常量<br>\n C99 新增了变长数组 允许使用变量表示数组的维度</p>\n<blockquote>\n<pre><code>int a = 4;\nint b = 5;\ndouble sales[a][b];  //一个变长数组\n</code></pre>\n</blockquote>\n<p>变长数组有一些限制 变长数组必须是自动存储类别 这意味着无论在函数中声明还是作为函数形参声明 都不能使用 static 和 extern 存储类别说明符 并且不能在声明中初始化他们<br>\n变长数组中的变 不是指可以修改已经创建数组的大小 而是 在创建数组时，可以使用变量指定数组的维度<br>\n声明一个带二维变长数组参数的函数</p>\n<blockquote>\n<pre><code>int sum2d(int row,int cols, int ar [rows][cols])   //有效\nint sum2d(int ar [rows][cols],int cols, int row)   //无效\n</code></pre>\n</blockquote>\n<p>因为 row 和 cols 用做第三个形参二维数组 ar 的两个维度 ar 的声明要使用 rows 和 cols 所以在形参列表中必须在声明 ar 之前先声明这两个形参<br>\n C99/C11 标准规定 可以省略原型中的形参名 但是在这种情况下必须用型号来代替省略的维度</p>\n<blockquote>\n<pre><code>int sum2d(int,int,int ar[*][*]);\n</code></pre>\n</blockquote>\n<p>函数定义的形参列表中表明的变长数组并未实际创建数组<br>\n变长数组实际上是一个指针 这说明变长数组形参的函数实际上实在原始数组中处理数组 因此可以修改传入的数组</p>\n<h5 id=\"const和数组大小\"><a class=\"markdownIt-Anchor\" href=\"#const和数组大小\">#</a> const 和数组大小</h5>\n<p>是否可以在声明数组时使用 const 变量？</p>\n<blockquote>\n<pre><code>const int SZ = 80;\ndouble ar[SZ];\n</code></pre>\n</blockquote>\n<p>C99/C11 标准允许在声明变长数组时使用 const 常量 所以该数组的定义必须是声明在块中的自动存储类别数组.</p>\n<h4 id=\"复合字面量\"><a class=\"markdownIt-Anchor\" href=\"#复合字面量\">#</a> 复合字面量</h4>\n<p>字面量是除符号常量外的常量 例如 5 是 int 类型字面量 81.3 是 double 类型字面量 'Y’是 char 类型的字面量 \"elephant\" 是字符串类型的字面量<br>\n对于数组 复合字面量类似数组初始化列表 前面是用括号括起来的类型名</p>\n<blockquote>\n<pre><code>int diva[2] = {10,20};   \n(int [2]){10,20}   //复合自变量\n</code></pre>\n</blockquote>\n<p>int [2] 就是复合字面量的类型名<br>\n初始化复合字面量可以省略大小 编译器会自动计算数组当前的元素个数</p>\n<blockquote>\n<pre><code>(int []){50,20,90}\n</code></pre>\n</blockquote>\n<p>复合字面量是匿名的 所以不能先创建然后再使用他 必须在创建的同意使用他 使用指针记录地址就是一种用法</p>\n<blockquote>\n<pre><code>int * pt1;\npt1 = (int [2]){10,20}\n</code></pre>\n</blockquote>\n<p>该复合字面量的字面常量和上面创建的 diva 数组的字面常量完全相同 复合字面量的类型名也代表首元素的地址<br>\n还可以把复合字面量作为实际参数传递给带有匹配形式参数的函数</p>\n<blockquote>\n<pre><code>total = sum((int[]){4,4,4,5,5,5},6)\n</code></pre>\n</blockquote>\n<p>这种用法的好处是 把信息传入函数前不必先创建数组 这是复合字面量的典型用法<br>\n该用法应用于二维数组或者多维数组</p>\n<blockquote>\n<pre><code>int (*pt2)[4];\nptr2 = (int [2][4]) {{1,2,3,-9},{4,5,6,-8}};\n</code></pre>\n</blockquote>\n<p>演示了如何创建二维 int 数组并存储其地址<br>\n复合字面量是提供至临时需要的值得一种手段 复合字面量具有块作用域，这意味着一旦离开定义复合字面量的块 程序将无法保证该字面量是否存在 也就是说 复合字面量的定义在最内层的花括号中</p>\n<h4 id=\"数组关键概念\"><a class=\"markdownIt-Anchor\" href=\"#数组关键概念\">#</a> 数组关键概念</h4>\n<p>数组用于存储相同类型的数据。C 把数组看作是派生类型，因为数组是建立在其他类型的基础上。也就是说，无法简单地声明一个数组。在声明数组时必须说明其元素的类型，如 int 类型的数组、float 类型的数组，或其他类型的数组。所谓的其他类型也可以是数组类型，这种情况下，创建的是数组的数组（或称为二维数组）。</p>\n<p>通常编写一个函数来处理数组，这样在特定的函数中解决特定的问题，有助于实现程序的模块化。在把数组名作为实际参数时，传递给函数的不是整个数组，而是数组的地址（因此，函数对应的形式参数是指针）。为了处理数组，函数必须知道从何处开始读取数据和要处理多少个数组元素。数组地址提供了 “地址”，“元素个数” 可以内置在函数中或作为单独的参数传递。第 2 种方法更普遍，因为这样做可以让同一个函数处理不同大小的数组。</p>\n<p>数组和指针的关系密切，同一个操作可以用数组表示法或指针表示法。它们之间的关系允许你在处理数组的函数中使用数组表示法，即使函数的形式参数是一个指针，而不是数组。</p>\n<p>对于传统的 C 数组，必须用常量表达式指明数组的大小，所以数组大小在编译时就已确定。C99/C11 新增了变长数组，可以用变量表示数组大小。这意味着变长数组的大小延迟到程序运行时才确定。</p>\n<h4 id=\"数组小结\"><a class=\"markdownIt-Anchor\" href=\"#数组小结\">#</a> 数组小结</h4>\n<p>数组是一组数据类型相同的元素。数组元素按顺序存储在内存中，通过整数下标（或索引）可以访问各元素。在 C 中，数组首元素的下标是 0，所以对于内含 n 个元素的数组，其最后一个元素的下标是 n-1。作为程序员，要确保使用有效的数组下标，因为编译器和运行的程序都不会检查下标的有效性。<br>\n声明一个简单的一维数组形式如下：</p>\n<blockquote>\n<pre><code>type name [ size ];\n</code></pre>\n</blockquote>\n<p>这里，type 是数组中每个元素的数据类型，name 是数组名，size 是数组元素的个数。对于传统的 C 数组，要求 size 是整型常量表达式。但是 C99/C11 允许使用整型非常量表达式。这种情况下的数组被称为变长数组。</p>\n<p>C 把数组名解释为该数组首元素的地址。换言之，数组名与指向该数组首元素的指针等价。概括地说，数组和指针的关系十分密切。如果 ar 是一个数组，那么表达式 ar [i] 和 *(ar+i) 等价。</p>\n<p>对于 C 语言而言，不能把整个数组作为参数传递给函数，但是可以传递数组的地址。然后函数可以使用传入的地址操控原始数组。如果函数没有修改原始数组的意图，应在声明函数的形式参数时使用关键字 const。在被调函数中可以使用数组表示法或指针表示法，无论用哪种表示法，实际上使用的都是指针变量。</p>\n<p>指针加上一个整数或递增指针，指针的值以所指向对象的大小为单位改变。也就是说，如果 pd 指向一个数组的 8 字节 double 类型值，那么 pd 加 1 意味着其值加 8，以便它指向该数组的下一个元素。</p>\n<p>二维数组即是数组的数组。例如，下面声明了一个二维数组：</p>\n<blockquote>\n<pre><code>double sales[5][12];\n</code></pre>\n</blockquote>\n<p>该数组名为 sales，有 5 个元素（一维数组），每个元素都是一个内含 12 个 double 类型值的数组。第 1 个一维数组是 sales [0]，第 2 个一维数组是 sales [1]，以此类推，每个元素都是内含 12 个 double 类型值的数组。使用第 2 个下标可以访问这些一维数组中的特定元素。例如，sales [2][5] 是 slaes [2] 的第 6 个元素，而 sales [2] 是 sales 的第 3 个元素。</p>\n<p>C 语言传递多维数组的传统方法是把数组名（即数组的地址）传递给类型匹配的指针形参。声明这样的指针形参要指定所有的数组维度，除了第 1 个维度。传递的第 1 个维度通常作为第 2 个参数。例如，为了处理前面声明的 sales 数组，函数原型和函数调用如下：</p>\n<blockquote>\n<pre><code>void display(double ar[][12], int rows);\n...\ndisplay(sales, 5);\n</code></pre>\n</blockquote>\n<p>变长数组提供第 2 种语法，把数组维度作为参数传递。在这种情况下，对应函数原型和函数调用如下：</p>\n<blockquote>\n<pre><code>void display(int rows, int cols, double ar[rows][cols]);\n...\ndisplay(5, 12, sales);\n</code></pre>\n</blockquote>\n<p>虽然上述讨论中使用的是 int 类型的数组和 double 类型的数组，其他类型的数组也是如此。然而，字符串有一些特殊的规则，这是由于其末尾的空字符所致。有了这个空字符，不用传递数组的大小，函数通过检测字符串的末尾也知道在何处停止。我们将在第 11 章中详细介绍。</p>\n<h3 id=\"第十一章字符串和字符串函数\"><a class=\"markdownIt-Anchor\" href=\"#第十一章字符串和字符串函数\">#</a> 第十一章字符串和字符串函数</h3>\n<h4 id=\"表示字符串和字符串io\"><a class=\"markdownIt-Anchor\" href=\"#表示字符串和字符串io\">#</a> 表示字符串和字符串 I/O</h4>\n<p>字符串是以空字符 (\\o) 结尾的 char 类型数组</p>\n<blockquote>\n<pre><code>#include &lt;stdio.h&gt;\n#define MSG \"I am a symbolic string constant.\"\n#define MAXLENGTH 81\nint main(void)\n{\n     char words[MAXLENGTH] = \"I am a string in an array.\";\n     const char * pt1 = \"Something is pointing at me.\";\n     puts(\"Here are some strings:\");\n     puts(MSG);\n     puts(words);\n     puts(pt1);\n     words[8] = 'p';\n     puts(words);\n\n     return 0;\n}\n</code></pre>\n</blockquote>\n<p>和 printf () 函数相同 puts () 函数也属于 stdio.h 系列的输出 / 输出函数 但是和 printf () 不同的是 puts () 函数只显示字符串 而且自动在显示的字符串末尾加上换行符</p>\n<h5 id=\"在程序中定义字符串\"><a class=\"markdownIt-Anchor\" href=\"#在程序中定义字符串\">#</a> 在程序中定义字符串</h5>\n<h6 id=\"1字符串字面量字符串常量\"><a class=\"markdownIt-Anchor\" href=\"#1字符串字面量字符串常量\">#</a> 1. 字符串字面量 (字符串常量)</h6>\n<p>字符串字面量 (字符串常量): 用双引号括起来的内容 双引号中的字符和编译器自动加入末尾的 \\O 字符 都作为字符串存储在内存中<br>\n从 ANSI C 标准起 如果字符串字面量之间没有间隔 或者用空白字符分隔 C 会将其视为串联起来的字符串常量</p>\n<blockquote>\n<pre><code>char greeting[50] = \"Hello,and\"\"how are\"  \" you\"\n                     \"\" today!\" ;\nchar greeting [50] = \"Hello,and how are you today!\"\n</code></pre>\n<blockquote>\n<p>这两行代码是等价的</p>\n</blockquote>\n</blockquote>\n<p>如果要在字符串内部使用双引号 必须要在双引号前面加上一个反斜杠 (\\)<br>\n 字符串常量属于<strong>静态存储类别</strong>，这说明 如果在函数中使用字符串常量 该字符串只会被存储一次 在整个程序的生命周期内存在 即使函数被调用多次 用双引号括起来的内容被视为指向该字符串存储位置的指针。类似于把数组名作为指向该数组位置的指针</p>\n<blockquote>\n<pre><code>#include &lt;stdio.h&gt;\nint main(void)\n{\n     printf(\"%s, %p, %c\\n\", \"We\", \"are\", *\"space farers\");\n\n     return 0;\n}\n</code></pre>\n</blockquote>\n<p>% s 打印 We 根据 % p 转换说明打印一个地址 *\"space farers\" 表示该字符串所指向地址所存储的值 应该是字符串 \"space farers\" 的首字符</p>\n<h6 id=\"2字符串数组和初始化\"><a class=\"markdownIt-Anchor\" href=\"#2字符串数组和初始化\">#</a> 2. 字符串数组和初始化</h6>\n<p>定义字符串数组时 必须让编译器知道需要多少空间 一种方法是用足够空间的数组 存储字符串</p>\n<blockquote>\n<pre><code>const char m1[40] = \"Limit yourself to one line's worth.\";\n</code></pre>\n</blockquote>\n<p>这种形式的初始化比标准的数组初始化形式简单得多</p>\n<blockquote>\n<pre><code>const char m1[40] = { 'L','i', 'm', 'i', 't', ' ', 'y', 'o', 'u', 'r', 's', 'e', 'l',\n                      'f', ' ', 't', 'o', ' ', 'o', 'n', 'e', ' ','l', 'i', 'n', 'e',   \n                      '\\', 's', ' ', 'w', 'o', 'r','t', 'h', '.', '\\0'\n};\n</code></pre>\n</blockquote>\n<p>注意最后的空字符 没有这个空字符 这就不是一个字符串 而是一个字符数组<br>\n在指定数组大小时候要确保数组的元素个数至少比字符串长度多 1 (为了容纳空字符) 所有违背使用的元素都被自动化初始为 \\0 空字符<br>\n省略数组初始化声明中的大小编译器会自动计算数组的大小<br>\n处理字符串的函数通常都不知道数组的大小 这些函数通过查找字符串末尾的空字符确定字符串在何处结束<br>\n让编译器计算输的的大小只能用在初始化数组时。如果创建一个稍后再填充的数组 就必须在声明时指定大小。声明数组时数组大小 IXUS 是可求值得整数 在 CC 新增变长数组迁 数组的大小必须是整型变量 包括由整型变量组成的表达式</p>\n<p>字符数组名和其他数组名一样 是该数组首元素的地址</p>\n<p>同时还可以使用指针表示法创建字符串</p>\n<blockquote>\n<pre><code>const char * pt1 =\"yogmas best\";\nconst char ar1[] = \"yogmas best\";\n</code></pre>\n</blockquote>\n<p>这两个声明几乎相同<br>\n以上两个声明表示 pt1 和 ar1 都是该字符串的地址 在这两种情况下 带双引号的字符串本身决定了鱼类给字符串的存储空间 尽管如此 这两种形式并不完全相同</p>\n<h6 id=\"3数组和指针\"><a class=\"markdownIt-Anchor\" href=\"#3数组和指针\">#</a> 3. 数组和指针</h6>\n<p>数组形式和指针形式有一些不同点<br>\n数组形式：数组形式在计算机的内存中分配一个数组 (每个元素对应一个字符 再加上一个末尾的空字符), 每个元素被初始化为字符串字面量对应的字符.<br>\n 字符串都作为可执行文件的一部分存储在数据段中 当把程序载入内存时 也载入了了程序中的字符串 字符串存储在静态存储区中<br>\n程序在开始运行时 才为该数组分配内存 此时 才将字符串拷贝到数组中<br>\n此时字符串有两个副本 一个是在静态内存中的字符串字面量 另一个是存储在数组中的字符串<br>\n编译器把数组名识别为该数组首元素地址的别名 这以为着在数组形式中数组名是字符常量 不能更改 如果改变了就意味着改变了数组的存储位置 可以进行类似 ar1+1 这样的操作 表示数组的下一个元素 但是不允许进行 ++ar1 这样的操作 递增运算符只能用于变量名前</p>\n<p>指针形式：指针形式是的编译器为字符串在静态存储区预留 29 个元素的空间 另外一旦开始执行程序 他会为<strong>指针变量</strong>留出一个存储位置 并把字符串的地址存储在指针变量中 该变量最初指向该字符串的首字符但是它的值可以改变 因此可以使用递增运算符<br>\n<strong>字符串字面量被视为 const 数据</strong></p>\n<h5 id=\"指针和字符串\"><a class=\"markdownIt-Anchor\" href=\"#指针和字符串\">#</a> 指针和字符串</h5>\n<p>字符串的绝大多数操作都是通过指针完成的</p>\n<blockquote>\n<pre><code>#include &lt;stdio.h&gt;\nint main(void)\n{\n     const char * mesg = \"Don't be a fool!\";\n     const char * copy;\n\n     copy = mesg;\n     printf(\"%s\\n\", copy);\n     printf(\"mesg = %s; &amp;mesg = %p; value = %p\\n\", mesg, &amp;mesg, mesg);\n     printf(\"copy = %s; &amp;copy = %p; value = %p\\n\", copy, &amp;copy, copy);\n\n     return 0;\n}\n</code></pre>\n<p>如果编译器不识别 % p 用 % u 或者 % lu 来代替<br>\n字符串形式输出用 % s 转换说明<br>\n因为最后 mesg 和 copy 指针输出的值是一样的 即两个指针指向地址是一样的 这说明程序并未拷贝字符串 copy=mesg 仅仅把 mesg 的值即 mesg 存储的地址赋值给 copy 让 copy 也指向这一个地址<br>\n不拷贝整个字符串的原因是因为这样做更具有效率 如果一定要拷贝字符串可以使用 **strcpy () 和 strncpy ()** 函数，后续会介绍这两个函数</p>\n</blockquote>\n<h4 id=\"字符串输入\"><a class=\"markdownIt-Anchor\" href=\"#字符串输入\">#</a> 字符串输入</h4>\n<p>如果想把一个字符串读入程序 首先必须预留存储该字符串的空间 然后用输入函数获取该字符串</p>\n<h5 id=\"分配空间\"><a class=\"markdownIt-Anchor\" href=\"#分配空间\">#</a> 分配空间</h5>\n<p>分配空间的时候必须为字符串分配足够的空间 <strong>不要指望计算机在读取字符串的时候顺便计算它的长度然后再分配空间</strong> (计算机不会这样做 除非你编写一个处理这些任务的函数)</p>\n<blockquote>\n<pre><code>char * name;\nscanf(\"%s\",name);\n</code></pre>\n</blockquote>\n<p>可能会通过编译 但是在读入 name 时 name 可能会擦写掉程序中的数据或代码 而导致程序异常终止<br>\n因为 scanf () 要把信息拷贝到参数指定的地址上 此时 该参数是个未初始化的指针 name 可能会指向任何地方</p>\n<ul>\n<li>最简单的方法是 在声明时指明数组的大小</li>\n</ul>\n<blockquote>\n<pre><code>char name[81];\n</code></pre>\n</blockquote>\n<ul>\n<li>还有一种方法：使用 C 库函数来分配内存 (第 12 章)</li>\n</ul>\n<p>为字符串分配玩内存后 开始讨论读取字符串的函数</p>\n<h5 id=\"gets函数不幸\"><a class=\"markdownIt-Anchor\" href=\"#gets函数不幸\">#</a> gets () 函数–不幸</h5>\n<p>在读取字符串时，scanf () 和转换说明 % s 只能读取一个单词<br>\n程序中经常要读取一整行输入 gets () 函数就用于处理这种情况</p>\n<ul>\n<li>get () 函数读取整行输入 直到遇到换行符 然后丢弃换行符 存储其余字符 并在这些字符的末尾添加一个空字符使其称为一个 C 字符串 其经常和 puts () 函数配对使用</li>\n<li>puts () 函数用于显示字符串 并且在末尾添加换行符</li>\n</ul>\n<blockquote>\n<pre><code>#include &lt;stdio.h&gt;\n#define STLEN 81\nint main(void)\n{\n     char words[STLEN];\n\n     puts(\"Enter a string, please.\");\n     gets(words);  // 典型用法\n     printf(\"Your string twice:\\n\");\n     printf(\"%s\\n\", words);\n     puts(words);\n     puts(\"Done.\");\n\n     return 0;\n}\n</code></pre>\n</blockquote>\n<p>整行输入都被存储在 words 中 put () 和 printf () 的效果相同<br>\n但是在有些编译器中并不会输出正确的结果，并且会给出警告<br>\n gets () 的唯一参数是 words, 他无法检查数组是否装得下输入行.<br>\n 数组名仅仅是数组首元素的地址。因此，gets () 函数只知道数组的开始处 并不知道数组中有多少个元素</p>\n<p>如果输入的字符过长 会导致<strong>缓冲区溢出</strong>即多余的字符超出了指定的目标空间 如果这些多于的字符只是占用了<strong>尚未使用</strong>的内存就不会立即出现问题 如果他们擦写掉程序中的其他数据就会导致程序异常中止<br>\n<em>在过去有些人通过系统编程 利用 gets () 插入和运行一些破坏系统安全的代码</em><br>\n C99 中承认了 gets () 的问题并且建议不要使用它 尽管如此 现有程序中因为含有大量使用该函数的代码 所以在标准中保留了 gets ()<br>\n C11 直接从标准中废除了 gets () 函数<br>\n所以这就导致了有些编译器支持 gets () 函数而有些编译器不支持 gets () 函数<br>\n部分编译器为了兼容以前的代码 就继续支持 gets () 函数</p>\n<h5 id=\"gets的替代品\"><a class=\"markdownIt-Anchor\" href=\"#gets的替代品\">#</a> gets () 的替代品</h5>\n<p>过去尝尝用 fgets () 来代替 gets (),fgets () 函数稍微复杂些 在处理输入方面与 gets () 略有不同 C11 标准新增的 gets_s () 也可以代替 gets () 该函数与 gets () 函数更为接近 但是 它是 stdio.h 输入 / 输出函数系列中的可选拓展 所以编译器不一定支持它</p>\n<h6 id=\"fgets函数和fputs\"><a class=\"markdownIt-Anchor\" href=\"#fgets函数和fputs\">#</a> fgets () 函数和 (fputs)</h6>\n<p>fgets () 函数通过第 2 个参数限制读入的字符数来解决溢出的问题<br>\n<strong>该函数专门设计处理文件输入</strong>一般情况下可能不太好用<br>\n fgets () 与 gets () 的区别如下</p>\n<ul>\n<li>fgets () 函数的第 2 个参数指明了读入字符的最大数量，如果该参数是 n 那么 fgets () 函数将读入 n-1 个字符 或者读到遇到的第一个换行符为止</li>\n<li>如果 fgets () 读到一个换行符，会把它存储在字符串中 这点和 gets () 不同，gets () 会丢地换行符</li>\n<li>fgets () 函数的第三个参数执行要读入的文件 如果读入从键盘输入的数据 则以 **stdin (标准输入)<strong> 作为参数 该标识符定义在 stdio.h 中<br>\n因为 fgets () 函数把换行符放在字符串的末尾 (假设输入行不溢出) 通常要与 fputs () 配对使用，除非该函数不在字符串末尾添加换行符 fputs () 的第 2 个参数指明它要写入的文件 如果要显示在计算机显示器上，应使用</strong> stdout (标准输出)** 作为参数</li>\n</ul>\n<blockquote>\n<pre><code>#include &lt;stdio.h&gt;\n#define STLEN 14\nint main(void)\n{\n     char words[STLEN];\n\n     puts(\"Enter a string, please.\");\n     fgets(words, STLEN, stdin);\n     printf(\"Your string twice (puts(), then fputs()):\\n\");\n     puts(words);\n     fputs(words, stdout);\n     puts(\"Enter another string, please.\");\n     fgets(words, STLEN, stdin);\n     printf(\"Your string twice (puts(), then fputs()):\\n\");\n     puts(words);\n     fputs(words, stdout);\n     puts(\"Done.\");\n\n     return 0;\n}\n</code></pre>\n</blockquote>\n<p>输入案例</p>\n<blockquote>\n<pre><code>Enter a string, please.\napple pie\nYour string twice (puts(), then fputs()):\napple pie\n\napple pie\nEnter another string, please.\nstrawberry shortcake\nYour string twice (puts(), then fputs()):\nstrawberry sh\nstrawberry shDone.\n</code></pre>\n</blockquote>\n<ul>\n<li>第一行输入 apple pie 比 fgets () 读入的整行输入短 因此 apple pie 被存储在数组中 所以当 puts () 显示该字符串时又在末尾添加了换行符 因此 apple pie 后面有一行空行 因为 fputs () 不在字符串末尾添加换行符 所以并未打印出空行</li>\n<li>第二行输入 的字符超过了大小的限制 所以只会读入相应的字符 然后把前几个范围内的存储在数组中<br>\n<strong> puts () 函数会在待输入字符串末尾添加一个换行符 而 fputs () 不会这样做</strong><br>\n<strong>同样 fgets () 存储时会在末尾自动存储一个换行符 而 gets () 不会这样</strong></li>\n</ul>\n<p>fgets () 函数返回 char 的指针 该函数返回的地址与传入的一个参数相同 如果读到文件末尾将返回<strong>空指针</strong>该指针保证不会指向有效的数据 所以可用于表述特殊情况 在 C 语言中用宏 NULL 来代替 (如果读入数据错误 该函数也返回 NULL).</p>\n<p>下列函数演示了一个简单的循环 读入并显示用户输入的内容 直到 fgets () 读到文件末尾或空行 (首字符是换行符)</p>\n<blockquote>\n<pre><code>#include &lt;stdio.h&gt;\n#define STLEN 10\nint main(void)\n{\n     char words[STLEN];\n\n     puts(\"Enter strings (empty line to quit):\");\n     while (fgets(words, STLEN, stdin) != NULL &amp;&amp; words[0] != '\\n')\n          fputs(words, stdout);\n     puts(\"Done.\");\n\n     return 0;\n}\n</code></pre>\n</blockquote>\n<p>输出结果如下</p>\n<blockquote>\n<pre><code>Enter strings (empty line to quit):\nBy the way, the gets() function\nBy the way, the gets() function\nalso returns a null pointer if it\nalso returns a null pointer if it\nencounters end-of-file.\nencounters end-of-file.\n\nDone.\n</code></pre>\n</blockquote>\n<p>神奇的是 这个程序在处理过长的输入时完全没有问题<br>\n通过 while 循环每次读入 9 个字符 (虽然 STLEN 为 10 但是最后一个位置需要留给 \\0) 并且没有换行由此不断叠加<br>\n<strong> important</strong> 系统使用缓冲的 I/O 用户按 enter 键之前 输入都被存储在缓冲区中 按下 enter 键就在输入中增加了一个换行符 并且把整行输入发送给 fgets () 对出输出 fputs () 把字符发送给另一个缓冲区 当发送换行符时 缓冲区的内容被发送到屏幕上<br>\n fgets () 存储换行符有好有坏</p>\n<ul>\n<li>好处：对于存储的字符串而言 检查末尾是否有换行符可以判断是否读取了一整行</li>\n<li>坏处：可能编者本身并不想把换行符存储在字符串中 这样的换行符会带来一些麻烦</li>\n</ul>\n<p>存储的字符串 如果不是一整行 要妥善处理一行中剩下的字符</p>\n<p>如何处理掉换行符呢</p>\n<ul>\n<li>在已存储的字符串中查找换行符 并将其替换成空字符</li>\n</ul>\n<blockquote>\n<pre><code>while (words[i] != '\\n') // 假设\\n在words中\n     i++;\nwords[i] = '\\0';\n</code></pre>\n</blockquote>\n<ul>\n<li>如果仍然有字符串留在输入行怎么办，如果目标数组装不下一整行输入就丢弃多出的字符</li>\n</ul>\n<blockquote>\n<pre><code>while (getchar() != '\\n')    // 读取但不存储输入，包括\\n\ncontinue;\n</code></pre>\n</blockquote>\n<p>以下程序读取输入航 删除存储在字符串中的换行符  如果没有换行符 就丢弃数组装不下的字符</p>\n<blockquote>\n<pre><code>#include &lt;stdio.h&gt;\n#define STLEN 10\nint main(void)\n{\n     char words[STLEN];\n     int i;\n\n     puts(\"Enter strings (empty line to quit):\");\n     while (fgets(words, STLEN, stdin) != NULL &amp;&amp; words[0] != '\\n')\n     {\n          i = 0;\n          while (words[i] != '\\n' &amp;&amp; words[i] != '\\0')\n               i++;\n          if (words[i] == '\\n')\n               words[i] = '\\0';\n          else    // 如果word[i] == '\\0'则执行这部分代码\n               while (getchar() != '\\n')\n                     continue;\n          puts(words);\n     }\n     puts(\"done\");\n     return 0;\n}\n</code></pre>\n</blockquote>\n<p>遍历字符串 直到遇到换行符或者空字符 如果先遇到换行符 就替换成空字符 如果先遇到空字符 else 部分就丢弃输入行的剩余字符</p>\n<h6 id=\"gets_s函数\"><a class=\"markdownIt-Anchor\" href=\"#gets_s函数\">#</a> gets_s () 函数</h6>\n<p>和 fgets () 函数类似 用一个参数限制读入的字符数目</p>\n<p>区别如下:</p>\n<ul>\n<li>gets_s () 只从标准输入中读取数据 不需要第三个参数</li>\n<li>gets_s 读到换行符会丢弃换行符而不是存储</li>\n<li>如果 gets_s 读到最大字符数都没有读到换行符 他会先把数组中的首字符设置成空字符 读取然后丢弃随后的输入 知道读到换行符 然后返回空指针 接着调用 \"处理函数\" (可能会终止或者退出程序)</li>\n</ul>\n<p>如果输入行未超过最大字符数目 gets_s () 和 gets () 相同</p>\n<p>如果目标存储区装得下输入行 以上函数效果都一样</p>\n<p>如果输入行太长会怎样</p>\n<ul>\n<li>使用 gets () 会擦写现有数据 具有安全隐患</li>\n<li>gets_s () 很安全 但是如果不希望程序终止或者退出 就要知道如何编写 \"处理函数\" 如果让程序继续运行 gets_s 会丢弃该输入行的其余字符</li>\n<li>fgets () 综合了以上两个 可以自由选择 是截取丢弃 还是继续使用输入行中超出的字符 可以参考以上 fgets () 中两个程序的处理方法</li>\n</ul>\n<h6 id=\"s_gets函数\"><a class=\"markdownIt-Anchor\" href=\"#s_gets函数\">#</a> s_gets () 函数</h6>\n<p>fgets () 函数的一种语法 读取郑航输入并用空字符代替换行符 或者读取一部分输入 并丢弃其余部分 然而并没有处理这种情况的标准 C 库函数<br>\n所以我们就创建一个 或许在后面的程序中会用得上</p>\n<blockquote>\n<pre><code>char * s_gets(char * st, int n)\n{\n     char * ret_val;\n     int i = 0;\n\n     ret_val = fgets(st, n, stdin);\n     if (ret_val)    // 即，ret_val != NULL\n     {\n          while (st[i] != '\\n' &amp;&amp; st[i] != '\\0')\n               i++;\n          if (st[i] == '\\n')\n               st[i] = '\\0';\n          else&lt;ins&gt;\n&lt;/ins&gt;               while (getchar() != '\\n')\n                     continue;\n     }\n     return ret_val;\n}\n</code></pre>\n</blockquote>\n<p>如果 fgets () 返回 NULL，说明读到文件结尾或出现读取错误，s_gets () 函数跳过了这个过程。它模仿上面处理 fgets () 函数的的处理方法，如果字符串中出现换行符，就用空字符替换它；如果字符串中出现空字符，就丢弃该输入行的其余字符，然后返回与 fgets () 相同的值。我们在后面的示例中将讨论 fgets () 函数。</p>\n<p>为什么要丢弃过长输入行中的余下字符。<br>\n这是因为，输入行中多出来的字符会被留在缓冲区中，成为下一次读取语句的输入。<br>\n例如，如果下一条读取语句要读取的是 double 类型的值，就可能导致程序崩溃。丢弃输入行余下的字符保证了读取语句与键盘输入同步。</p>\n<p>s_gets () 函数并不完美，它最严重的缺陷是遇到不合适的输入时毫无反应。它丢弃多余的字符时，既不通知程序也不告知用户。但是，用来替换前面程序示例中的 gets () 足够了。</p>\n<h6 id=\"空字符和空指针\"><a class=\"markdownIt-Anchor\" href=\"#空字符和空指针\">#</a> 空字符和空指针</h6>\n<ul>\n<li>\n<p>空字符 (\\0) 用于标记 C 字符串末尾的字符 对应字符编码为 0 由于其他字符的编码不可能为 0 所以空字符不可能是字符串的一部分</p>\n</li>\n<li>\n<p>空指针 (NULL) 有一个值 该值不会与任何数据的有效地址对应.</p>\n</li>\n<li>\n<p>空指针是整数类型 空指针是指针类型 空字符是一个字符占 1 字节 空指针是一个地址 占 4 字节</p>\n</li>\n</ul>\n<h5 id=\"scanf函数-2\"><a class=\"markdownIt-Anchor\" href=\"#scanf函数-2\">#</a> scanf () 函数</h5>\n<p>前面用 scanf () 和 % s 来读取字符串<br>\n scanf () 和 gets () 以及 fgets () 的区别在于他们如何确定字符串的末尾</p>\n<ul>\n<li>\n<p>scanf () 更像是在 \"获取单词\" 而不是在 \"获取字符串\"</p>\n</li>\n<li>\n<p>如果预留区装得下输入航 gets () 和 fgets () 会读取第一个换行符之前所有的字符</p>\n</li>\n</ul>\n<p>scanf () 有两种方法确定输入结束，但是都是从第一个非空白字符作为字符的开始</p>\n<ul>\n<li>使用 % s 转换说明 以下一个空白字符 (空行 空格 制表符 换行符) 作为字符串的结束 (<strong>空白字符不存储在字符串中</strong>)</li>\n<li>如果指定了字符串的长度 如 %8s 那么 scanf () 将读取 8 个字符 或者读到空白符位置</li>\n</ul>\n<p><a href=\"https://imgtu.com/i/oFcCd0\"><img src=\"https://z3.ax1x.com/2021/11/25/oFcCd0.png\" alt=\"oFcCd0.png\"></a></p>\n<p>scanf () 函数返回一个整数值 该值等于 scanf () 成功读取的项数 或者 EOF (读到文件末尾)</p>\n<blockquote>\n<pre><code>#include &lt;stdio.h&gt;\nint main(void)\n{\n     char name1[11], name2[11];\n     int count;\n\n     printf(\"Please enter 2 names.\\n\");\n     count = scanf(\"%5s %10s\", name1, name2);\n     printf(\"I read the %d names %s and %s.\\n\", count, name1, name2);\n\n     return 0\n}\n</code></pre>\n</blockquote>\n<p>输入示例</p>\n<blockquote>\n<p>Please enter 2 names.<br>\nJesse Jukes<br>\nI read the 2 names Jesse and Jukes.  // 都未超出字段宽度<br>\n Please enter 2 names.<br>\nLiza Applebottham<br>\nI read the 2 names Liza and Applebotth.  // 第二个超出了字段宽度 自动截取了<br>\n Please enter 2 names.<br>\nPortensia Callowit<br>\nI read the 2 names Porte and nsia.   先读取了 5 个字符 (第一次调用 scanf ()) 然后又读取了 4 字符 (第二次调用 scanf () 从上一次调用结束的地方继续读取数据)</p>\n</blockquote>\n<p>根据输入数据的性质 用 scanf () 读取键盘输入的数据 有时并不合适<br>\n scanf () 无法完整地读入书名或者歌曲名 除非这些名称是一个单词<br>\n scanf () 的典型用法：读取并转换混合数据类型为某种标准形式<br>\n scanf () 缺点：输入行过长也会导致数据溢出<br>\n解决方法：在 % s 转换说明中限制字段宽度</p>\n<h4 id=\"字符串输出\"><a class=\"markdownIt-Anchor\" href=\"#字符串输出\">#</a> 字符串输出</h4>\n<p>C 中 3 个用于打印字符串的标准库函数</p>\n<ol>\n<li>puts()</li>\n<li>fputs()</li>\n<li>printf()</li>\n</ol>\n<h5 id=\"puts函数\"><a class=\"markdownIt-Anchor\" href=\"#puts函数\">#</a> puts () 函数</h5>\n<p>puts () 函数会在末尾自动添加一个换行符</p>\n<blockquote>\n<pre><code>#include &lt;stdio.h&gt;\n#define DEF \"I am a #defined string.\"\nint main(void)\n{\n     char str1[80] = \"An array was initialized to me.\";\n     const char * str2 = \"A pointer was initialized to me.\";\n\n     puts(\"I'm an argument to puts().\");\n     puts(DEF);\n     puts(str1);\n     puts(str2);\n     puts(&amp;str1[5]);  //puts后面需要跟的是一个地址 字符串的起始地址\n     puts(str2 + 4);\n\n     return 0;\n}\n</code></pre>\n</blockquote>\n<p>输出如下</p>\n<blockquote>\n<p>I’m an argument to puts().<br>\nI am a #defined string.<br>\nAn array was initialized to me.<br>\nA pointer was initialized to me.<br>\nray was initialized to me.<br>\ninter was initialized to me.</p>\n</blockquote>\n<p>puts 遇到空字符就停止输入 所以必须却要有空字符<br>\n如果缺少空字符他会一直打印内存后面中的内容 直到读到空字符的位置为止</p>\n<h5 id=\"fputs函数\"><a class=\"markdownIt-Anchor\" href=\"#fputs函数\">#</a> fputs () 函数</h5>\n<p>与 puts () 函数的区别如下</p>\n<ul>\n<li>fputs () 的第二个参数指明要写入数据的文件 如果要打印在显示器上 用定义在 stdio.h 中的 stdout (标准输出) 作为该参数</li>\n<li>fputs () 不会在输出的末尾添加换行符 而 puts () 会</li>\n</ul>\n<p>与前面的输入函数关联起来 也就是前面提过的<br>\n<strong> puts () 函数会在待输入字符串末尾添加一个换行符 而 fputs () 不会这样做</strong><br>\n<strong>同样 fgets () 存储时会在末尾自动存储一个换行符 而 gets () 不会这样</strong></p>\n<p>不推荐使用 gets () 因为已经废弃了  学习 gets () 只是以防以后看到 gets () 代码看不懂</p>\n<h5 id=\"printf函数-2\"><a class=\"markdownIt-Anchor\" href=\"#printf函数-2\">#</a> printf () 函数</h5>\n<p>printf () 把字符串的地址作为参数<br>\n printf () 不是那么方便 但是它可以格式化不同的数据类型</p>\n<blockquote>\n<pre><code>printf(\"%s \\n\",string)\nputs(string); 这两个语句的效果是相同的\n</code></pre>\n</blockquote>\n<h4 id=\"自定义输入输出函数\"><a class=\"markdownIt-Anchor\" href=\"#自定义输入输出函数\">#</a> 自定义输入 / 输出函数</h4>\n<p>以下是一个 类似 puts 但是不会就自动添加换行符的函数</p>\n<blockquote>\n<pre><code>#include &lt;stdio.h&gt;\nvoid put1(const char * string)/* 不会改变字符串 */\n{\n     while (*string != '\\0')\n          putchar(*string++);\n}\n</code></pre>\n</blockquote>\n<p>因为从右向左运算 *string++ 中递增是 string 本身而不是递增它所指向的字符</p>\n<p>很多 C 程序员在 whild 中会使用下面的测试条件</p>\n<blockquote>\n<pre><code>while (*string) 若*string是空字符 则为0 循环结束 这种方法风场渐变\n</code></pre>\n</blockquote>\n<p>以下将打印一串字符串 并且 统计打印的字符个数</p>\n<blockquote>\n<pre><code> int put2(const char * string)\n {\n      int count = 0;\n      while (*string)    /* 常规用法 */\n      {\n           putchar(*string++);\n           count++;\n      }\n      putchar('\\n');    /* 不统计换行符 */\n \n      return(count);\n }\n</code></pre>\n</blockquote>\n<p>具体的程序使用</p>\n<blockquote>\n<pre><code>#include &lt;stdio.h&gt;\nvoid put1(const char *);\nint put2(const char *);\n\nint main(void)\n{\n     put1(\"If I'd as much money\");\n     put1(\" as I could spend,\\n\");\n     printf(\"I count %d characters.\\n\",\n          put2(\"I never would cry old chairs to mend.\"));\n\n     return 0;\n}\n\nvoid put1(const char * string)\n{\n     while (*string)  /* 与 *string != '\\0' 相同 */\n          putchar(*string++);\n}\n\nint put2(const char * string)\n{\n     int count = 0;\n     while (*string)\n     {\n          putchar(*string++);\n          count++;\n     }\n     putchar('\\n');\n\n     return(count);\n}\n</code></pre>\n</blockquote>\n<h4 id=\"字符串函数\"><a class=\"markdownIt-Anchor\" href=\"#字符串函数\">#</a> 字符串函数</h4>\n<p>C 库中有多个处理字符串的函数 ANSI C 放在了 string.h 头文件中</p>\n<h5 id=\"strlen-函数\"><a class=\"markdownIt-Anchor\" href=\"#strlen-函数\">#</a> strlen () 函数</h5>\n<p>strlen () 函数用于统计字符串的长度<br>\n以下函数用于缩短字符串的长度</p>\n<blockquote>\n<pre><code>void fit(char *string, unsigned int size)\n{\n     if (strlen(string) &gt; size)\n         string[size] = '\\0';\n}\n</code></pre>\n</blockquote>\n<h5 id=\"strcat函数\"><a class=\"markdownIt-Anchor\" href=\"#strcat函数\">#</a> strcat () 函数</h5>\n<p>strcat () 用于凭借字符串<br>\n函数接受两个字符串作为参数 该函数是把第二个字符串的备份附加在第一个字符串末尾 然后把拼接后形成的新字符串作为第一个字符串 第二个字符串不发生改变<br>\n strcat () 的类型是指向 char 的指针 返回的值是第一个字符串的地址</p>\n<h5 id=\"strncat函数\"><a class=\"markdownIt-Anchor\" href=\"#strncat函数\">#</a> strncat () 函数</h5>\n<p>strcat () 无法检查第一个数组 是否能够容纳第 2 个字符串 如果第一个数组的空间不够大 拼接的时候就会出现问题<br>\n strncat () 的第三个参数制定了最大添加字符数</p>\n<blockquote>\n<pre><code>strncat(bugs,addon,13)\n</code></pre>\n</blockquote>\n<p>在加到第 13 个字符或者空字符的时候就停止<br>\n strncat () 和 gets () 一样也会导致缓冲区溢出 但是并没有废弃</p>\n<h5 id=\"strcmp函数\"><a class=\"markdownIt-Anchor\" href=\"#strcmp函数\">#</a> strcmp () 函数</h5>\n<p>strcmp 用于字符串的比较<br>\n如果两个字符串参数相同 函数就返回 0 否则返回非 0 数<br>\n<strong>注意</strong><br>\n strcmp () 比较的是字符串不是整个数组 即使数组很大 strcmp () 也只会比较数组中存储的字符串 也就是第一个空字符前面的字符串</p>\n<h6 id=\"1strcmp的返回值\"><a class=\"markdownIt-Anchor\" href=\"#1strcmp的返回值\">#</a> 1.strcmp () 的返回值</h6>\n<ul>\n<li>如果第一个字符串在第二个字符串前面 strcmp () 返回一个负数</li>\n<li>如果两个字符串相同 则返回 0</li>\n<li>如果第一个字符串在第二个字符串后面 strcmp () 返回一个正数</li>\n</ul>\n<p>比较过程中 strcmp () 会依次比较每个字符 知道发现第一对不同的字符为止 然后返回相应的值</p>\n<p>strcmp () 与其说是比较字符串 不如说是根据 ASCII 的值 按照<strong>机器排序序列</strong>进行比较</p>\n<p><strong>注意</strong> strcmp () 比较的是字符串而不是字符 也就是说即使要比较单个字符 也应该写成 \"A\" 而不是’A’<br>\n实际上因为 char 类型实际上是 int 类型 所以比较字符时 也不需要使用到 strcmp () 函数</p>\n<h6 id=\"strncmp函数\"><a class=\"markdownIt-Anchor\" href=\"#strncmp函数\">#</a> strncmp () 函数</h6>\n<ul>\n<li>strcmp () 比较字符串中的字符 这一过程会持续到直到发现不同</li>\n<li>strncmp () 在比较两个字符串时 可以限定函数只比较哪几个字符 这样可以用来查找哪个字母 或者开头 结尾 相同的单词</li>\n</ul>\n<blockquote>\n<pre><code>strncmp(\"transform\",\"transparent\",5)\n</code></pre>\n</blockquote>\n<p>此时函数就只会比较前面 5 个字符 并且输出的结果是 0 因为前 5 个字符 trans 相同</p>\n",
            "tags": [
                "C语言"
            ]
        }
    ]
}