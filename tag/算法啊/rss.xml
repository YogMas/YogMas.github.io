<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>S1m • Posts by &#34;算法啊&#34; tag</title>
        <link>http://s1mm.gitee.io/s1mm</link>
        <description>博客记录个人学习笔记,处于不断完善中</description>
        <language>zh-CN</language>
        <pubDate>Sun, 09 Oct 2022 00:00:00 +0800</pubDate>
        <lastBuildDate>Sun, 09 Oct 2022 00:00:00 +0800</lastBuildDate>
        <category>C语言</category>
        <category>Css</category>
        <category>python</category>
        <category>Html</category>
        <category>Git</category>
        <category>java</category>
        <category>操作系统</category>
        <category>Javascript</category>
        <category>icoding答案</category>
        <category>机器学习</category>
        <category>算法啊</category>
        <item>
            <guid isPermalink="true">http://s1mm.gitee.io/s1mm/2022/10/09/suan-fa/</guid>
            <title>算法</title>
            <link>http://s1mm.gitee.io/s1mm/2022/10/09/suan-fa/</link>
            <category>算法啊</category>
            <pubDate>Sun, 09 Oct 2022 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;算法&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#算法&#34;&gt;#&lt;/a&gt; 算法&lt;/h1&gt;
&lt;p&gt;基于 Acwing 算法课&lt;/p&gt;
&lt;h2 id=&#34;算法基础课&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#算法基础课&#34;&gt;#&lt;/a&gt; 算法基础课&lt;/h2&gt;
&lt;h3 id=&#34;基础算法&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#基础算法&#34;&gt;#&lt;/a&gt; 基础算法&lt;/h3&gt;
&lt;p&gt;算法：以空间来换取时间&lt;/p&gt;
&lt;h4 id=&#34;快速排序&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#快速排序&#34;&gt;#&lt;/a&gt; 快速排序&lt;/h4&gt;
&lt;p&gt;快速排序基于分治的思想，选取数&lt;strong&gt; x&lt;/strong&gt; (从数组中任选), 将大于 x 的数放置于数组的左边，小于 x 的数放置于数组的右边&lt;/p&gt;
&lt;p&gt;处理过程采用&lt;strong&gt;双指针&lt;/strong&gt;和&lt;strong&gt;递归&lt;/strong&gt;进行处理&lt;/p&gt;
&lt;p&gt;时间复杂度最快&lt;strong&gt; O (nlogn)&lt;/strong&gt; 最慢&lt;strong&gt; O (n^2)&lt;/strong&gt;  取决于每一次随机选取的数在数组中的大小关系&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;时间复杂度最快&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/java%E5%BF%AB%E6%8E%92%E6%9C%80%E5%BF%AB.png&#34; alt=&#34;快排最快&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间复杂度最慢&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/java195AF8FC790A2FAFE29FCFC35CCD6B87.png&#34; alt=&#34;时间复杂度最慢&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;line-numbers language-c++&#34; data-language=&#34;c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;//快速排序基本模板
void quick_sort(int q[],int l,int r)
{
    if(l &amp;gt;= r) return;
    int x = q[l]; //int x = q[r], int x = q[l+r &amp;gt;&amp;gt;1] 都可以 因为是随机选择
    //这里有个边界问题, 如果后面以j为边界,这里就不能为q[r]  
    //如果后面以i为边界,这里就不能为q[l];
    int i = l -1,j = r + 1; // 先- 先+ 因为后面do while循环 会先进行-- 和++
    while(i &amp;lt; j)
    {
        //比较条件没有等号
        do i++;while(q[i] &amp;lt;x);
        do j--;while(q[j] &amp;gt;x);
        if(i &amp;lt; j) swap(q[i],q[j]);
    }
    quick_sort(q,l,j);
    quick_sort(q,j+1,r);
}&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;快速查找&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#快速查找&#34;&gt;#&lt;/a&gt; 快速 / 查找&lt;/h5&gt;
&lt;p&gt;快速查找采用的是&lt;strong&gt;快速排序 + 二分&lt;/strong&gt;的思想，在排序过程中，如果可以确定值在两半的哪一半，就继续去查找那一半，另外一半就不需要查找了，这样&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最快的时间复杂度是 O (n);&lt;/li&gt;
&lt;li&gt;最慢仍然是 O (n^2);&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;line-numbers language-c++&#34; data-language=&#34;c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;//查找第k小的数
int quick_search(int q[],int l,int r,int k)
{
    if(l &amp;gt;= r) return q[l];
    int x = q[l + r &amp;gt;&amp;gt;1],i = l - 1, j = r +1;
    while(i&amp;lt;j)
    {
        do i++;while(q[i] &amp;lt; x);
        do j--;while(q[j] &amp;gt; x);
        if(i &amp;lt; j) swap(q[i],q[j]);
    }
    if(k &amp;lt; j- l +1) return quick_search(q,l,j,k);
    else return quick_search(q,j+1,r,k - (j -l +1));
}&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;归并排序&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#归并排序&#34;&gt;#&lt;/a&gt; 归并排序&lt;/h4&gt;
&lt;p&gt;经典采取分治的思想，时间复杂度为 O (nlogn)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：时间复杂度为 O (nlogn);&lt;/li&gt;
&lt;li&gt;缺点：使用了多余的空间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过不断递归，将整个数组无限二等分，直到最后分成单个，在通过比较，将分割后的数组合并起来.&lt;/p&gt;
&lt;p&gt;时间复杂度证明可以参照上面的&lt;strong&gt;快排最优&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-c++&#34; data-language=&#34;c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;//归并排序基本模板
void merge_sort(int q[],int l,int r)
{
    if(l &amp;gt;= r) return;
    int mid = l + r &amp;gt;&amp;gt; 1;
    
    //递归不断二等分
    merge_sort(q,l,mid);
    merge_sort(q,mid + 1,r);
    
    //进行数组合并
    int i =l,j = mid +1,k =0;
    while(i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= r)
    {
        if(q[i] &amp;lt;= q[j]) tmp[k++] =q[i++];                //tmp数组 用空间换时间 临时存储
            else tmp[k++] = q[j++];
    }
    while(i &amp;lt;= mid) tmp[k++] = q[i++];
    while(j &amp;lt;= r) tmp[k++] = q[j++];	
    //将tmp排序好的数组重新赋值到原本的数组中
    for(int i = l,j = 0;i &amp;lt;= r;i++,j++)
    	q[i] = tmp[j];
}&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;二分查找&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#二分查找&#34;&gt;#&lt;/a&gt; 二分查找&lt;/h4&gt;
&lt;h5 id=&#34;整数二分&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#整数二分&#34;&gt;#&lt;/a&gt; 整数二分&lt;/h5&gt;
&lt;p&gt;二分也是采用&lt;strong&gt;分治&lt;/strong&gt;的方法，不断将一个&lt;strong&gt;有序&lt;/strong&gt;数组分成两半，然后判断满足条件的数 (&lt;strong&gt;要查找的数&lt;/strong&gt;) 是在左边还是右边&lt;/p&gt;
&lt;p&gt;二分存在&lt;strong&gt;边界问题&lt;/strong&gt;，所以记忆一个模板可以&lt;strong&gt;有效避免边界问题&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-C++&#34; data-language=&#34;C++&#34;&gt;&lt;code class=&#34;language-C++&#34;&gt;//当l = r 的时候停止，此时无论是取l 或者 取 r 输出都可以
// 模板1
void find(int q[],int l,int r)
{
    while(l &amp;lt; r)
    {
       	int mid = l + r &amp;gt;&amp;gt;1;
        if(check(mid)) r = mid;  //check(mid)表示是否满足条件
        else l = mid + 1;
    }
}

//模板2
void find(int q[],int l,int r)
{
    while(l &amp;lt; r)
    {
       	int mid = l + r + 1 &amp;gt;&amp;gt; 1
        if(check(mid)) l = mid;  //check(mid)表示中心点是否满足条件
        else r = mid - 1;
    }
}

//通过check函数来判断使用哪个二分
//注意对mid的使用 是导致边界问题的原因&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;部分问题，查找一个数的值，但数组中有&lt;strong&gt;多个一样的值都满足条件&lt;/strong&gt;，如果确定搜到的答案 是所有满足条件的答案里面&lt;strong&gt;最左边的还是最右边的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个时候需要根据模板 模拟一下，&lt;strong&gt; 当条件满足的时候&lt;/strong&gt;，二分是在往左边查找，还是往右边查找.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;往右边查找 最后得到的就是最右边的值&lt;/li&gt;
&lt;li&gt;往左边不断查找，最后得到的就是最左边的值&lt;/li&gt;
&lt;li&gt;我们可以通过改变 check () 判断函数和模板的切换 来人为控制往左边查找和往右边查找的过程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;边界&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;选择模板为了避免边界问题，灵活记忆&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果满足条件的时候，需要 &lt;code&gt;l = mid&lt;/code&gt; , 这个时候求 mid 就是 + 1&lt;/li&gt;
&lt;li&gt;如果满足条件的时候，需要 &lt;code&gt;r = mid&lt;/code&gt; , 这个时候求 mid 就不需要 + 1, 就是普通的 (l + r) / 2;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;小数二分&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#小数二分&#34;&gt;#&lt;/a&gt; 小数二分&lt;/h5&gt;
&lt;p&gt;因为小数二分&lt;strong&gt;不存在这个边界问题&lt;/strong&gt;，就非常简单&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-c++&#34; data-language=&#34;c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;void find(int q[],int l,int r)
{
    while(l &amp;lt; r)
    {
       	int mid = l + r &amp;gt;&amp;gt;1;
        if(check(mid)) r = mid;  //check(mid)表示是否满足条件
        else l = mid;
    }
}&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;高精度&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#高精度&#34;&gt;#&lt;/a&gt; 高精度&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;C++&lt;strong&gt; 中对&lt;/strong&gt;大数存储不支持&lt;/strong&gt;，所以需要用&lt;strong&gt;数组来存储&lt;/strong&gt;大数，然后通过小时候学习的&lt;strong&gt;加法竖式等等&lt;/strong&gt;的原理对数组进行处理，从而达到大数计算的目的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：因为&lt;strong&gt;进位&lt;/strong&gt;的问题，所以在&lt;strong&gt;加减乘三个运算&lt;/strong&gt;中反着输入数组，最后再将数组颠倒&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为存在&lt;strong&gt;借位&lt;/strong&gt;问题，减法的最后可能因为被借了一位被判断为 0，所以需要去除这个 0, 去除这个 0 的时候要考虑特例，这个 0 就是答案，所以还要判断是不是只有 1 个 0, 只有满足不止一位数，且最后一位是 0, 才去除这个 0&lt;/li&gt;
&lt;li&gt;同样减法也可能存在&lt;strong&gt;前置 0&lt;/strong&gt;, 需要去除&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;高精度加法&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#高精度加法&#34;&gt;#&lt;/a&gt; 高精度加法&lt;/h5&gt;
&lt;pre class=&#34;line-numbers language-c++&#34; data-language=&#34;c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;//进位问题 输入的数组都是反向存的
vector&amp;lt;int&amp;gt; add(vector&amp;lt;int&amp;gt; &amp;amp;a,vector&amp;lt;int&amp;gt; &amp;amp;b)
{
    vector&amp;lt;int&amp;gt; c;
    for(int i = 0 ,t = 0; t ||i &amp;lt; a.size() || i &amp;lt;b.size();i++)
    {
        if(i &amp;lt;a.size()) t += a[i];
        if(i &amp;lt; b.size()) t += b[i];
        c.push_back(t % 10);
        t /= 10;
    }
    reverse(c.begin(),c.end());
    return c;
}&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;高精度减法&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#高精度减法&#34;&gt;#&lt;/a&gt; 高精度减法&lt;/h5&gt;
&lt;pre class=&#34;line-numbers language-c++&#34; data-language=&#34;c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;//可以在外面先写个函数 保证输入减函数内部的时候一定是 a &amp;gt;= b的
bool cmp(vector&amp;lt;int&amp;gt; &amp;amp;a,vector&amp;lt;int&amp;gt; &amp;amp;b) //a &amp;gt;= b 则返回true 否则返回false
{
    if(a.size()!= b.size()) return a.size() &amp;gt;b.size(); //长度不一样的时候,显然长度大的更大
    else
    {
        for(int i = 0 ; i &amp;lt; a.size();i++)
        {
            if(a[i] != b[i]) return a[i] &amp;gt;= b[i]; //当某个位置出现不一样的时候,该位置大的更大
        }
    }
    return true; //长度相同 每个位置也相同 说明两个大数相等返回true
}
//默认输入的时候a &amp;gt;= b;
vector&amp;lt;int&amp;gt; sub(vector&amp;lt;int&amp;gt; &amp;amp;a,vector&amp;lt;int&amp;gt; &amp;amp;b)
{
    if(!cpm(a,b)) return sub(b,a); //如果a &amp;lt; b 就进行b - a的操作
    vector&amp;lt;int&amp;gt; c;
    for(int i = 0, t = 0;i &amp;lt; a.size();i++)
    {
        t += a[i];
        if(i &amp;lt;b.size()) t = t - b[i];
        c.push_back((t +10) % 10); //保证插入的是正数
        if(t &amp;lt; 0) t = -1;
        else t = 0;
    }
    while(c.size() &amp;gt;1 &amp;amp;&amp;amp; c.back() == 0) c.pop_back(); //删除前置0,如果最后一个为0 并且不只有1个0(正确答案)，就将最后一位山区
    reverse(c.begin(),c.end(0));
    return c;
}&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;高精度乘法&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#高精度乘法&#34;&gt;#&lt;/a&gt; 高精度乘法&lt;/h5&gt;
&lt;p&gt;依据乘法&lt;strong&gt;竖式&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-c++&#34; data-language=&#34;c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;//高精度乘法一般是一个大数和一个小数相乘,不会出现大数乘大数
vector&amp;lt;int&amp;gt; mul(vector&amp;lt;int&amp;gt; &amp;amp;a,int b)
{
    vector&amp;lt;int&amp;gt; c;
    for(int i = 0,t = 0 ; t || i &amp;lt;a.size();i++)
    {
        if(i&amp;lt; a.size())t += a[i] * b;
        c.push_back(t % 10);
        t /= 10;
    }
    reverse(c.begin(),c.end())
    return c;
}&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;高精度除法&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#高精度除法&#34;&gt;#&lt;/a&gt; 高精度除法&lt;/h5&gt;
&lt;p&gt;高精度除法，不存在&lt;strong&gt;借位和进位&lt;/strong&gt;的问题，所以按照原来的数组存储，但是最后需要&lt;strong&gt;翻转两次&lt;/strong&gt;来&lt;strong&gt;去掉前缀 0&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-c++&#34; data-language=&#34;c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;//高精度除法,一般也为一个大数和一个小数相除
vector&amp;lt;int&amp;gt; div(vector&amp;lt;int&amp;gt; a,int b,int &amp;amp;r) // r用来存储余数 默认为0
{
    vector&amp;lt;int&amp;gt; c;
    for(int i = 0,r = 0; i&amp;lt; a.size();i++)
    {
        r = r * 10 + a[i];
        c.push_back(r / b); //不够除的时候 自然传入的是0 所以也会有前缀0的问题
        r = r % b; //取余数
    }
    reverse(c.begin(),c.end());
    while(c.size() &amp;gt;1 &amp;amp;&amp;amp; c.back() == 0) a.pop_back();
    reverse(c.begin(),c.end());
    return c;
}&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;数学&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#数学&#34;&gt;#&lt;/a&gt; 数学&lt;/h3&gt;
&lt;h4 id=&#34;质数&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#质数&#34;&gt;#&lt;/a&gt; 质数&lt;/h4&gt;
&lt;h5 id=&#34;判断质因数&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#判断质因数&#34;&gt;#&lt;/a&gt; 判断质因数&lt;/h5&gt;
&lt;p&gt;如果一个数除了表示成 1 和他自身的乘积外 还能表示成另外两个数的乘积  这个数就不是质因数&lt;/p&gt;
&lt;p&gt;反之一个数如果只能表示成 1 和他自身的乘积，那么这个数是质因数&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-c++&#34; data-language=&#34;c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;bool is_prime(int x)
{
	for(int i = 2 ; i &amp;lt;= x /i ;i++) //做了优化  将O(n)时间复杂度降到O(sqrt(n))  这里x/i不写成sqrt(x) sqrt()函数运行较慢 这样每次比较的时候,都会调用sqrt()函数 会大大提高时间
    {
        if(x % i == 0) return false
    }
    return true;
}&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;优化&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#优化&#34;&gt;#&lt;/a&gt; 优化&lt;/h6&gt;
&lt;p&gt;一个数 表示成两个数的乘积 显然这两个数是&lt;strong&gt;一大一小&lt;/strong&gt;的&lt;/p&gt;
&lt;p&gt;如果 x 可以表示成 a *  b 的话  假设 a &amp;lt; b 那么显然 &lt;strong&gt;a &amp;lt; x / a&lt;/strong&gt; 即  &lt;strong&gt;a &amp;lt; sqrt(x)&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&#34;分解质因数&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#分解质因数&#34;&gt;#&lt;/a&gt; 分解质因数&lt;/h5&gt;
&lt;p&gt;例如 12 = 2 * 2 * 3 一个合数可以被分解成若干个质数的乘积&lt;/p&gt;
&lt;p&gt;分解质因数就是找出一个合数 他所可以分解成的所有质因数&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-c++&#34; data-language=&#34;c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;void get_primes(int x)
{
    for(int i = 2; i &amp;lt;= x/ i;i++ )
    {
        if(x % i == 0)
        {
            int s = 0; 
            while(x % i == 0) //将一个质数 判断到底
            {
                x = x / i;
                s++;
            }
            cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; s;
        }
    }
    if(x &amp;gt; x / i) cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt;endl; //优化 数据单独处理
}&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;优化-2&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#优化-2&#34;&gt;#&lt;/a&gt; 优化&lt;/h6&gt;
&lt;p&gt;分解质因数中 最多只存在一个质数大于&lt;strong&gt; sqrt (x)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以将最后一个数 脱离出来&lt;strong&gt;单独处理&lt;/strong&gt; 可以将时间复杂度 进行一个降低&lt;/p&gt;
&lt;p&gt;前半部分采用遍历的方式 最后一个数据单独处理&lt;/p&gt;
&lt;h5 id=&#34;筛质数&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#筛质数&#34;&gt;#&lt;/a&gt; 筛质数&lt;/h5&gt;
&lt;p&gt;给出一个数 x 把小于等于他的&lt;strong&gt;质数&lt;/strong&gt;全部筛出来&lt;/p&gt;
&lt;h6 id=&#34;埃式筛法onloglogn&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#埃式筛法onloglogn&#34;&gt;#&lt;/a&gt; 埃式筛法 O (nloglogn)&lt;/h6&gt;
&lt;p&gt;从左往右遍历，找到一个质数的同时，就把 &amp;lt;= n 范围内 他的所有倍数打上标签 (这个数不是质数)  遍历过程中没有打上标签的就是质数&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-c++&#34; data-language=&#34;c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;int primes[N]; // 存储所有质数
bool st[N]; //这个数是否被筛过了
int get_primes(int n)
{
    int cnt = 0 ;
    for(int i = 2 ; i &amp;lt;= n;i++)
    {
        if(st[i]) continue; //被筛过了 就跳过
        prime[cnt++] = i;
        for(int j = i + i; j &amp;lt;= n; j += i)   //这里似乎 j 可以直接从i * i 开始 没理解
        {
            st[j] = true;
        }
    }
    return cnt;
}&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;欧式筛法线性筛法-on&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#欧式筛法线性筛法-on&#34;&gt;#&lt;/a&gt; 欧式筛法 (线性筛法) O (n)&lt;/h6&gt;
&lt;p&gt;时间复杂度是线性的&lt;/p&gt;
&lt;p&gt;埃式筛法 筛查过程中存在大量的重复筛的问题 比如 2  * 2 = 4 已经被筛过了 但是在到 4 的同时还会被再筛查一遍&lt;/p&gt;
&lt;p&gt;所以欧式筛法采用的一个优化的方法 就是筛一个数的时候 只通过最小质因数来筛，这样每个数都只会被筛一遍&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-c++&#34; data-language=&#34;c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;bool st[N];
int primes[N];
int get_primes(int n)
{
    int cnt = 0;
    for(int i = 2 ; i &amp;lt;= n;i++)
    {
        if(!st[i]) prime[cnt++] = i;
        for(int j = 0 ; j &amp;lt; cnt &amp;amp;&amp;amp; primes[j] &amp;lt;= n \ i;j++)
        {
            st[i * primes[j]] = true;
            if(i % primes[j] == 0) break; //优化所在 如果i是primes[j]的倍数 显然后面 primes[j+1]就不会是最小的质因数了 就break
        }
    }
    return cnt;
}&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;约数&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#约数&#34;&gt;#&lt;/a&gt; 约数&lt;/h4&gt;
&lt;h5 id=&#34;试除法求约数&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#试除法求约数&#34;&gt;#&lt;/a&gt; 试除法求约数&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;与前面判断质因数相同&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&#34;约数个数&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#约数个数&#34;&gt;#&lt;/a&gt; 约数个数&lt;/h5&gt;
&lt;p&gt;对于一个大于 1 正整数 n 可以&lt;a href=&#34;https://baike.baidu.com/item/%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0?fromModule=lemma_inlink&#34;&gt;分解质因数&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/javaafef3bf76b93359a0067ea80e57bca0e.svg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;则 n 的&lt;a href=&#34;https://baike.baidu.com/item/%E6%AD%A3%E7%BA%A6%E6%95%B0/882466?fromModule=lemma_inlink&#34;&gt;正约数&lt;/a&gt;的个数就是&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/java21c38a03ef417a187c0a202b37ce59c4.svg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;其中 a1、a2、a3…ak 是 p1、p2、p3，…pk 的指数。首先同上，n 可以&lt;a href=&#34;https://baike.baidu.com/item/%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0/2253749?fromModule=lemma_inlink&#34;&gt;分解质因数&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bkimg.cdn.bcebos.com/formula/7acc0c37dfea06c873d081dba44b2164.svg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;证明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/java%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%AE%9A%E7%90%86%E8%AF%81%E6%98%8E.png&#34; alt=&#34;约数个数定理证明&#34;&gt;&lt;/p&gt;
&lt;p&gt;所以进行程序书写的时候，可以先用&lt;strong&gt;质数中的分解质因数&lt;/strong&gt;的方法，找到所有的质数和他们的指数，然后进行计算&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-c++&#34; data-language=&#34;c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;unordered_map&amp;lt;int,int&amp;gt;prime;
int getnum(int x)
{
    for(int i = 0 ; i &amp;lt;= n/i;i++) //筛质数
    {
        while(x % i == 0)
        {
            x /= i;
            prime[i]++; //存储指数
        }
    }   
    if(x &amp;gt;1) prime[x]++; //现在已经将所有的质数和他们的指数筛出来了
    int res = 1;
    for(auto p:prime)
    {
        res *= p.second +1;
    }
}&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;约数之和&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#约数之和&#34;&gt;#&lt;/a&gt; 约数之和&lt;/h5&gt;
&lt;p&gt;同样利用公式&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/java%E7%BA%A6%E6%95%B0%E5%92%8C%E5%AE%9A%E7%90%86.png&#34; alt=&#34;约数和定理&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;证明&lt;/strong&gt;：进行乘法分配律将括号打开，得到的就是所有因数的和&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-c++&#34; data-language=&#34;c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;unordered_map&amp;lt;int,int&amp;gt;prime;
int getallnum(int x)
{
    for(int i = 0 ; i &amp;lt;= n/i;i++) //筛质数
    {
        while(x % i == 0)
        {
            x /= i;
            prime[i]++; //存储指数
        }
    }
    int res = 1;
    for(auto p : prime)
    {
        int ans = 0;
        int x = p.first;
        int y = p.second;
        while(y--)  ans = ans * p + 1;
        res *= ans;
    }
    return res;
}&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;最大公约数&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#最大公约数&#34;&gt;#&lt;/a&gt; 最大公约数&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;(a,b) 的最大公约数等于（b,a % b）的最大公约数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://s1mimg.oss-cn-chengdu.aliyuncs.com/img/java%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E5%8E%9F%E7%90%86%E8%AF%81%E6%98%8E.png&#34; alt=&#34;辗转相除原理证明&#34;&gt;&lt;/p&gt;
&lt;p&gt;通过这个式子可以利用递归，不断减小，直到 a% b 等于 0, 此时最大公约数就找到了&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-c++&#34; data-language=&#34;c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;int gck(int a,int b)
{
  	return b?gck(b,a%b):a;
}&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
    </channel>
</rss>
