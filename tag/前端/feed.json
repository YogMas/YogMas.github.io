{
    "version": "https://jsonfeed.org/version/1",
    "title": "Hexo • All posts by \"前端\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2021/11/06/html-shang/",
            "url": "http://example.com/2021/11/06/html-shang/",
            "title": "Html-first",
            "date_published": "2021-11-05T16:00:00.000Z",
            "content_html": "<h1 id=\"html上\"><a class=\"markdownIt-Anchor\" href=\"#html上\">#</a> Html (上)</h1>\n<h3 id=\"the-article-from-yogmas-also-sam\"><a class=\"markdownIt-Anchor\" href=\"#the-article-from-yogmas-also-sam\">#</a> the article from yogmas also sam</h3>\n<h4 id=\"1基本架构\"><a class=\"markdownIt-Anchor\" href=\"#1基本架构\">#</a> 1. 基本架构</h4>\n<blockquote>\n<pre><code>&lt;html&gt; \n&lt;head&gt;&lt;/head&gt;\n&lt;body&gt;&lt;/body&gt;\n&lt;/html&gt; \n</code></pre>\n</blockquote>\n<h4 id=\"2html标签\"><a class=\"markdownIt-Anchor\" href=\"#2html标签\">#</a> 2.html 标签</h4>\n<h6 id=\"标题标签\"><a class=\"markdownIt-Anchor\" href=\"#标题标签\">#</a> 标题标签</h6>\n<blockquote>\n<pre><code>&lt;h1&gt;&lt;/h1&gt;   ……  &lt;h6&gt;&lt;/h6&gt;\n</code></pre>\n</blockquote>\n<p>一共六级标题，文字加粗，由大到小依次减小。<br>\n<strong>大多数标签都是成对存在的，只有少数例如 br 的单标签</strong></p>\n<h6 id=\"段落和换行标签\"><a class=\"markdownIt-Anchor\" href=\"#段落和换行标签\">#</a> 段落和换行标签</h6>\n<blockquote>\n<pre><code>&lt;p&gt;&lt;/p&gt;\n&lt;/br&gt;\n</code></pre>\n</blockquote>\n<p>p 标签会自动换行，不用添加 br</p>\n<h6 id=\"文本格式化标签\"><a class=\"markdownIt-Anchor\" href=\"#文本格式化标签\">#</a> 文本格式化标签</h6>\n<blockquote>\n<pre><code>&lt;strong&gt;加粗&lt;/strong&gt; 或者 &lt;b&gt;加粗&lt;/b&gt;\n&lt;em&gt;倾斜&lt;/em&gt; 或者 &lt;i&gt;倾斜&lt;/i&gt;\n&lt;del&gt;删除线&lt;/del&gt; 或者 &lt;s&gt;删除线&lt;/s&gt;\n&lt;ins&gt;下划线&lt;/ins&gt; 或者 &lt;u&gt;下划线&lt;/u&gt;\n</code></pre>\n</blockquote>\n<h6 id=\"div和span标签\"><a class=\"markdownIt-Anchor\" href=\"#div和span标签\">#</a> div 和 span 标签</h6>\n<blockquote>\n<pre><code>&lt;span&gt;&lt;/span&gt;\n</code></pre>\n</blockquote>\n<p>形象来说 div 是一个大盒子，span 通常是用来放在大盒子里面的小盒子（后期 div 在页面构造中非常常用)</p>\n<h6 id=\"图像标签\"><a class=\"markdownIt-Anchor\" href=\"#图像标签\">#</a> 图像标签</h6>\n<blockquote>\n<pre><code>&lt;img src=\"路径\" alt=\"图片不显示时显示出来的\" \ntitle=\"鼠标放在图片上面显示出来的文字\" \nwidth=\"\" height=\"\" border=\"\"&gt;\n</code></pre>\n</blockquote>\n<p>在后期使用的 width,height,border, 都会放入<strong> css</strong> 中来运行使用不会单独列入 img 中<br>\n图像标签的路径<br>\n 1. 同一级路径<br>\n eg:(img.jpg)<br>\n 2. 下一级路径<br>\n eg:(images/img.jpg)<br>\n 3. 绝对路径<br>\n eg:(C:\\Users\\apple\\Desktop\\ 前端基础第一天 - HTML\\ 案例 \\img.jpg)<br>\neg：(<a href=\"http://www.itcast.cn/2018czgw/images/logo.png\">http://www.itcast.cn/2018czgw/images/logo.png</a>)<br>\n<img src=\"images/2.png\" alt=\"这是图片\"></p>\n<h6 id=\"超链接标签\"><a class=\"markdownIt-Anchor\" href=\"#超链接标签\">#</a> 超链接标签</h6>\n<blockquote>\n<pre><code>&lt;a href=\"链接\"&gt;LOL&lt;/a&gt;\n</code></pre>\n<p>LOL 可以以图片文字等等代替，点击就可以跳转到 href 所在的链接</p>\n</blockquote>\n<p>可以添加的元素：target=“X”<br>\nX 包括_self (覆盖当前页面)<br>\n 和_blank 重新启动新的页面<br>\n链接分类<br>\n 1. 内部链接：存放在你网站前端的链接也就是你写前端时电脑里面的链接<br>\n 2. 外部链接：例如 http 这类的其他网站的链接<br>\n 3. 空链接：当你还没有链接可以填时，留出空位用 #代替<br>\n 4. 下载链接：通常是以.zip 结尾的压缩包<br>\n<img src=\"images/1.png\" alt=\"这是图片\"></p>\n<h6 id=\"锚点定位\"><a class=\"markdownIt-Anchor\" href=\"#锚点定位\">#</a> 锚点定位</h6>\n<p>由两个相互呼应的标签组成<br>\n可以从页面的一个地方跳转到当前页面的另外一个地方</p>\n<blockquote>\n<pre><code>&lt;a href=\"#ID\"&gt;&lt;/a&gt;\n&lt;h3 id=\"ID\"&gt;\n</code></pre>\n</blockquote>\n<p>ID 可以写成任何你定义的名称<br>\n h3 并不是固定的，可以换成任意标签<br>\n当你点击 a 中携带的元素或标签时你将会跳转到拥有 id=“” 且和 a 相同 id 的标签这</p>\n<h6 id=\"注释标签和特殊字符\"><a class=\"markdownIt-Anchor\" href=\"#注释标签和特殊字符\">#</a> 注释标签和特殊字符</h6>\n<blockquote>\n<pre><code>&lt;!-- 注释内容 --&gt; \n&lt;用&amp;lt  &gt;用&amp;gt；(由于&lt;&gt;符号在html中的特殊性)\n</code></pre>\n</blockquote>\n<p>特殊内容可以用 ctrl+l 快速注释</p>\n",
            "tags": [
                "前端"
            ]
        },
        {
            "id": "http://example.com/2021/11/06/html-xia/",
            "url": "http://example.com/2021/11/06/html-xia/",
            "title": "Html-second",
            "date_published": "2021-11-05T16:00:00.000Z",
            "content_html": "<p>。</p>\n<h1 id=\"html下\"><a class=\"markdownIt-Anchor\" href=\"#html下\">#</a> Html (下)</h1>\n<h3 id=\"the-article-from-yogmas-also-sam\"><a class=\"markdownIt-Anchor\" href=\"#the-article-from-yogmas-also-sam\">#</a> the article from yogmas also sam</h3>\n<h4 id=\"1表格\"><a class=\"markdownIt-Anchor\" href=\"#1表格\">#</a> 1. 表格</h4>\n<h6 id=\"表格基本语法\"><a class=\"markdownIt-Anchor\" href=\"#表格基本语法\">#</a> 表格基本语法</h6>\n<blockquote>\n<pre><code>&lt;table&gt;\n  &lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;/tr&gt;\n  &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;\n&lt;/table&gt;\n</code></pre>\n</blockquote>\n<h6 id=\"表头单元格标签\"><a class=\"markdownIt-Anchor\" href=\"#表头单元格标签\">#</a> 表头单元格标签</h6>\n<blockquote>\n<p>align=\"\"<br>\nborder=\"\"<br>\ncellpadding=\"\"<br>\ncellspacing=\"\"<br>\nwidth=\"\"<br>\nheight=\"\"<br>\n<strong> 这些标签要写到 table 里面去</strong></p>\n</blockquote>\n<p>align: 表格中的文字所处的文字 eg.center 就是未于中间类似的还有 left,right<br>\nborder：表示表格边框的大小 0 表示没有 <strong>此属性的参数值是数字</strong><br>\n cellpadding：代表单元格边框到内容之间的距离（留白）<br>\ncellspacing：用来指定表格各单元格之间的空隙。<strong>此属性的参数值是数字</strong>，表示单元格间隙所占的像素点数。<br>\n同样 width,height 已经介绍过了 ，大多数时候都会用<strong> CSS</strong> 来写</p>\n<h6 id=\"合并单元格\"><a class=\"markdownIt-Anchor\" href=\"#合并单元格\">#</a> 合并单元格</h6>\n<blockquote>\n<p>rowspan=“合并单元格数目”<br>\ncolspan=“合并单元格数目”</p>\n</blockquote>\n<p>rowspan: 合并行 (也就是将一列上的各行合并)<br>\n colspan: 合并列 (也就是将一行上的各列合并)<br>\n 合并准则：如果 rowspan 就在最上面的表格的标签里面加上 rowspan=\"合并数目\" 并且删除已经被合并的表格<br>\n colspan 同理，注意 colspan 加在最左边的表格标签<br>\n eg.</p>\n<blockquote>\n<pre><code>  &lt;tr&gt;\n     &lt;td&gt;&lt;/td&gt;\n      &lt;td colspan=\"2\"&gt;&lt;/td&gt;\n\n  &lt;/tr&gt;\n</code></pre>\n</blockquote>\n<p>表示合并一行上的 2 列 第三列删除 colspan 写在第二列的 td 表格标签内</p>\n<h4 id=\"2列表\"><a class=\"markdownIt-Anchor\" href=\"#2列表\">#</a> 2. 列表</h4>\n<h6 id=\"无序列表\"><a class=\"markdownIt-Anchor\" href=\"#无序列表\">#</a> 无序列表</h6>\n<blockquote>\n<pre><code>&lt;ul&gt;\n  &lt;li&gt;&lt;/li&gt;\n    …………\n  &lt;li&gt;&lt;/li&gt;\n  &lt;li&gt;&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n</blockquote>\n<p>其中的 li 标签各位根据需要而定<br>\n ul:unorderlist<br>\nli:list</p>\n<h6 id=\"有序列表\"><a class=\"markdownIt-Anchor\" href=\"#有序列表\">#</a> 有序列表</h6>\n<blockquote>\n<pre><code>&lt;ol&gt;\n  &lt;li&gt;&lt;/li&gt;\n    …………\n  &lt;li&gt;&lt;/li&gt;\n&lt;/ol&gt;\n</code></pre>\n</blockquote>\n<p>ol:orderlist<br>\nli:list</p>\n<h6 id=\"自定义列表\"><a class=\"markdownIt-Anchor\" href=\"#自定义列表\">#</a> 自定义列表</h6>\n<blockquote>\n<pre><code> &lt;dl&gt;\n   &lt;dt&gt;&lt;/dt&gt;顶部总标签\n   &lt;dd&gt;&lt;/dd&gt;\n   &lt;dt&gt;&lt;/dt&gt;\n   &lt;dd&gt;&lt;/dd\n &lt;/dl&gt;\n 一个&lt;dt&gt;和&lt;/dt&gt;标签出现代表一列\n 直到下一个&lt;dt&gt;和&lt;/dt&gt;出现才换列\n</code></pre>\n</blockquote>\n<h4 id=\"3表单\"><a class=\"markdownIt-Anchor\" href=\"#3表单\">#</a> 3. 表单</h4>\n<h6 id=\"表单域\"><a class=\"markdownIt-Anchor\" href=\"#表单域\">#</a> 表单域</h6>\n<blockquote>\n<pre><code>&lt;form action=\"\" method=\"\" name=\"\"&gt;\n&lt;/form&gt;\n</code></pre>\n</blockquote>\n<p>表单域需要与后端结合使用只是接下来的一系列需要传输数据到后端的都需要写到表单域内<br>\n附：此时作者还不知道表单域的 action 等标签充当的角色和用处</p>\n<h6 id=\"input表单元素\"><a class=\"markdownIt-Anchor\" href=\"#input表单元素\">#</a> input 表单元素</h6>\n<blockquote>\n<pre><code>&lt;input type=\"\" value=\"\" name=\"\" &gt;\n</code></pre>\n</blockquote>\n<p><img src=\"images/26.png\" alt=\"photo\"><br>\ntype 里面可以填写的元素<br>\n text: 文本框，用户可以输入任何文字，但可以用 maxlength 等来加以限定<br>\n password：密码框，可以对你输入的数字进行保密 此时显示 *******<br>\nradio: 单选按钮</p>\n<blockquote>\n<p>将两个 input+radio 元素的标签 name 设置成相同 才可以进行单选 具体下面看图</p>\n</blockquote>\n<p>checkbox: 复选框，可以进行多个选择<br>\n submit: 提交按钮，点击可以将数据提交给后端<br>\n reset: 重新填写<br>\n button: 点击  例如：获取短信验证码需要使用</p>\n<p>与 type 同等级的元素作用<br>\n value：提前显示在文本框内的文字<br>\n name：传送给后端时的数据名称，radio 只有 name 相同才能单选<br>\n<img src=\"imges/../images/3.png\" alt=\"photo\"></p>\n<h6 id=\"label标签\"><a class=\"markdownIt-Anchor\" href=\"#label标签\">#</a> label 标签</h6>\n<p>点击添加了 label 标签的元素等于点击 label 标签的输出端</p>\n<blockquote>\n<pre><code>&lt;label for=\"XXX\"&gt; &lt;/label&gt;\n&lt;input type=\"\" id=\"XXX\"&gt;\n</code></pre>\n</blockquote>\n<p>并不一定要是 input 只是在 input 等填写数据中较为广泛地使用，xxx 可以换成任何自己命名的单词字母等<br>\n for 和 id 中填写的必须相同</p>\n<h6 id=\"select下拉表单\"><a class=\"markdownIt-Anchor\" href=\"#select下拉表单\">#</a> select 下拉表单</h6>\n<blockquote>\n<pre><code>&lt;select&gt;\n&lt;option&gt;&lt;/option&gt;\n&lt;option selected=\"selected\"&gt; &lt;/potion&gt;\n&lt;/select&gt;\n</code></pre>\n</blockquote>\n<p>option 标签中间填写下拉菜单中的文字等<br>\n添加了 selected 元素的表示 未下拉时显示在表面的选项</p>\n<h6 id=\"textarea文本域\"><a class=\"markdownIt-Anchor\" href=\"#textarea文本域\">#</a> textarea 文本域</h6>\n<blockquote>\n<pre><code>&lt;textarea cols=\"\" rows=\"\"&gt;\n&lt;/textarea&gt;\n</code></pre>\n</blockquote>\n<p>文本域通常很大所以用 cols 和 rows 来进行限定<br>\n cols 限定一行的字数 rows 限定行数<br>\n在后期的学习中可以用<strong> css</strong> 将文本域的右下角拉伸和上下滑动进行去除，增加美观性</p>\n<h4 id=\"4html5新增\"><a class=\"markdownIt-Anchor\" href=\"#4html5新增\">#</a> 4.html5 新增</h4>\n<h6 id=\"语义化标签\"><a class=\"markdownIt-Anchor\" href=\"#语义化标签\">#</a> 语义化标签</h6>\n<blockquote>\n<pre><code>&lt;header&gt;头部标签&lt;/header&gt;\n\n&lt;nav&gt;导航栏标签&lt;/nav&gt;   \n&lt;section&gt;某个区域&lt;/section&gt;\n</code></pre>\n</blockquote>\n<h6 id=\"视频标签\"><a class=\"markdownIt-Anchor\" href=\"#视频标签\">#</a> 视频标签</h6>\n<blockquote>\n<pre><code>&lt;video src=\"\" autoplay=\"\"muted=\"muted\"  loop=\"loop\" poster=\"media/mi9.jpg\"&gt;\n</code></pre>\n</blockquote>\n<p>src: 路径<br>\n autoplay: 写入 autoplay 代表自动播放<br>\n mute: 播放时静音<br>\n loop: 预先加载<br>\n poster: 播放还没有加载出来的时候显示的图片<br>\n controls: 是否显示控制按钮</p>\n<h6 id=\"音频标签\"><a class=\"markdownIt-Anchor\" href=\"#音频标签\">#</a> 音频标签</h6>\n<blockquote>\n<pre><code>&lt;audio src=\"media/music.mp3\" autoplay=\"autoplay\" controls=\"controls\"&gt;&lt;/audio&gt;\n</code></pre>\n</blockquote>\n<p>与视频标签相差无几</p>\n<h6 id=\"input表单\"><a class=\"markdownIt-Anchor\" href=\"#input表单\">#</a> input 表单</h6>\n<p><img src=\"images/46.png\" alt=\"photo\"></p>\n<h6 id=\"表单属性\"><a class=\"markdownIt-Anchor\" href=\"#表单属性\">#</a> 表单属性</h6>\n<blockquote>\n<pre><code>&lt;input type=\"search\" name=\"sear\" id=\"\" required=\"required\" placeholder=\"pink老师\" autofocus=\"autofocus\" autocomplete=\"off\"&gt;\n</code></pre>\n</blockquote>\n<pre><code> &lt;input type=\"file\" name=\"\" id=\"\" multiple=\"multiple\"&gt;\n</code></pre>\n<p>required: 需要填写才能点确定<br>\n placeholder: 还没有填写时候显示的文字<br>\n autofocus: 打开网页时，指标会自动点一下这里<br>\n autocomplete: 自动储存你输入过的信息 (容易暴露信息，所以一般都会关闭)<br>\n multiple: 可以选取多个文件</p>\n",
            "tags": [
                "前端"
            ]
        },
        {
            "id": "http://example.com/2021/11/06/css1/",
            "url": "http://example.com/2021/11/06/css1/",
            "title": "Css-first",
            "date_published": "2021-11-05T16:00:00.000Z",
            "content_html": "<h1 id=\"css1\"><a class=\"markdownIt-Anchor\" href=\"#css1\">#</a> css1</h1>\n<h3 id=\"the-article-from-yogmas-also-sam\"><a class=\"markdownIt-Anchor\" href=\"#the-article-from-yogmas-also-sam\">#</a> the article from yogmas also sam</h3>\n<h4 id=\"1css基本架构\"><a class=\"markdownIt-Anchor\" href=\"#1css基本架构\">#</a> 1.css 基本架构</h4>\n<blockquote>\n<pre><code>&lt;html&gt; \n&lt;head&gt;\n&lt;style&gt;&lt;/style&gt;\n &lt;/head&gt;\n &lt;body&gt;&lt;/body&gt;\n &lt;/html&gt;\n style为css放置位置\n</code></pre>\n</blockquote>\n<p>前期学习先将 css 放置在 html 文件夹里面后期会单独利用 css 文件来写 css</p>\n<h4 id=\"2选择器\"><a class=\"markdownIt-Anchor\" href=\"#2选择器\">#</a> 2. 选择器</h4>\n<h6 id=\"标签选择器\"><a class=\"markdownIt-Anchor\" href=\"#标签选择器\">#</a> 标签选择器</h6>\n<blockquote>\n<p>选择器 {样式}<br>\n 给谁改样式 {改什么样式}<br>\neg.p { color: red;<br>\nfont-size: 12px; }</p>\n</blockquote>\n<p>标签选择器为大类选择，同一类标签全部都会被 css 修改</p>\n<h6 id=\"类选择器\"><a class=\"markdownIt-Anchor\" href=\"#类选择器\">#</a> 类选择器</h6>\n<blockquote>\n<pre><code>.id {} \neg .red {color:red;}\n&lt;# class=\"id\"&gt;  &lt;/#&gt;\n</code></pre>\n</blockquote>\n<p>这里的 ID 还需要与 html 中的 class 相互匹配 #可以替换成任何你想选择的类别 id 可以替换成任何你命名的字母或者单词<br>\n<strong>类选择器口诀：样式点定义  结构类 (class) 调用  一个或多个 开发最常用</strong><br>\n<img src=\"images/4.png\" alt=\"phtot\"><br>\n 同时类选择器可以有多个 ID 都会起作用 中间用空格隔开 例如<br>\n<img src=\"images/5.png\" alt=\"phtot\"></p>\n<h6 id=\"id选择器\"><a class=\"markdownIt-Anchor\" href=\"#id选择器\">#</a> id 选择器</h6>\n<p>id 选择器与类选择器相似，不过 ID 选择器只能使用一次 并且一个 ID 只能调用一次</p>\n<blockquote>\n<pre><code>#ID {}\n&lt;XX id=\"\"&gt;  &lt;/XX&gt;\n</code></pre>\n</blockquote>\n<h6 id=\"通配符选择器\"><a class=\"markdownIt-Anchor\" href=\"#通配符选择器\">#</a> 通配符选择器</h6>\n<blockquote>\n<pre><code>* { }\n</code></pre>\n</blockquote>\n<p>通配符 简而言之就是对所有元素和类都有作用，后期主要用来先去除掉浏览器自身所带的一些 css 属性方便我们后续进行 css 操作</p>\n<h4 id=\"3css字体属性\"><a class=\"markdownIt-Anchor\" href=\"#3css字体属性\">#</a> 3.CSS 字体属性</h4>\n<p><img src=\"images/6.png\" alt=\"phtot\"></p>\n<h6 id=\"字体系列\"><a class=\"markdownIt-Anchor\" href=\"#字体系列\">#</a> 字体系列</h6>\n<blockquote>\n<p>font-family:’   ';</p>\n</blockquote>\n<p>通常会根据团队的要求来确定书写的字体 一般来说是微软雅黑也就是 microsoft YaHei 当然也可以有其他的一系列字体<br>\n比如在后期的<strong>字体图标</strong>中就需要修改 font-family</p>\n<h6 id=\"字体大小\"><a class=\"markdownIt-Anchor\" href=\"#字体大小\">#</a> 字体大小</h6>\n<blockquote>\n<p>font-size:;</p>\n</blockquote>\n<p>顾名思义，是修改字体的大小，不过需要注意的是这后面不能跟单独的数字 这样是没有效果的 需要跟单位 px</p>\n<h6 id=\"字体粗细\"><a class=\"markdownIt-Anchor\" href=\"#字体粗细\">#</a> 字体粗细</h6>\n<blockquote>\n<p>font-weight:  ;</p>\n</blockquote>\n<p>这里需要谨记 2 个数字<br>\n 700: 加粗<br>\n 400: 正常大小<br>\n font-weight 后面跟数字，可以根据需要来进行调整 不过一般都是 700 和 400 之间切换</p>\n<h6 id=\"文字样式风格\"><a class=\"markdownIt-Anchor\" href=\"#文字样式风格\">#</a> 文字样式风格</h6>\n<blockquote>\n<p>font-style: ;</p>\n</blockquote>\n<p>一般运用的都 italic (倾斜) 和 normal (正常) 两种<br>\n实际运用场景：<br>\n1. 用来修改需要倾斜的汉字<br>\n 2. 当没有标签可用时，可以用 em 倾斜标签先将汉字包括，在通过 font-style:normal；将倾斜属性去掉</p>\n<h6 id=\"字体复合属性\"><a class=\"markdownIt-Anchor\" href=\"#字体复合属性\">#</a> 字体复合属性</h6>\n<p>通过简写的方式来节约代码 (不过有顺序要求)</p>\n<blockquote>\n<pre><code>font: font-style  font-weight  font-size/line-height  font-family;\neg:font: italic 700 16px 'Microsoft yahei';\n 前面两个可以省略，但是后面连个一定要写\n</code></pre>\n</blockquote>\n<h4 id=\"4文本外观属性\"><a class=\"markdownIt-Anchor\" href=\"#4文本外观属性\">#</a> 4. 文本外观属性</h4>\n<p><img src=\"images/7.png\" alt=\"phtot\"></p>\n<h6 id=\"颜色\"><a class=\"markdownIt-Anchor\" href=\"#颜色\">#</a> 颜色</h6>\n<blockquote>\n<pre><code>color: \"\n</code></pre>\n</blockquote>\n<p>这里 color 后面所带有 4 种写法<br>\n 1. 直接加颜色例如 red,blue<br>\n2. 加颜色编号，主要这里 #必须加例如 #123456 (常用) 后期通常会用吸色笔 然后负值颜色编号<br>\n 3.rgb (X,X,X) 三色的搭配<br>\n 4.rgba (X,X,X,G) 这个主要是用来设置颜色的透明度 G 取值从 0~1<br>\n 用来设置颜色的透明度</p>\n<h6 id=\"文字对齐\"><a class=\"markdownIt-Anchor\" href=\"#文字对齐\">#</a> 文字对齐</h6>\n<blockquote>\n<p>text-align: ;</p>\n</blockquote>\n<p>设置文字的对齐方式，<br>\nleft,center,right</p>\n<h6 id=\"装饰文本\"><a class=\"markdownIt-Anchor\" href=\"#装饰文本\">#</a> 装饰文本</h6>\n<blockquote>\n<pre><code>text-deroration: ;\n</code></pre>\n</blockquote>\n<p>可加元素:<br>\nline-through 删除线<br>\n overline 上划线<br>\n<strong> none</strong> (常用) 通常用来配合通配符选择器来取消 a 的下划线</p>\n<h6 id=\"文本缩进\"><a class=\"markdownIt-Anchor\" href=\"#文本缩进\">#</a> 文本缩进</h6>\n<blockquote>\n<p>text-indent: ;</p>\n</blockquote>\n<p>后面添加数据时需要注意单位 用像素 (px) 或者 em (一个汉字所占的大小)</p>\n<h6 id=\"行间距\"><a class=\"markdownIt-Anchor\" href=\"#行间距\">#</a> 行间距</h6>\n<blockquote>\n<p>line-height: ;</p>\n</blockquote>\n<p>也需要加 px<br>\n 后期通常使 line-height 和 height 相等，来使文字垂直对齐</p>\n<h4 id=\"5style样式表\"><a class=\"markdownIt-Anchor\" href=\"#5style样式表\">#</a> 5.style 样式表</h4>\n<h6 id=\"内部样式表\"><a class=\"markdownIt-Anchor\" href=\"#内部样式表\">#</a> 内部样式表</h6>\n<p>也就是我们最开始介绍，直到现在一直在使用的加到 style 里面的 css 属性</p>\n<h6 id=\"行内样式表\"><a class=\"markdownIt-Anchor\" href=\"#行内样式表\">#</a> 行内样式表</h6>\n<p>直接加在 html 标签中的样式表</p>\n<blockquote>\n<pre><code> 例如: &lt;div style=\"\";&gt; &lt;/div&gt;\n 不常使用，会使html标签显得臃肿\n</code></pre>\n</blockquote>\n<h6 id=\"外部样式表\"><a class=\"markdownIt-Anchor\" href=\"#外部样式表\">#</a> 外部样式表</h6>\n<blockquote>\n<pre><code>&lt;link rel=\"\"; href=\"文件地址\";&gt;\n</code></pre>\n</blockquote>\n<p>另建一个.css 文件，在另外一个文件中书写 css 属性<br>\n再通过在 style 中书写 link 将其引入</p>\n<h4 id=\"6vscode中使用emmet语法快速书写代码\"><a class=\"markdownIt-Anchor\" href=\"#6vscode中使用emmet语法快速书写代码\">#</a> 6.vscode 中使用 emmet 语法快速书写代码</h4>\n<p><img src=\"images/8.png\" alt=\"phtot\"></p>\n<h4 id=\"7选择器拓展\"><a class=\"markdownIt-Anchor\" href=\"#7选择器拓展\">#</a> 7. 选择器拓展</h4>\n<p><img src=\"images/12.png\" alt=\"photo\"></p>\n<h6 id=\"后代选择器\"><a class=\"markdownIt-Anchor\" href=\"#后代选择器\">#</a> 后代选择器</h6>\n<p>顾名思义就是将大元素中包括的小元素提取出来，这里通过列子来展示<br>\n<img src=\"images/9.png\" alt=\"phtot\"></p>\n<h6 id=\"子元素选择器\"><a class=\"markdownIt-Anchor\" href=\"#子元素选择器\">#</a> 子元素选择器</h6>\n<p>例如上面的 ol li 变成 ol&gt;li 就只对 ol 中的下一级 li 有用也就是他的儿子，而他的下下级，也就是孙子则不起作用</p>\n<h6 id=\"并集选择器\"><a class=\"markdownIt-Anchor\" href=\"#并集选择器\">#</a> 并集选择器</h6>\n<p>在标签和标签中间用逗号连接，这样就可以达到同时对两个盒子都起作用的效果</p>\n<blockquote>\n<p>例如 div,p,li {}</p>\n</blockquote>\n<p>需要注意的是最后一个选择器不需要加逗号</p>\n<h6 id=\"链接伪类选择器\"><a class=\"markdownIt-Anchor\" href=\"#链接伪类选择器\">#</a> 链接伪类选择器</h6>\n<p><img src=\"images/27.png\" alt=\"photo\"></p>\n<blockquote>\n<p>X:GGGG {}</p>\n</blockquote>\n<p>X 可以是你的选择器中的任何<br>\n：后面可以添加 4 中元素 (其中 hover 最经常使用)：<br>\nlink: 未访问链接：把没有点击过的链接选择出来<br>\n visited: 访问过的链接，把点击过的链接选择出来<br>\n hover: 当鼠标经过时<br>\n active: 鼠标点击但是还未弹起来时<br>\n<img src=\"images/10.png\" alt=\"photo\"></p>\n<h6 id=\"focus选择器\"><a class=\"markdownIt-Anchor\" href=\"#focus选择器\">#</a> focus 选择器</h6>\n<p>把获得光标的 input 选择显示出来<br>\n下面是代码，可以通过自己运行来进行查看<br>\n<img src=\"images/11.png\" alt=\"photo\"></p>\n<h4 id=\"8元素显示模式\"><a class=\"markdownIt-Anchor\" href=\"#8元素显示模式\">#</a> 8. 元素显示模式</h4>\n<p><img src=\"images/28.png\" alt=\"photo\"></p>\n<h6 id=\"块级元素\"><a class=\"markdownIt-Anchor\" href=\"#块级元素\">#</a> 块级元素</h6>\n<p><img src=\"images/13.png\" alt=\"photo\"></p>\n<h6 id=\"行内元素\"><a class=\"markdownIt-Anchor\" href=\"#行内元素\">#</a> 行内元素</h6>\n<p><img src=\"images/14.png\" alt=\"photo\"></p>\n<h6 id=\"行内块元素\"><a class=\"markdownIt-Anchor\" href=\"#行内块元素\">#</a> 行内块元素</h6>\n<p>特殊情况，同时具有块级元素和行内元素的特点，可以进行的大小设置，也可以书写汉字，但是大小会随着汉字的多少而改变</p>\n<h6 id=\"元素显示模式转换\"><a class=\"markdownIt-Anchor\" href=\"#元素显示模式转换\">#</a> 元素显示模式转换</h6>\n<blockquote>\n<pre><code> display:   ;\n</code></pre>\n</blockquote>\n<p>inline: 行内元素<br>\n block: 块级元素<br>\n inline-block: 行内块元素<br>\n<strong>学到这里去做一下小米侧边栏试试吧</strong></p>\n<h6 id=\"单行文字垂直居中\"><a class=\"markdownIt-Anchor\" href=\"#单行文字垂直居中\">#</a> 单行文字垂直居中</h6>\n<p>也就是上面和大家提及过的，这里让 height 和 line-height 相同即可</p>\n<h4 id=\"9背景\"><a class=\"markdownIt-Anchor\" href=\"#9背景\">#</a> 9. 背景</h4>\n<p><img src=\"images/20.png\" alt=\"photo\"></p>\n<h6 id=\"背景颜色\"><a class=\"markdownIt-Anchor\" href=\"#背景颜色\">#</a> 背景颜色</h6>\n<blockquote>\n<p>background-color: ;</p>\n</blockquote>\n<p>后面的元素参照前面 color 属性</p>\n<h6 id=\"背景图片\"><a class=\"markdownIt-Anchor\" href=\"#背景图片\">#</a> 背景图片</h6>\n<blockquote>\n<p>background-image: url (链接 / 地址)；</p>\n</blockquote>\n<h6 id=\"背景平铺\"><a class=\"markdownIt-Anchor\" href=\"#背景平铺\">#</a> 背景平铺</h6>\n<blockquote>\n<p>background-repeat: ;</p>\n</blockquote>\n<p>no-repeat (常用): 不平铺<br>\n repeat (默认): 平铺<br>\n repeat-x: 沿着 X 轴平铺<br>\n repeat-y: 沿着 Y 轴平铺<br>\n<strong>背景图片会压住背景颜色</strong><br>\n<img src=\"images/15.png\" alt=\"photo\"></p>\n<h6 id=\"背景位置\"><a class=\"markdownIt-Anchor\" href=\"#背景位置\">#</a> 背景位置</h6>\n<blockquote>\n<p>background-position: ;</p>\n</blockquote>\n<p>left top center right bottom<br>\n 也可以用 right center 等同时使用 但是有几点需要注意<br>\n 1. 如果是方位名词  right center 和 center right 效果是等价的 跟顺序没有关系<br>\n 2. 当有参数省略时，并且不全是方位名字时，例如 right top ,<br>\n 省略 right，此时 top 会自动顶部对齐，而省略的会被判定为水平居中<br>\n省略 top，则会被判定为垂直居中<br>\n<img src=\"images/16.png\" alt=\"photo\"><br>\n 也可以用具体的数据来进行移动，主要用于精灵图<br>\n<img src=\"images/17.png\" alt=\"phtot\"><br>\n 需要注意的时，html 的 X 轴向右，而 y 轴是向下的，需要向反方向移动时可以添加负号</p>\n<h6 id=\"背景固定\"><a class=\"markdownIt-Anchor\" href=\"#背景固定\">#</a> 背景固定</h6>\n<blockquote>\n<p>backgrounf-attachment: fixed;</p>\n</blockquote>\n<p>将背景图片固定，这样滑动鼠标滚轮时，背景图片会一直存在于网页上，并不会滑走<br>\n<img src=\"images/18.png\" alt=\"photo\"></p>\n<h6 id=\"背景属性复合写法\"><a class=\"markdownIt-Anchor\" href=\"#背景属性复合写法\">#</a> 背景属性复合写法</h6>\n<p><img src=\"images/19.png\" alt=\"photo\"></p>\n<h6 id=\"背景半透明\"><a class=\"markdownIt-Anchor\" href=\"#背景半透明\">#</a> 背景半透明</h6>\n<p>主要这个不是放在 background-color 中</p>\n<blockquote>\n<p>background: rgba(X,X,X,X);</p>\n</blockquote>\n",
            "tags": [
                "前端"
            ]
        },
        {
            "id": "http://example.com/2021/11/06/css2/",
            "url": "http://example.com/2021/11/06/css2/",
            "title": "Css-second",
            "date_published": "2021-11-05T16:00:00.000Z",
            "content_html": "<h1 id=\"css2\"><a class=\"markdownIt-Anchor\" href=\"#css2\">#</a> css2</h1>\n<h3 id=\"the-article-from-yogmas-also-sam\"><a class=\"markdownIt-Anchor\" href=\"#the-article-from-yogmas-also-sam\">#</a> the article from yogmas also sam</h3>\n<h4 id=\"1css选择器的性质\"><a class=\"markdownIt-Anchor\" href=\"#1css选择器的性质\">#</a> 1.css 选择器的性质</h4>\n<h6 id=\"css层叠性\"><a class=\"markdownIt-Anchor\" href=\"#css层叠性\">#</a> css 层叠性</h6>\n<p>长江后浪推前浪，前浪死在沙滩上<br>\n当两个完全相同的选择器写在一起时，此时根据就近原则处理</p>\n<h6 id=\"css继承性\"><a class=\"markdownIt-Anchor\" href=\"#css继承性\">#</a> css 继承性</h6>\n<p>大元素中的小元素会继承写在大元素中的属性</p>\n<h6 id=\"行高的继承\"><a class=\"markdownIt-Anchor\" href=\"#行高的继承\">#</a> 行高的继承</h6>\n<p><img src=\"images/21.png\" alt=\"photo\"></p>\n<p>孩子拥有 font-size 元素会优先使用定义在自身的，而后面的倍数孩子自身没有就会继承父亲的倍数</p>\n<h6 id=\"css优先级\"><a class=\"markdownIt-Anchor\" href=\"#css优先级\">#</a> css 优先级</h6>\n<p>这个主要是根据后面的权重的大小而判定的，权重大的优先。</p>\n<h6 id=\"css权重\"><a class=\"markdownIt-Anchor\" href=\"#css权重\">#</a> css 权重</h6>\n<p><img src=\"images/22.png\" alt=\"photo\"></p>\n<h6 id=\"权重的叠加\"><a class=\"markdownIt-Anchor\" href=\"#权重的叠加\">#</a> 权重的叠加</h6>\n<p>权重的叠加可以用加减法来计算<br>\n例如 0,1,0,0 相当于 100</p>\n<h4 id=\"2盒子模型\"><a class=\"markdownIt-Anchor\" href=\"#2盒子模型\">#</a> 2. 盒子模型</h4>\n<p>盒子通常是块级元素<br>\n也可以通过 display 将其变成块级元素 a 元素通常使用这种方法</p>\n<h6 id=\"盒子边框\"><a class=\"markdownIt-Anchor\" href=\"#盒子边框\">#</a> 盒子边框</h6>\n<p><img src=\"images/23.png\" alt=\"photo\"></p>\n<blockquote>\n<p>border-width: ;<br>\nborder-style: ;<br>\nborder-color: ;<br>\nborder:width style color ; 复合写法</p>\n</blockquote>\n<p>这边建议大家使用复合写法<br>\n style:solid 实线 dotted 虚线 dashed 更大点的虚线</p>\n<p><strong>边框会影响盒子的实际大小</strong></p>\n<h6 id=\"盒子内边框\"><a class=\"markdownIt-Anchor\" href=\"#盒子内边框\">#</a> 盒子内边框</h6>\n<p><img src=\"images/24.png\" alt=\"photo\"></p>\n<blockquote>\n<p>padding: ;<br>\npadding-left: ;</p>\n</blockquote>\n<p>同理 left 可以换成其他的方位</p>\n<p>内边距复合写法：从顶部顺时针数<br>\n<strong>内边距会影响盒子的大小</strong></p>\n<p>内边距不会影响盒子大小的情况:<br>\n 当盒子内没有给宽时，padding-left/right 不会影响<br>\n没有给高时 padding-top/bottom 不会影响</p>\n<h6 id=\"盒子外边距\"><a class=\"markdownIt-Anchor\" href=\"#盒子外边距\">#</a> 盒子外边距</h6>\n<blockquote>\n<p>margin:  ;<br>\nmargin-top/XXX: ;</p>\n</blockquote>\n<p>复合写法和内边距同理</p>\n<p><strong>外边距典型应用</strong>:<br>\nmargin: XXXpx auto;<br>\n 此时 auto 代表左右两边自动设置可以让盒子水平对齐</p>\n<h6 id=\"行内元素或行内块元素水平居中对齐\"><a class=\"markdownIt-Anchor\" href=\"#行内元素或行内块元素水平居中对齐\">#</a> 行内元素或行内块元素水平居中对齐</h6>\n<p>margin 对行内元素没有作用，但是可以给这两种元素的父盒子添加 text-align:center;</p>\n<h6 id=\"外边距合并\"><a class=\"markdownIt-Anchor\" href=\"#外边距合并\">#</a> 外边距合并</h6>\n<p>当子盒子给 margin 时，父盒子和子盒子会塌陷，两个盒子会边框重合</p>\n<h6 id=\"清除内外边距\"><a class=\"markdownIt-Anchor\" href=\"#清除内外边距\">#</a> 清除内外边距</h6>\n<p>通常浏览器会自带内外边距这时就需要使用通用符选择器将浏览器自带的边距出去</p>\n<blockquote>\n<pre><code>* {padding:0 ;\n   margin:0;}\n</code></pre>\n</blockquote>\n<h6 id=\"圆角边框\"><a class=\"markdownIt-Anchor\" href=\"#圆角边框\">#</a> 圆角边框</h6>\n<blockquote>\n<p>border-radius: Xpx ;</p>\n</blockquote>\n<p>原理：利用一个半径为 Xpx 的圆，与边角重叠，然后切去没有重叠的边角；</p>\n<h6 id=\"盒子阴影\"><a class=\"markdownIt-Anchor\" href=\"#盒子阴影\">#</a> 盒子阴影</h6>\n<p><img src=\"images/32.png\" alt=\"photo\"></p>\n<blockquote>\n<p>box-shadow: X X X X X;</p>\n</blockquote>\n<p>由左到右依次为 往右边移动的距离 往下面移动的距离 阴影发散度 (往四面八方发散)  往四面八方扩散的距离 颜色 (通常是 rgba 控制)</p>\n<h6 id=\"文字阴影\"><a class=\"markdownIt-Anchor\" href=\"#文字阴影\">#</a> 文字阴影</h6>\n<blockquote>\n<p>text-shadow:X X X rgba;</p>\n</blockquote>\n<p>分别是 往右边移动的距离 往下面移动的距离 虚实度 (越大越虚)</p>\n<h6 id=\"行内块元素中间有缝隙\"><a class=\"markdownIt-Anchor\" href=\"#行内块元素中间有缝隙\">#</a> 行内块元素中间有缝隙</h6>\n<h4 id=\"3浮动\"><a class=\"markdownIt-Anchor\" href=\"#3浮动\">#</a> 3. 浮动</h4>\n<blockquote>\n<pre><code>  float: left/right;\n</code></pre>\n</blockquote>\n<h6 id=\"浮动特性-脱标\"><a class=\"markdownIt-Anchor\" href=\"#浮动特性-脱标\">#</a> 浮动特性 - 脱标</h6>\n<p>1. 脱离标准普通流的控制（浮）移动到指定位置（动）。<br>\n2. 浮动的盒子不在保留原先的位置</p>\n<p><strong>浮动元素具有行内块元素的特点</strong><br>\n浮动盒子通常搭配标准流父盒子</p>\n<h6 id=\"浮动的注意点\"><a class=\"markdownIt-Anchor\" href=\"#浮动的注意点\">#</a> 浮动的注意点</h6>\n<p>1. 如果一个子元素浮动了，尽量其他盒子也浮动，这样保证这些子元素一行显示</p>\n<h6 id=\"清除浮动的方法\"><a class=\"markdownIt-Anchor\" href=\"#清除浮动的方法\">#</a> 清除浮动的方法</h6>\n<p><img src=\"images/31.png\" alt=\"photo\"></p>\n<p><img src=\"images/29.png\" alt=\"photo\"></p>\n<p>额外标签法：在子盒子的最后新增一个块级盒子 并且用 css 给快捷盒子加上 clear:both; 属性</p>\n<p>父元素 overflow: 给父元素加上一个 overflow: hidden; 的 css 属性<br>\n<img src=\"images/25.png\" alt=\"photo\"></p>\n<p>伪元素清除:</p>\n<blockquote>\n<p>.clearfix:after {<br>\ncontent: “”;<br>\ndisplay: block;<br>\nheight: 0;<br>\nclear: both;<br>\nvisibility: hidden;<br>\n}<br>\n.clearfix {<br>\nIE6、7 专有<br>\n zoom: 1;<br>\n}</p>\n</blockquote>\n<p><img src=\"images/30.png\" alt=\"photo\"></p>\n<p>给父盒子一个 class 为 clearfix 然后将这串代码心如 css 中</p>\n<p>双伪元素清除:</p>\n<blockquote>\n<p>.clearfix:before,<br>\n.clearfix:after {<br>\ncontent: “”;<br>\ndisplay: table;<br>\n}<br>\n.clearfix:after {<br>\nclear: both;<br>\n}<br>\n.clearfix {<br>\n*zoom: 1;<br>\n}</p>\n</blockquote>\n<p>同理给一个 clearfix 标签，然后将这串代码写入 css 中</p>\n<h4 id=\"4定位\"><a class=\"markdownIt-Anchor\" href=\"#4定位\">#</a> 4. 定位</h4>\n<p><img src=\"images/33.png\" alt=\"photo\"><br>\n<img src=\"images/40.png\" alt=\"photo\"></p>\n<blockquote>\n<p>position: ;</p>\n</blockquote>\n<p>static: 默认静态定位<br>\n absolute: 绝对定位<br>\n relative: 相对定位<br>\n fixed: 固定定位<br>\n sticky: 粘性定位</p>\n<p>相对定位：可以进行定位，但依旧会占用空间<br>\n绝对定位<br>\n如果没施加绝对定位的盒子没有父盒子，那么绝对定位就是在浏览器的基础上的<br>\n如果绝对定位的盒子有父盒子，那么绝对定位就是在父盒子的基础上，并且<strong>父盒子一定要有定位，否则绝对定位就会失效</strong>所以通常说相对定位就是给绝对定位当爹的</p>\n<p>固定定位：会固定在屏幕上，无视浏览器的滑块移动</p>\n<p>粘性定位：会先随着浏览器滑块的滑动而滑动，但是后来会静止，并且无法滑出浏览器屏幕</p>\n<h6 id=\"定位的堆叠顺序\"><a class=\"markdownIt-Anchor\" href=\"#定位的堆叠顺序\">#</a> 定位的堆叠顺序</h6>\n<p>如果有很多个绝对定位，可能会放在同一个位置，这时候需要确定谁放置在最上面</p>\n<blockquote>\n<pre><code>z-index: ;\n</code></pre>\n</blockquote>\n<p>默认为 0，数值越大显示等级越高</p>\n<h6 id=\"小技巧-绝对定位的水平垂直居中\"><a class=\"markdownIt-Anchor\" href=\"#小技巧-绝对定位的水平垂直居中\">#</a> 小技巧 - 绝对定位的水平垂直居中</h6>\n<p>1.left 走 50%  父容器宽度的一半<br>\n 2.margin 负值 往左边走 自己盒子宽度的一半</p>\n<h6 id=\"定位的特殊特性\"><a class=\"markdownIt-Anchor\" href=\"#定位的特殊特性\">#</a> 定位的特殊特性</h6>\n<p><img src=\"images/34.png\" alt=\"photo\"><br>\n<img src=\"images/35.png\" alt=\"photo\"></p>\n<h6 id=\"定位和浮动的差异\"><a class=\"markdownIt-Anchor\" href=\"#定位和浮动的差异\">#</a> 定位和浮动的差异</h6>\n<p>定位和浮动有相似部分，类如都会转化为行内块元素，都会压住盒子，但是浮动不会压住文字，定位会将所有东西压住</p>\n<h4 id=\"5显示隐藏\"><a class=\"markdownIt-Anchor\" href=\"#5显示隐藏\">#</a> 5. 显示隐藏</h4>\n<h6 id=\"display\"><a class=\"markdownIt-Anchor\" href=\"#display\">#</a> display</h6>\n<blockquote>\n<p>display: ;</p>\n</blockquote>\n<p><img src=\"images/36.png\" alt=\"photo\"></p>\n<h6 id=\"visibility\"><a class=\"markdownIt-Anchor\" href=\"#visibility\">#</a> visibility</h6>\n<p><img src=\"images/37.png\" alt=\"photo\"></p>\n<h6 id=\"overflow\"><a class=\"markdownIt-Anchor\" href=\"#overflow\">#</a> overflow</h6>\n<blockquote>\n<p>overflow: ;</p>\n</blockquote>\n<p><img src=\"images/38.png\" alt=\"photo\"><br>\n<img src=\"images/39.png\" alt=\"photo\"></p>\n<h4 id=\"6精灵图\"><a class=\"markdownIt-Anchor\" href=\"#6精灵图\">#</a> 6. 精灵图</h4>\n<p>这里不好介绍怎样操作只能简单而言<br>\n一张包含各种小图片的大图片<br>\n利用前面所讲的背景图片位置的移动使其只能显示出一张小图片来<br>\n问：为什么需要精灵图<br>\n利用精灵图可以将多张图片整合在一起，从而可以减少信息的发送和接受量，减少服务器的负担</p>\n<h4 id=\"7字体图标的使用\"><a class=\"markdownIt-Anchor\" href=\"#7字体图标的使用\">#</a> 7. 字体图标的使用</h4>\n<p>通过在网站上寻找字体图标，下载</p>\n<p>然后将代码写入 css 中</p>\n<blockquote>\n<p>@font-face {<br>\nfont-family: ‘icomoon’;<br>\nsrc:  url(‘fonts/icomoon.eot?p4ssmb’);<br>\nsrc:  url(‘fonts/icomoon.eot?p4ssmb#iefix’) format(‘embedded-opentype’),<br>\nurl(‘fonts/icomoon.ttf?p4ssmb’) format(‘truetype’),<br>\nurl(‘fonts/icomoon.woff?p4ssmb’) format(‘woff’),<br>\nurl(‘fonts/icomoon.svg?p4ssmb#icomoon’) format(‘svg’);<br>\nfont-weight: normal;<br>\nfont-style: normal;<br>\nfont-display: block;<br>\n}</p>\n</blockquote>\n<p>font 文件夹移动到主文件夹中</p>\n<p>此时就可以用字体图标代码来进行表示字体图标</p>\n<p>好处：可以对图标进行改变颜色大小等等的改变字体时用到的属性</p>\n<h4 id=\"8css三角的制作\"><a class=\"markdownIt-Anchor\" href=\"#8css三角的制作\">#</a> 8.css 三角的制作</h4>\n<p>利用 cssborder 属性来进行三角的制作<br>\n由于不好叙述，自己输入，理解并体验这几组代码，应该就能理解 css 三角的制作<br>\n<img src=\"images/41.png\" alt=\"photo\"><br>\n<img src=\"images/42.png\" alt=\"photo\"></p>\n<h4 id=\"9用户界面样式\"><a class=\"markdownIt-Anchor\" href=\"#9用户界面样式\">#</a> 9. 用户界面样式</h4>\n<h6 id=\"表单轮廓\"><a class=\"markdownIt-Anchor\" href=\"#表单轮廓\">#</a> 表单轮廓</h6>\n<p>由于点击表单或者 text 文本框时边框上会出现颜色变化边框变大拖拽文本域等一系列的反应，从而利用 css 取消边框的轮廓</p>\n<blockquote>\n<pre><code>outline: none;  (input,textarea)\n</code></pre>\n</blockquote>\n<blockquote>\n<pre><code>resize:none; (textarea)\n</code></pre>\n<p>用来防止拖拽文本域的</p>\n</blockquote>\n<h6 id=\"鼠标样式\"><a class=\"markdownIt-Anchor\" href=\"#鼠标样式\">#</a> 鼠标样式</h6>\n<blockquote>\n<p>cursor: ;</p>\n</blockquote>\n<p>default: 小白鼠标样式<br>\n pointer: 鼠标小手样式<br>\n move: 鼠标移动样式<br>\n text: 鼠标文本样式<br>\n not-allowed: 鼠标禁止样式</p>\n<h6 id=\"图片文字垂直居中\"><a class=\"markdownIt-Anchor\" href=\"#图片文字垂直居中\">#</a> 图片文字垂直居中</h6>\n<p><img src=\"images/43.png\" alt=\"photo\"></p>\n<h6 id=\"图片底侧有空白缝隙的解决方案\"><a class=\"markdownIt-Anchor\" href=\"#图片底侧有空白缝隙的解决方案\">#</a> 图片底侧有空白缝隙的解决方案</h6>\n<p>先将图片变为块级元素，然后再给块级元素设置边框就可以解决</p>\n<h4 id=\"10文字溢出显示\"><a class=\"markdownIt-Anchor\" href=\"#10文字溢出显示\">#</a> 10. 文字溢出显示</h4>\n<h6 id=\"单行文字溢出显示\"><a class=\"markdownIt-Anchor\" href=\"#单行文字溢出显示\">#</a> 单行文字溢出显示</h6>\n<p><img src=\"images/44.png\" alt=\"photo\"></p>\n<h6 id=\"多行文字溢出显示\"><a class=\"markdownIt-Anchor\" href=\"#多行文字溢出显示\">#</a> 多行文字溢出显示</h6>\n<p><img src=\"images/45.png\" alt=\"photo\"></p>\n<h4 id=\"11margin负值的巧妙运动\"><a class=\"markdownIt-Anchor\" href=\"#11margin负值的巧妙运动\">#</a> 11.margin 负值的巧妙运动</h4>\n<p>如果多个盒子都有边框，此时相交部分边框会重合在一起，从而增加边框的大小，此时只需要写入 margin-left: -1px; 就可以得到解决</p>\n<h4 id=\"12文字围绕浮动元素\"><a class=\"markdownIt-Anchor\" href=\"#12文字围绕浮动元素\">#</a> 12. 文字围绕浮动元素</h4>\n<p>众所周知浮动元素是不占用空间的，此时如果将一个照片浮动，而需要在照片旁边写入汉字的话，汉字是否会出现在图片的下方呢，答案是不会，因为汉字会围绕浮动元素</p>\n<h4 id=\"13css初始化\"><a class=\"markdownIt-Anchor\" href=\"#13css初始化\">#</a> 13.css 初始化</h4>\n<p>这里给出一串代码，初始化网页，将网页元素自带的一些 css 属性给去掉</p>\n<blockquote>\n<p>/* 把我们所有标签的内外边距清零 <em>/<br>\n* {<br>\nmargin: 0;<br>\npadding: 0<br>\n}<br>\n/</em>em 和 i 斜体的文字不倾斜 <em>/<br>\nem,<br>\ni {<br>\nfont-style: normal<br>\n}<br>\n/</em> 去掉 li 的小圆点 <em>/<br>\nli {<br>\nlist-style: none<br>\n}<br>\nimg {<br>\n/</em>border 0 照顾低版本浏览器 如果 图片外面包含了链接会有边框的问题 <em>/<br>\nborder: 0;<br>\n/</em> 取消图片底侧有空白缝隙的问题 <em>/<br>\nvertical-align: middle<br>\n}<br>\nbutton {<br>\n/</em> 当我们鼠标经过 button 按钮的时候，鼠标变成小手 <em>/<br>\ncursor: pointer<br>\n}<br>\na {<br>\ncolor: #666;<br>\ntext-decoration: none<br>\n}<br>\na:hover {<br>\ncolor: #c81623<br>\n}<br>\nbutton,<br>\ninput {<br>\n/</em> “\\5B8B\\4F53” 就是宋体的意思 这样浏览器兼容性比较好 <em>/<br>\nfont-family: Microsoft YaHei, Heiti SC, tahoma, arial, Hiragino Sans GB, “\\5B8B\\4F53”, sans-serif<br>\n}<br>\nbody {<br>\n/</em> CSS3 抗锯齿形 让文字显示的更加清晰 <em>/<br>\n-webkit-font-smoothing: antialiased;<br>\nbackground-color: #fff;<br>\nfont: 12px/1.5 Microsoft YaHei, Heiti SC, tahoma, arial, Hiragino Sans GB, “\\5B8B\\4F53”, sans-serif;<br>\ncolor: #666<br>\n}<br>\n.hide,<br>\n.none {<br>\ndisplay: none<br>\n}<br>\n/</em> 清除浮动 */<br>\n.clearfix:after {<br>\nvisibility: hidden;<br>\nclear: both;<br>\ndisplay: block;<br>\ncontent: “.”;<br>\nheight: 0<br>\n}<br>\n.clearfix {<br>\n*zoom: 1<br>\n}</p>\n</blockquote>\n<h4 id=\"14css新增属性\"><a class=\"markdownIt-Anchor\" href=\"#14css新增属性\">#</a> 14.css 新增属性</h4>\n<h6 id=\"新增属性选择器\"><a class=\"markdownIt-Anchor\" href=\"#新增属性选择器\">#</a> 新增属性选择器</h6>\n<p><img src=\"images/47.png\" alt=\"photo\"></p>\n<p>通过举例进行说明<br>\n input [type=text] {}<br>\n 这个表示选出 input 中 type=text 的元素</p>\n<p>div [class^=XXX]: 选出以 XXX 开头的元素</p>\n<p>div [class$=XXX]: 选出以 XXX 结尾的元素</p>\n<h6 id=\"结构伪类选择器\"><a class=\"markdownIt-Anchor\" href=\"#结构伪类选择器\">#</a> 结构伪类选择器</h6>\n<p><img src=\"images/48.png\" alt=\"photo\"></p>\n<blockquote>\n<pre><code>xxx:firstchild\nxxx:secondchild\nxxx:nth-child(number)\n</code></pre>\n</blockquote>\n<p>都是选出第几个子元素的意思</p>\n<p><img src=\"images/49.png\" alt=\"photo\"></p>\n<p>括号里面不仅仅可以跟数字，也可以很有特殊意义的单词，甚至可以跟公式 n 将取自然数</p>\n<p>nth-of-type 选择器</p>\n<p>两个选择器的区别如下<br>\n<img src=\"images/50.png\" alt=\"photo\"><br>\n 举例子来说明:</p>\n<blockquote>\n<pre><code>&lt;p&gt;光头强&lt;/p&gt;\n&lt;div&gt;熊大&lt;/div&gt;\n&lt;div&gt;熊二&lt;/div&gt;\n</code></pre>\n</blockquote>\n<p>此时如果给一个 section div:nth-child (1) { background-color: red; } 指令，你觉得谁会被加上红色呢<br>\n答案是都不会<br>\n child 先看后面的数字 1   ，此时第一个孩子是 p，然后再来看前面的 div，发现 div 不是 P，所以不成立 谁都不给</p>\n<p>但如果给一个 section div:nth-of-type (1) {<br>\nbackground-color: blue;} 指令呢<br>\n答案是会给熊大，type 先看前面的 div，找出 div，再发现后面的 1，所以会给 div 中的第一个孩子</p>\n<h6 id=\"伪元素选择器\"><a class=\"markdownIt-Anchor\" href=\"#伪元素选择器\">#</a> 伪元素选择器</h6>\n<blockquote>\n<p>XXX::before/after {<br>\ncontent:’’;<br>\n}<br>\n 这里面的 content 是必须加的，表示里面的内容，即使你没有内容要写，也需要写出 content 否则无效，注意是单引号</p>\n</blockquote>\n<p>用处：可以里面 css 来个父元素添加盒子 词的的 before 表示出现在父元素的左边 after 表示出现在父元素的右边</p>\n<h6 id=\"css3盒子模型\"><a class=\"markdownIt-Anchor\" href=\"#css3盒子模型\">#</a> css3 盒子模型</h6>\n<p>前面我们说了 padding 和边框都会撑大盒子，所以说我们使用 border 和 padding 还需要减去其尺寸，现在我们提供了修复的方法</p>\n<blockquote>\n<p>box-sizing:  ;</p>\n</blockquote>\n<p>content-box: 按照原来会撑大盒子的方式<br>\n border-box: 会自动减去撑大的尺寸，保证盒子的尺寸不变</p>\n<h6 id=\"图片模糊处理\"><a class=\"markdownIt-Anchor\" href=\"#图片模糊处理\">#</a> 图片模糊处理</h6>\n<blockquote>\n<p>filter:blur()</p>\n</blockquote>\n<p>blur 是一个函数 小括号里面数值越大，图片越模糊 注意数值要加 px 单位</p>\n<h6 id=\"css3宽度calc函数\"><a class=\"markdownIt-Anchor\" href=\"#css3宽度calc函数\">#</a> css3 宽度 calc 函数</h6>\n<p>calc 函数主要提供了一个计算的方法<br>\n例如在有一个父盒子的前提下，子盒子写出这样一个函数 width: calc (100% - 30px); 表示在父亲 100% 尺寸的前提下始终减去 30px 的宽度</p>\n<h6 id=\"过渡效果\"><a class=\"markdownIt-Anchor\" href=\"#过渡效果\">#</a> 过渡效果</h6>\n<p>大概来说就是将一个瞬间变化的过程转化成阶段性有时间长短的变化<br>\n<img src=\"images/51.png\" alt=\"photo0\"><br>\n 在这里 0s 开始一般可以不写而省略，变化曲线也一遍使用 ease 这是最常用的变化曲线</p>\n",
            "tags": [
                "前端"
            ]
        },
        {
            "id": "http://example.com/2021/11/06/javascript-ji-chu-ban/",
            "url": "http://example.com/2021/11/06/javascript-ji-chu-ban/",
            "title": "Javascript基础(未完待续)",
            "date_published": "2021-11-05T16:00:00.000Z",
            "content_html": "<h1 id=\"javascript\"><a class=\"markdownIt-Anchor\" href=\"#javascript\">#</a> javascript</h1>\n<h2 id=\"article-by-yogmas\"><a class=\"markdownIt-Anchor\" href=\"#article-by-yogmas\">#</a> Article By Yogmas</h2>\n<h3 id=\"js的组成\"><a class=\"markdownIt-Anchor\" href=\"#js的组成\">#</a> js 的组成</h3>\n<p>1.ECNscript:JS 语法<br>\n 2.DOM: 页面文档模型<br>\n 3.BOM: 浏览器对象模型</p>\n<h4 id=\"js初体验\"><a class=\"markdownIt-Anchor\" href=\"#js初体验\">#</a> js 初体验</h4>\n<p>1. 行内式 js: 直接写到元素的内部<br>\n<img src=\"js_img/%E8%A1%8C%E5%86%85%E5%BC%8Fjs.png\" alt=\"photo\"><br>\n2. 内嵌式的 js:</p>\n<blockquote>\n<pre><code>&lt;head&gt;&lt;script&gt; &lt;/script&gt;&lt;/head&gt;\n</code></pre>\n</blockquote>\n<p>3. 外部式 js: 创建 XXX.js 文件在通过标签引出到 html 文件中<br>\n<img src=\"js_img/%E5%A4%96%E9%83%A8js.png\" alt=\"photo\"></p>\n<h4 id=\"js注释\"><a class=\"markdownIt-Anchor\" href=\"#js注释\">#</a> js 注释</h4>\n<blockquote>\n<pre><code>1.单行注释    //    ctrl + /\n2.多行注释     /*    */    shift + alt + a\n</code></pre>\n</blockquote>\n<h4 id=\"js输入输出语句\"><a class=\"markdownIt-Anchor\" href=\"#js输入输出语句\">#</a> js 输入输出语句</h4>\n<p><img src=\"js_img/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AF%AD%E5%8F%A5.png\" alt=\"photo\"></p>\n<blockquote>\n<pre><code>prompt('') 输入框 \nalert('')警示框  展示给用户的\nconsole 控制台打印的信息 给程序员看的\n</code></pre>\n</blockquote>\n<h3 id=\"变量概述\"><a class=\"markdownIt-Anchor\" href=\"#变量概述\">#</a> 变量概述</h3>\n<h4 id=\"什么是变量\"><a class=\"markdownIt-Anchor\" href=\"#什么是变量\">#</a> 什么是变量</h4>\n<p>变量是用来存放数据的容器，简而言之就是一个装东西的盒子<br>\n变量是内存中申请的一部分用来存放数据的空间</p>\n<h3 id=\"变量的使用\"><a class=\"markdownIt-Anchor\" href=\"#变量的使用\">#</a> 变量的使用</h3>\n<h4 id=\"声明变量\"><a class=\"markdownIt-Anchor\" href=\"#声明变量\">#</a> 声明变量</h4>\n<blockquote>\n<p>var age;</p>\n</blockquote>\n<p>var 是一个 js 关键字用来声明变量<br>\n age 是程序员取的名字</p>\n<h4 id=\"赋值\"><a class=\"markdownIt-Anchor\" href=\"#赋值\">#</a> 赋值</h4>\n<p>赋值就是把值存入变量中</p>\n<blockquote>\n<p>age=10</p>\n</blockquote>\n<p>这里的 = 是赋值的意思 在变量中存储一个数据</p>\n<h4 id=\"变量的初始化\"><a class=\"markdownIt-Anchor\" href=\"#变量的初始化\">#</a> 变量的初始化</h4>\n<blockquote>\n<p>var age=18;</p>\n</blockquote>\n<p>在声明变量的同时赋值给 18  使程序变得更加简便</p>\n<blockquote>\n<pre><code>var myname = prompt('请输入你的名字')\n</code></pre>\n</blockquote>\n<p>这样在弹出的对话框里面输入的名字 可以储存到变量 myname 中去</p>\n<h4 id=\"变量语法扩展\"><a class=\"markdownIt-Anchor\" href=\"#变量语法扩展\">#</a> 变量语法扩展</h4>\n<h5 id=\"更新变量\"><a class=\"markdownIt-Anchor\" href=\"#更新变量\">#</a> 更新变量</h5>\n<blockquote>\n<pre><code> var myname = 'pink';\n console.log(myname);\n  myname = '迪丽热巴';\n  console.log(myname);\n</code></pre>\n</blockquote>\n<p>这样从上到下 第一次输出的 pink 第二次输出的是迪丽热巴  变量在不断更新</p>\n<h5 id=\"声明多个变量\"><a class=\"markdownIt-Anchor\" href=\"#声明多个变量\">#</a> 声明多个变量</h5>\n<blockquote>\n<pre><code>eg:var age=18,address='火影村'\n</code></pre>\n</blockquote>\n<p>这里声明了 age 和 address 多个变量，变量与变量之间通过英文的逗号隔开</p>\n<h5 id=\"声明变量的特殊情况\"><a class=\"markdownIt-Anchor\" href=\"#声明变量的特殊情况\">#</a> 声明变量的特殊情况</h5>\n<p>1. 只声明不赋值 这时候输出的结果是 undefined (未定义的)<br>\n 2. 不声明不赋值 直接使用 浏览器会进行报错<br>\n 3. 不声明直接赋值使用 在 js 之中只可以使用的</p>\n<p>注意:js 是从上到下处理的，如果中间有错误的代码，那么错误代码下面的代码将不再被 js 处理<br>\n<img src=\"js_img/%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E7%9A%84%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5.png\" alt=\"photo\"></p>\n<h5 id=\"变量命名规范\"><a class=\"markdownIt-Anchor\" href=\"#变量命名规范\">#</a> 变量命名规范</h5>\n<p><img src=\"js_img/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83.png\" alt=\"photo\"><br>\n 尽量不要直接使用 name 作为变量名，name 在大部分浏览器中有变量含义</p>\n<h4 id=\"小结\"><a class=\"markdownIt-Anchor\" href=\"#小结\">#</a> 小结</h4>\n<p>自我问答环节<br>\n<img src=\"js_img/%E5%8F%98%E9%87%8F%E9%97%AE%E9%A2%98.png\" alt=\"photo\"><br>\n<img src=\"js_img/%E5%8F%98%E9%87%8F%E9%97%AE%E9%A2%98%E7%AD%94%E6%A1%88.png\" alt=\"photo\"></p>\n<h3 id=\"数据类型\"><a class=\"markdownIt-Anchor\" href=\"#数据类型\">#</a> 数据类型</h3>\n<h4 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\">#</a> 简介</h4>\n<p>不同的数据占用的存储空间不同，为了充分利用存储空间，于是定义了不同的数据类型.</p>\n<h4 id=\"变量的数据类型\"><a class=\"markdownIt-Anchor\" href=\"#变量的数据类型\">#</a> 变量的数据类型</h4>\n<p>js 是一种弱类型或者说动态语言，这意味着不用提前声明变量的类型，在程序运行的过程中，类型会自动确定.</p>\n<p>js 的变量数据类型是只有程序在运行过程中，根据等号右边的值来确定的.</p>\n<p>js 是动态语言，变量的数据类型是可以变化的</p>\n<blockquote>\n<p>var x = 10;x 是数字型<br>\n var x = ‘yogmas’; x 是字符串型</p>\n</blockquote>\n<h5 id=\"简单数据类型\"><a class=\"markdownIt-Anchor\" href=\"#简单数据类型\">#</a> 简单数据类型</h5>\n<p><img src=\"js_img/%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png\" alt=\"photo\"></p>\n<h6 id=\"数字型\"><a class=\"markdownIt-Anchor\" href=\"#数字型\">#</a> 数字型</h6>\n<p>1. 在我们程序里面数字前面加 0 表示 8 进制</p>\n<blockquote>\n<pre><code>eg:var num = 010 转化为10进制就是8\n</code></pre>\n</blockquote>\n<p>2. 十六进制 0~9 a~f<br>\n 在数字前面加 0x 表示 16 进制</p>\n<blockquote>\n<pre><code>eg:var num = 0xa 转外为10进制就是10\n</code></pre>\n</blockquote>\n<p>3. 数字型的最大值</p>\n<blockquote>\n<pre><code>console.log(Number.MAX_VALUE)  1.7976e+308\n</code></pre>\n</blockquote>\n<p>4. 数字型的最小值</p>\n<blockquote>\n<pre><code>console.log(Number.MIN_VALUE)  5e-324\n</code></pre>\n</blockquote>\n<p>数字型的三个特殊数值<br>\n alert (infinity) 无穷大<br>\n alert (-infinity) 无穷小<br>\n这两个数都可以通过将前面的最大数或者最小数通过加减乘除扩大或缩小得到<br>\n alert (NAN) 非数值</p>\n<p>可以通过 isNAN 用来判断非数字 并且返回一个值， 如果是数值返回的是 false 如果不是数字 返回的是 true<br>\nconsole.log(isNaN(XX));<br>\n<img src=\"js_img/%E9%AA%8C%E8%AF%81%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B0%E5%AD%97.png\" alt=\"photo\"></p>\n<h5 id=\"字符串型\"><a class=\"markdownIt-Anchor\" href=\"#字符串型\">#</a> 字符串型</h5>\n<p>字符串数据类型用单引号圈出 (字符串必须加引号，不然会提示错误)</p>\n<p>注意引号内不能内嵌引号，如果要引号内嵌，使用不同的引号 (<strong>引号判定是就近一致原则</strong>)</p>\n<blockquote>\n<pre><code>例如:var str = \"我是一个'高富帅'程序员\";\n</code></pre>\n</blockquote>\n<h6 id=\"字符串长度\"><a class=\"markdownIt-Anchor\" href=\"#字符串长度\">#</a> 字符串长度</h6>\n<p>检测获取字符串的长度 用 length</p>\n<blockquote>\n<pre><code>        var str = 'my name is andy ';\n        console.log(str.length)\n</code></pre>\n</blockquote>\n<h6 id=\"字符转义符\"><a class=\"markdownIt-Anchor\" href=\"#字符转义符\">#</a> 字符转义符</h6>\n<p><img src=\"js_img/%E5%AD%97%E7%AC%A6%E8%BD%AC%E4%B9%89%E7%AC%A6.png\" alt=\"photo\"><br>\n 都是以 \\ 开头 ，但是这些转义字符要写到引号里面</p>\n<h6 id=\"字符串的拼接\"><a class=\"markdownIt-Anchor\" href=\"#字符串的拼接\">#</a> 字符串的拼接</h6>\n<blockquote>\n<pre><code>console.log ('' + '' + '')字符串之间通过加号连接\neg:console.log ('沙漠'+'骆驼 ') = '沙漠骆驼'\nconsole.log ('12' + 12) 最后为1212  这是字符串的相加   \nconsole.log (12 + 12) 最后为24   这是数字型的相加\n</code></pre>\n</blockquote>\n<p>只要有一个是字符串 其他全部都会以字符串相连<br>\n<strong>数字相加，字符相连</strong></p>\n<h6 id=\"字符串拼接加强\"><a class=\"markdownIt-Anchor\" href=\"#字符串拼接加强\">#</a> 字符串拼接加强</h6>\n<p>通过改变变量中的值 来改变显示中的值</p>\n<blockquote>\n<pre><code>eg:var age = 18;\n   console.log('pink老师'+age+'岁')\n</code></pre>\n</blockquote>\n<p>需要注意的时，<strong>变量不要写到字符串里面，是通过和字符串相连的方式实现的</strong></p>\n<blockquote>\n<pre><code>  console.log ('pink老师age岁')\n  console.log ('pink老师'+'age'+'岁')\n  console.log ('pink老师'+'age岁')\n</code></pre>\n</blockquote>\n<p>如上这些等等做法，都是不能实现的.<br>\n<img src=\"js_img/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E5%8A%A0%E5%BC%BA.png\" alt=\"photo\"></p>\n<p>交互编程：</p>\n<p>用户输入 → 处理 → 输出</p>\n<blockquote>\n<pre><code>eg         var age = prompt('请输入您的年龄');\n           var str = '你今年已经' + age + '岁了';\n           alert(str);\n</code></pre>\n</blockquote>\n<h5 id=\"布尔型boolean\"><a class=\"markdownIt-Anchor\" href=\"#布尔型boolean\">#</a> 布尔型 Boolean</h5>\n<p>布尔型中有两个值 true 和 false</p>\n<blockquote>\n<pre><code>eg         var flag = true; 布尔型\n           var flag1 = false; 布尔型\n</code></pre>\n</blockquote>\n<p>需要注意的是参与加法运算时布尔型 true 就是 1，false 就是 0.</p>\n<h5 id=\"undefined-和null\"><a class=\"markdownIt-Anchor\" href=\"#undefined-和null\">#</a> Undefined 和 Null</h5>\n<p>如果一个变量声明未赋值 就是 undefined 未定义数据类型</p>\n<blockquote>\n<pre><code>   eg: var str;\n       console.log(var);\n</code></pre>\n</blockquote>\n<p>未定义和字符串相加，最终的结果是 undefined+ 字符串的内容</p>\n<p>undefined 和数字相加 最后得到的结果是 NaN: not a number</p>\n<p>null : 空值</p>\n<blockquote>\n<pre><code>var space = null\nconsole.log(space + 'yogmas')  输出的结果是 spaceyogmas\nconsole.log(space + 1) 输出的结果是1  (和undefined区别)\n</code></pre>\n</blockquote>\n<h4 id=\"获取变量数据类型\"><a class=\"markdownIt-Anchor\" href=\"#获取变量数据类型\">#</a> 获取变量数据类型</h4>\n<h5 id=\"使用typeof来检测\"><a class=\"markdownIt-Anchor\" href=\"#使用typeof来检测\">#</a> 使用 typeof 来检测</h5>\n<blockquote>\n<pre><code>   eg:   var num = 10;\n         console.log(typeof num);\n</code></pre>\n</blockquote>\n<p>比较特殊的是 在这里对 null 进行数据类型检测 输出来的是 object (对象)</p>\n<p>经过检测发现 我们 prompt 取过来的值是字符型的</p>\n<h5 id=\"观察控制台中的数据颜色\"><a class=\"markdownIt-Anchor\" href=\"#观察控制台中的数据颜色\">#</a> 观察控制台中的数据颜色</h5>\n<p>数字型 浅蓝色<br>\n字符型 黑色<br>\n布尔型 深蓝色<br>\n undefined 和 null 灰色</p>\n<h4 id=\"字面量\"><a class=\"markdownIt-Anchor\" href=\"#字面量\">#</a> 字面量</h4>\n<p>字面量是在源代码中一个固定值得表示法，通俗来说，就是字面量表示如何表达这个值<br>\n<img src=\"js_img/%E8%87%AA%E5%8F%98%E9%87%8F%E5%9F%BA%E6%9C%AC.png\" alt=\"photo\"></p>\n<h4 id=\"数据类型转换\"><a class=\"markdownIt-Anchor\" href=\"#数据类型转换\">#</a> 数据类型转换</h4>\n<p>通常会实现 3 中方式的转换<br>\n 1. 转换为字符串类型<br>\n 2. 转换为数字型<br>\n 3. 转换为布尔型</p>\n<h5 id=\"转换成字符串型\"><a class=\"markdownIt-Anchor\" href=\"#转换成字符串型\">#</a> 转换成字符串型</h5>\n<p><img src=\"js_img/%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2.png\" alt=\"photo\"></p>\n<blockquote>\n<pre><code>var num = 18;\nconsole.log(num.toString())\nconsole.log(String(num))\nconsole.log(num + '')\n</code></pre>\n</blockquote>\n<p>注意:toString () 和 String () 的使用方法不同<br>\n三种方法中 其中拼接转换字符串最为实用</p>\n<h5 id=\"转换为数字型重点\"><a class=\"markdownIt-Anchor\" href=\"#转换为数字型重点\">#</a> 转换为数字型 (重点)</h5>\n<p><img src=\"js_img/%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97%E5%9E%8B.png\" alt=\"photo\"><br>\n 其中前两个较为实用<br>\n 1.parseInt (变量) 可以把字符型的转换为数字型 但是得到的是整数 并且约分不会四舍五入，会直接去掉小数点后面的数字 如果数字后面有单位，也会去掉单位，如果以字母开头那么输出的为 NaN<br>\n2.paseFloat (变量) 可以把字符型的转化为数字型，得到的是浮点数也就是小数，但同样也会把后面的单位去掉<br>\n 3.Number (变量)<br>\n 4. 利用了算数运算 - * / 隐式转换<br>\n<img src=\"js_img/%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B0%E5%AD%97%E5%9E%8B%E5%AE%9E%E4%BE%8B.png\" alt=\"photo\"></p>\n<blockquote>\n<pre><code>   console.log(parseInt('123'));\n   console.log(parseFloat('123'));\n   console.log(Number('123'));\n   console.log('12' - 0);\n   console.log('123' - '123');\n   console.log('123' * 1);\n</code></pre>\n</blockquote>\n<h5 id=\"转化为布尔型\"><a class=\"markdownIt-Anchor\" href=\"#转化为布尔型\">#</a> 转化为布尔型</h5>\n<p>代表<strong>空，否定</strong>的值会被转化为 false，如’’,0,NaN,null,undefined. 其他的值都会被转化成 true<br>\n<img src=\"js_img/%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%B8%83%E5%B0%94%E5%9E%8B.png\" alt=\"photo\"></p>\n<blockquote>\n<pre><code>eg: console.log(Boolean(''));      这是false\n</code></pre>\n</blockquote>\n<h4 id=\"解释型语言和编译型语言\"><a class=\"markdownIt-Anchor\" href=\"#解释型语言和编译型语言\">#</a> 解释型语言和编译型语言</h4>\n<p>编译型语言：全部编译成功后再执行代码.(做好菜 再吃饭)<br>\n 解释型语言：解释一行代码后就执行一行代码.(吃火锅：边吃边涮)</p>\n<h4 id=\"标识符关键字保留字\"><a class=\"markdownIt-Anchor\" href=\"#标识符关键字保留字\">#</a> 标识符，关键字，保留字</h4>\n<p>标识符：开发人员为变量，属性，函数，参数取的名字<br>\n<strong>标识符不能是关键字和保留字</strong><br>\n关键字：是指 js 本身已经使用了子，不能充当变量名和方法名<br>\n<img src=\"js_img/%E5%85%B3%E9%94%AE%E5%AD%97.png\" alt=\"photo\"><br>\n 保留字：预留的关键字，未来可能会成为关键字<br>\n<img src=\"js_img/%E4%BF%9D%E7%95%99%E5%AD%97.png\" alt=\"photo\"></p>\n<h3 id=\"运算符\"><a class=\"markdownIt-Anchor\" href=\"#运算符\">#</a> 运算符</h3>\n<h4 id=\"算数运算符\"><a class=\"markdownIt-Anchor\" href=\"#算数运算符\">#</a> 算数运算符</h4>\n<p><img src=\"js_img/%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6.png\" alt=\"photo\"><br>\n 需要注意的是浮点数在算数运算里面会有问题 (会有一定的误差)</p>\n<blockquote>\n<pre><code>eg:console.log(0.07*100); 最终的结果是7.000000000000001\n</code></pre>\n</blockquote>\n<p><img src=\"js_img/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98.png\" alt=\"photo\"><br>\n 我们不能拿着浮点数来进行相比较是否相等</p>\n<h5 id=\"表达式返回值\"><a class=\"markdownIt-Anchor\" href=\"#表达式返回值\">#</a> 表达式，返回值</h5>\n<p>由数字，运算符，变量等组成的式子</p>\n<p>在程序中的计算是把右边表达式计算完毕把返回值给左边</p>\n<p>式子通过计算得到的结果 称为返回值</p>\n<h4 id=\"自增和自减运算符\"><a class=\"markdownIt-Anchor\" href=\"#自增和自减运算符\">#</a> 自增和自减运算符</h4>\n<p>反复用给数字变量添加或者减去 1，可以用 ++ 或者–来实现<br>\n在 js 中，自增自减运算符既可以放在变量前面又可以放在变量后面，称为前置或者后置.<br>\n 需要注意的是 这个运算符必须和变量配合才能使用<br>\n前置和后置有区别的是，前置表示先自增或自减再返回，后置表示先返回再自增或自减<br>\n<img src=\"js_img/%E9%80%92%E5%A2%9E%E5%92%8C%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6.png\" alt=\"photo\"></p>\n<h4 id=\"比较运算符关系运算符\"><a class=\"markdownIt-Anchor\" href=\"#比较运算符关系运算符\">#</a> 比较运算符 &amp; 关系运算符</h4>\n<p><img src=\"js_img/%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6.png\" alt=\"photo\"><br>\n<img src=\"js_img/%E7%AD%89%E5%8F%B7%E5%B0%8F%E7%BB%93.png\" alt=\"photo\"></p>\n<h4 id=\"逻辑运算符\"><a class=\"markdownIt-Anchor\" href=\"#逻辑运算符\">#</a> 逻辑运算符</h4>\n<p><img src=\"images/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6.png\" alt=\"photo\"></p>\n<h5 id=\"短路运算逻辑中断\"><a class=\"markdownIt-Anchor\" href=\"#短路运算逻辑中断\">#</a> 短路运算 (逻辑中断)</h5>\n<p>原理：左边表达式的值可以确定结果时，就不再继续运算右边的值</p>\n<p>逻辑与：如果表达式 1 结果为真，则返回表达式 2. 如果表达式 1 结果为假，则返回表达式 1<br>\n<img src=\"js_img/%E9%80%BB%E8%BE%91%E4%B8%8E%E7%9F%AD%E8%B7%AF.png\" alt=\"photo\"><br>\n<img src=\"js_img/%E9%80%BB%E8%BE%91%E4%B8%8E%E7%9F%AD%E8%B7%AF%E5%AE%9E%E4%BE%8B.png\" alt=\"photo\"><br>\n 逻辑或：如果表达式 1 结果为真，则返回表达式 1. 如果表达式 1 结果为假，则返回表达式 2.<br>\n<img src=\"js_img/%E9%80%BB%E8%BE%91%E6%88%96%E7%9A%84%E9%80%BB%E8%BE%91%E4%B8%AD%E6%96%AD.png\" alt=\"photo\"></p>\n<h5 id=\"赋值运算符\"><a class=\"markdownIt-Anchor\" href=\"#赋值运算符\">#</a> 赋值运算符</h5>\n<p>把右边的数据赋给左边的变量<br>\n<img src=\"js_img/%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6.png\" alt=\"photo\"></p>\n<h5 id=\"运算符优先级\"><a class=\"markdownIt-Anchor\" href=\"#运算符优先级\">#</a> 运算符优先级</h5>\n<p><img src=\"js_img/%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7.png\" alt=\"photo\"><br>\n 注意逻辑与的权重大于逻辑或的权重</p>\n<h3 id=\"流程控制-分支\"><a class=\"markdownIt-Anchor\" href=\"#流程控制-分支\">#</a> 流程控制 - 分支</h3>\n<h4 id=\"流程控制\"><a class=\"markdownIt-Anchor\" href=\"#流程控制\">#</a> 流程控制</h4>\n<p>控制代码按照什么结构顺序来执行</p>\n<p>流程控制有三种结构，分别是顺序结构，分支结构和循环结构<br>\n<img src=\"js_img/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.png\" alt=\"photo\"></p>\n<h5 id=\"顺序流程控制\"><a class=\"markdownIt-Anchor\" href=\"#顺序流程控制\">#</a> 顺序流程控制</h5>\n<p>按照写的代码的顺序从上到下执行，我们现在的代码大多数都是按照顺序流程控制来写的</p>\n<h5 id=\"分支流程控制\"><a class=\"markdownIt-Anchor\" href=\"#分支流程控制\">#</a> 分支流程控制</h5>\n<p>从上到下执行代码的过程中，根据不同的条件，执行不同的路径代码，从而得到不同的结果</p>\n<h4 id=\"if分支语句\"><a class=\"markdownIt-Anchor\" href=\"#if分支语句\">#</a> if 分支语句</h4>\n<blockquote>\n<pre><code>if (条件表达式) {执行语句}\n</code></pre>\n</blockquote>\n<p>如果条件表达式结果为真就执行大括号里面的执行语句<br>\n如果条件表达式结果为假就执行 if 语句后面的代码<br>\n<img src=\"js_img/if%E8%AF%AD%E5%8F%A5.png\" alt=\"photo\"><br>\n<img src=\"js_img/if%E8%AF%AD%E5%8F%A5%E6%B5%81%E7%A8%8B.png\" alt=\"photo\"></p>\n<h5 id=\"if-else-双分支语句\"><a class=\"markdownIt-Anchor\" href=\"#if-else-双分支语句\">#</a> if else 双分支语句</h5>\n<p><img src=\"js_img/if%20else.png\" alt=\"photo\"><br>\n 如果表达式结果为真，那么执行语句 1 否则执行语句 2<br>\n 语句 1 和语句 2 只能二选一执行<br>\n else 后面直接加大括号而不是小括号<br>\n<img src=\"js_img/if,else%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png\" alt=\"photo\"></p>\n<h5 id=\"if-else-多分支语句\"><a class=\"markdownIt-Anchor\" href=\"#if-else-多分支语句\">#</a> if else 多分支语句</h5>\n<p>利用多个条件来选择不同的语句执行，得到不同的结果，是多选 1 的过程</p>\n<p>语法规范:<br>\nif (条件表达式 1) {</p>\n<p>} else if (条件表达式 2) {</p>\n<p>} else if …{</p>\n<p>} else {<br>\n最后的语句<br>\n}<br>\n 如果条件表达式 1 满足就执行语句 1，执行完毕后退出整个 if 分支语句<br>\n如果条件 1 不满足就判断表达式 2 以此类推<br>\n如果全都不成立，则执行最后的 else 里面的语句<br>\n注意<br>\n 1. 多分支语句还是多选 1 最后只有 1 个语句能执行<br>\n 2.else if 里面的条件理论上是可以任意多个的<br>\n 3.else if 中间有个空格<br>\n<img src=\"js_img/if%20else%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png\" alt=\"photo\"></p>\n<h4 id=\"三元表达式\"><a class=\"markdownIt-Anchor\" href=\"#三元表达式\">#</a> 三元表达式</h4>\n<p>有三元运算符组成的式子我们称为三元表达式</p>\n<p>条件表达式 1? 表达式 1: 表达式 2</p>\n<p>如果条件表达式结果为真，则返回表达式 1 的值，如果条件表达式的结果为假，则返回表达式 2 的值</p>\n<h4 id=\"switch语句\"><a class=\"markdownIt-Anchor\" href=\"#switch语句\">#</a> switch 语句</h4>\n<p>也是多分支语句可以实现多选 1 的效果<br>\n<img src=\"js_img/switch%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84.png\" alt=\"photo\"><br>\n 语法结构:<br>\nswitch (表达式) {<br>\ncase value1:<br>\n 执行语句 1;<br>\nbreak;<br>\ncase value2:<br>\n 执行语句 2;<br>\nbreak;<br>\n…………<br>\ndefault :<br>\n 执行最后的语句；<br>\n}<br>\n 利用表达式的值和 case 里面的选项匹配如果匹配上就执行相应的 case 里面的值，如果都没有匹配上就执行 default 里面的语句<br>\n<img src=\"js_img/switch%E8%AF%AD%E5%8F%A5%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.png\" alt=\"photo\"></p>\n<h4 id=\"switch语句和-if-else-if语句的区别\"><a class=\"markdownIt-Anchor\" href=\"#switch语句和-if-else-if语句的区别\">#</a> switch 语句和 if else if 语句的区别</h4>\n<p>一般情况下，他们两个语句可以相互替换<br>\n switch…case 语句 一般在 case 为比较固定值得情况下而 if…else 语句一般来判断范围<br>\n switch 判断时直接跳到判断语句上而 if 语句从上往下一次判断，这样 switch 语句的效率更高一点，但是如果分支少的话 if else if 的效率会更高一点，分支多的时候 switch 语句的效率更高<br>\n<img src=\"js_img/5.3%E4%BD%9C%E4%B8%9A.png\" alt=\"photo\"></p>\n<h3 id=\"流程控制-循环\"><a class=\"markdownIt-Anchor\" href=\"#流程控制-循环\">#</a> 流程控制 - 循环</h3>\n<p>可以反复不断地循环执行某些代码</p>\n<h4 id=\"for循环\"><a class=\"markdownIt-Anchor\" href=\"#for循环\">#</a> for 循环</h4>\n<p>for 循环重复执行某些代码，通常和计数有关<br>\n被重复的语句称为循环体，是否重复执行取决于循环的终止条件，由循环体及循环的终止条件<br>\n初始化变量 就是用 var 声明的一个普通变量，通常用于作为计数器使用<br>\n条件表达式 就是用来决定每一次循环是否继续执行 就是终止的条件<br>\n操作表达式 是每次循环最后执行的代码，经常用来对我们的计数器进行更新 (递增或者递减)</p>\n<h5 id=\"断点调试\"><a class=\"markdownIt-Anchor\" href=\"#断点调试\">#</a> 断点调试</h5>\n<p>自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看着各个变量当前的值，出错的话，调试到出错的代码行及硻错误，停下.</p>\n<p>在浏览器调试中的 source 中可以进行断点调试<br>\n<img src=\"js_img/%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95.png\" alt=\"photo\"></p>\n<h5 id=\"for循环重复相同的代码\"><a class=\"markdownIt-Anchor\" href=\"#for循环重复相同的代码\">#</a> for 循环重复相同的代码</h5>\n<blockquote>\n<pre><code>   var num = prompt('请输入重复的次数');\n   for (i = 1; i &lt;= num; i++) {\n   console.log('你是大傻逼');\n   }\n</code></pre>\n</blockquote>\n<h5 id=\"for循环重复不同的代码\"><a class=\"markdownIt-Anchor\" href=\"#for循环重复不同的代码\">#</a> for 循环重复不同的代码</h5>\n<p>循环可以重复执行不同的代码，因为计数器变量 i 的存在 i 每次循环值都会变化</p>\n<blockquote>\n<pre><code>   for (var i = 1; i &lt;= 100; i++) {\n   console.log('这个人今年' + i + '岁了');\n   }\n</code></pre>\n</blockquote>\n<h5 id=\"for循环重复相同的操作\"><a class=\"markdownIt-Anchor\" href=\"#for循环重复相同的操作\">#</a> for 循环重复相同的操作</h5>\n<p>例如:</p>\n<blockquote>\n<pre><code>   var sum = 0, aver = 0;\n   for (var i = 1; i &lt;= 100; i++) {\n   sum += i\n   }\n   aver = sum / i\n   console.log(aver);\n</code></pre>\n</blockquote>\n<h5 id=\"双重for循环\"><a class=\"markdownIt-Anchor\" href=\"#双重for循环\">#</a> 双重 for 循环</h5>\n<p>也就是 for 循环嵌套，在一个循环语句中 再定义一个循环语句.</p>\n<blockquote>\n<pre><code>for (外层的初始化变量;外层的条件表达式;外层的操作表达式) {\n     for (初始化变量;条件表达式;操作表达式){\n     }\n     }\n</code></pre>\n</blockquote>\n<p>里层的循环可以看成是外层循环的语句</p>\n<h5 id=\"for循环小结\"><a class=\"markdownIt-Anchor\" href=\"#for循环小结\">#</a> for 循环小结</h5>\n<p><img src=\"js_img/for%E5%BE%AA%E7%8E%AF%E5%B0%8F%E7%BB%93.png\" alt=\"photo\"></p>\n<h4 id=\"while循环\"><a class=\"markdownIt-Anchor\" href=\"#while循环\">#</a> while 循环</h4>\n<p><img src=\"js_img/while%E5%BE%AA%E7%8E%AF.png\" alt=\"photo\"></p>\n<p>条件表达式结果为 true 则执行循环体 否则 退出循环</p>\n<p>while 循环中应该也有计数器初始化变量，也该有操作表达式完成计数器的更新防止死循环</p>\n<h4 id=\"do-while-循环\"><a class=\"markdownIt-Anchor\" href=\"#do-while-循环\">#</a> do while 循环</h4>\n<p>语法结构</p>\n<blockquote>\n<p>do {循环体} while (条件表达式)</p>\n</blockquote>\n<p>执行思路不同的地方跟 while 在于 do whild 先执行一遍循环体再判断条件<br>\n do while 语句至少执行一次循环体</p>\n<p><img src=\"js_img/do%20while.png\" alt=\"photo\"></p>\n<h4 id=\"循环小结\"><a class=\"markdownIt-Anchor\" href=\"#循环小结\">#</a> 循环小结</h4>\n<p><img src=\"js_img/%E5%BE%AA%E7%8E%AF%E5%B0%8F%E7%BB%93.png\" alt=\"photo\"></p>\n<h3 id=\"continue关键字\"><a class=\"markdownIt-Anchor\" href=\"#continue关键字\">#</a> continue 关键字</h3>\n<p>用于立即跳出本次循环，继续下一次循环.</p>\n<h3 id=\"break关键字\"><a class=\"markdownIt-Anchor\" href=\"#break关键字\">#</a> break 关键字</h3>\n<p>break 退出整个循环，使循环立马结束</p>\n<h3 id=\"命名规范\"><a class=\"markdownIt-Anchor\" href=\"#命名规范\">#</a> 命名规范</h3>\n<h4 id=\"标志符命名规范\"><a class=\"markdownIt-Anchor\" href=\"#标志符命名规范\">#</a> 标志符命名规范</h4>\n<p><img src=\"js_img/%E6%A0%87%E5%BF%97%E7%AC%A6%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83.png\" alt=\"photo\"></p>\n<h4 id=\"操作符规范\"><a class=\"markdownIt-Anchor\" href=\"#操作符规范\">#</a> 操作符规范</h4>\n<p>操作符左右两侧各保留一个空格<br>\n单行注释在 // 后面敲个空格</p>\n<h4 id=\"循环作业\"><a class=\"markdownIt-Anchor\" href=\"#循环作业\">#</a> 循环作业</h4>\n<p><img src=\"js_img/%E5%BE%AA%E7%8E%AF%E4%BD%9C%E4%B8%9A.png\" alt=\"photo\"></p>\n<h3 id=\"javascript数组\"><a class=\"markdownIt-Anchor\" href=\"#javascript数组\">#</a> javascript 数组</h3>\n<h4 id=\"数组的概念\"><a class=\"markdownIt-Anchor\" href=\"#数组的概念\">#</a> 数组的概念</h4>\n<p>数组是一组数据的集合，其中每个数据都被称为元素，在数组中可以存放任何类型的元素，数组是可以将数据存储在单个变量下的优雅方式</p>\n<h4 id=\"创建数组\"><a class=\"markdownIt-Anchor\" href=\"#创建数组\">#</a> 创建数组</h4>\n<p>1.new 创建数组<br>\n 2. 利用数组关键字创造数组</p>\n<h5 id=\"利用new创建数组\"><a class=\"markdownIt-Anchor\" href=\"#利用new创建数组\">#</a> 利用 new 创建数组</h5>\n<p><img src=\"js_img/new%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84.png\" alt=\"photo\"><br>\n 注意 Array 的 A 要大写</p>\n<h5 id=\"利用数组字面量创建数组\"><a class=\"markdownIt-Anchor\" href=\"#利用数组字面量创建数组\">#</a> 利用数组字面量创建数组</h5>\n<p>[] 是数组的的字面量</p>\n<blockquote>\n<p>var arr = [];<br>\n 这样便创建了一个空的数组<br>\n var arr = [1,1,2,3,‘pink’,true]</p>\n</blockquote>\n<p>在数组内可以放任何的数据类型，但是每一个数据之间必须用逗号分隔.</p>\n<h4 id=\"获取数组元素\"><a class=\"markdownIt-Anchor\" href=\"#获取数组元素\">#</a> 获取数组元素</h4>\n<h5 id=\"数组的索引\"><a class=\"markdownIt-Anchor\" href=\"#数组的索引\">#</a> 数组的索引</h5>\n<p>索引又被称为下标：用来访问数组元素的序号 (数组下标从 0 开始)<br>\n<img src=\"js_img/%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%8B%E6%A0%87.png\" alt=\"photo\"></p>\n<blockquote>\n<pre><code> 数组名[索引号]\n console.log(arr[1])\n</code></pre>\n</blockquote>\n<p><strong>索引号从 0 开始</strong><br>\n如果没有该数组元素 就会输出 undefined</p>\n<h4 id=\"遍历数组\"><a class=\"markdownIt-Anchor\" href=\"#遍历数组\">#</a> 遍历数组</h4>\n<p>遍历：就是把数组中的每个元素从头到尾访问一次</p>\n<blockquote>\n<pre><code>eg:var arr = [1, 2, 3, 4, 5, 'pink'];\n   for (i = 0; i &lt; 6; i++) {\n   console.log(arr[i]);\n   }\n</code></pre>\n</blockquote>\n<p>输出的时候计数器当索引号来用</p>\n<h5 id=\"数组长度\"><a class=\"markdownIt-Anchor\" href=\"#数组长度\">#</a> 数组长度</h5>\n<p>数组名.length  可以访问数组中的数组元素的数量</p>\n<blockquote>\n<pre><code>console.log(arr.length);\n</code></pre>\n</blockquote>\n<p>同时 数组名.length 可以动态检测数组元素的个数</p>\n<h4 id=\"数组中新增元素\"><a class=\"markdownIt-Anchor\" href=\"#数组中新增元素\">#</a> 数组中新增元素</h4>\n<h5 id=\"通过修改length长度新增数组长度\"><a class=\"markdownIt-Anchor\" href=\"#通过修改length长度新增数组长度\">#</a> 通过修改 length 长度新增数组长度</h5>\n<blockquote>\n<pre><code>   var arr = ['pink', 'red', 'blue'];\n   arr.length = 5\n</code></pre>\n</blockquote>\n<p>如果扩容的数组元素中没有给值，其中的元素是 undefined</p>\n<h5 id=\"修改索引号-增加数组元素\"><a class=\"markdownIt-Anchor\" href=\"#修改索引号-增加数组元素\">#</a> 修改索引号 增加数组元素</h5>\n<blockquote>\n<pre><code>var arr = ['pink', 'red', 'blue'];\narr[3] = 'pink'\n</code></pre>\n</blockquote>\n<p>如果这个索引号原先已经被占用，就会替换原来的数组元素<br>\n<strong>不要直接给数组名赋值，否则会覆盖掉以前的数据，导致数据一个都没有了</strong></p>\n<h4 id=\"筛选数组的方法\"><a class=\"markdownIt-Anchor\" href=\"#筛选数组的方法\">#</a> 筛选数组的方法</h4>\n<h5 id=\"方法1\"><a class=\"markdownIt-Anchor\" href=\"#方法1\">#</a> 方法 1</h5>\n<blockquote>\n<pre><code>   var arr = [1, 2, 3, 4, 5, 6, 8, 11, 45, 13, 48, 46, 13];\n   var newArr = [];\n   var j = 0;\n   for (var i = 0; i &lt; arr.length; i++) {\n       if (arr[i] &gt; 10) {\n           newArr[j] = arr[i]\n           j++\n       }\n   }\n   console.log(newArr);\n</code></pre>\n</blockquote>\n<p>这里通过声明一个变量 j 来使新数组从 0 开始</p>\n<h5 id=\"方法2\"><a class=\"markdownIt-Anchor\" href=\"#方法2\">#</a> 方法 2</h5>\n<blockquote>\n<pre><code>   var arr = [1, 2, 3, 4, 5, 6, 8, 11, 45, 13, 48, 46, 13];\n   var newArr = [];\n   for (var i = 0; i &lt; arr.length; i++) {\n       if (arr[i] &gt; 10) {\n           newArr[newArr.length] = arr[i]\n       }\n   }\n   console.log(newArr);\n</code></pre>\n</blockquote>\n<p>将 j 替换成 newArr, 最开始当新数组里面没有元素时是 0，当有元素时 newArr.length 开始不断增多</p>\n<h4 id=\"翻转数组\"><a class=\"markdownIt-Anchor\" href=\"#翻转数组\">#</a> 翻转数组</h4>\n<blockquote>\n<pre><code>   var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n   var newArr = [];\n   for (i = arr.length - 1; i &gt;= 0; i--) {\n       newArr[newArr.length] = arr[i]\n   }\n   console.log(newArr);\n</code></pre>\n</blockquote>\n<p>这里需要注意的是：元素的索引号的最大值等于数组长度 - 1</p>\n<h4 id=\"冒泡排序\"><a class=\"markdownIt-Anchor\" href=\"#冒泡排序\">#</a> 冒泡排序</h4>\n<p>是一种算法，把一系列数组按照一定的顺序进行排列显示 (从小到大或者从大到小)<br>\n 算法：观察执行过程，从而找到其中的规律，并且找到代码</p>\n<blockquote>\n<pre><code>   var arr = [1, 5, 4, 3, 2];\n   for (var i = 0; i &lt; arr.length - 1; i++) { // 外层循环次数\n       for (var j = 0; j &lt; arr.length - i - 1; j++) { // 内层循环次数\n           if (arr[j] &gt; arr[j + 1]) {\n               var temp = arr[j]\n               arr[j] = arr[j + 1]\n               arr[j + 1] = temp\n           }\n       }\n   }\n</code></pre>\n</blockquote>\n<h3 id=\"javascript函数\"><a class=\"markdownIt-Anchor\" href=\"#javascript函数\">#</a> javascript 函数</h3>\n<h4 id=\"函数的概念\"><a class=\"markdownIt-Anchor\" href=\"#函数的概念\">#</a> 函数的概念</h4>\n<p>js 中经常会定义相同的代码，这些代码可能会大量使用<br>\n函数：就是封装了一段可被重复调用执行的代码块，通过调用代码块可以实现大量代码的重复使用.</p>\n<h4 id=\"函数的使用\"><a class=\"markdownIt-Anchor\" href=\"#函数的使用\">#</a> 函数的使用</h4>\n<p>步骤：1. 声明函数 2. 调用函数</p>\n<h5 id=\"声明函数\"><a class=\"markdownIt-Anchor\" href=\"#声明函数\">#</a> 声明函数</h5>\n<blockquote>\n<pre><code>function 函数名() {函数体}\n</code></pre>\n</blockquote>\n<p>注意事项：1.function 声明函数的关键字 全部小写 2. 函数是做某件事情，函数名一般是动词 3. 函数不调用自己不会执行</p>\n<h5 id=\"调用函数\"><a class=\"markdownIt-Anchor\" href=\"#调用函数\">#</a> 调用函数</h5>\n<blockquote>\n<pre><code>函数名();\n</code></pre>\n</blockquote>\n<p>调用函数时，千万不要忘了加小括号.</p>\n<h5 id=\"函数的参数\"><a class=\"markdownIt-Anchor\" href=\"#函数的参数\">#</a> 函数的参数</h5>\n<p>我们可以利用函数的参数实现函数重复不同的代码<br>\n参数: 1. 形参 2. 实参<br>\n<img src=\"js_img/%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E5%88%86%E7%B1%BB.png\" alt=\"photo\"></p>\n<blockquote>\n<pre><code>function (形参1,形参2,....) {  在声明函数的小括号里面是形参\n }\n函数名(实参1,实参2...)     在函数调用的小括号里面是实参\n</code></pre>\n</blockquote>\n<p>形参类似于一个变量来接受实参的<br>\n函数的参数可以有也可以没有，个数不限<br>\n多个参数之间用逗号隔开</p>\n<h6 id=\"函数形参实参个数匹配\"><a class=\"markdownIt-Anchor\" href=\"#函数形参实参个数匹配\">#</a> 函数形参实参个数匹配</h6>\n<p>1. 如果实参的个数和形参的个数一直，则正常输出结果<br>\n 2. 如果实参的个数多于形参的个数，会取到形参的个数，实参中多的自动忽略<br>\n 3. 如果实参的个数小于形参的个数，num2 可以看做一个变量但是没有接收值，所以最终的结果就是 undefined<br>\n<img src=\"js_img/%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82%E7%9A%84%E4%B8%AA%E6%95%B0%E5%8C%B9%E9%85%8D.png\" alt=\"photo\"></p>\n<h6 id=\"函数参数小结\"><a class=\"markdownIt-Anchor\" href=\"#函数参数小结\">#</a> 函数参数小结</h6>\n<p><img src=\"js_img/%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E5%B0%8F%E7%BB%93.png\" alt=\"photo\"></p>\n<h5 id=\"函数的返回值\"><a class=\"markdownIt-Anchor\" href=\"#函数的返回值\">#</a> 函数的返回值</h5>\n<h6 id=\"return语句\"><a class=\"markdownIt-Anchor\" href=\"#return语句\">#</a> return 语句</h6>\n<p>函数只是实现某种功能，最终的结果需要返回给函数的调用者函数名 () 通过 return 实现<br>\n只要函数遇到 return 就把后面的结果返回给函数的调用者 函数名 ()=return 后面的结果</p>\n<blockquote>\n<pre><code> function 函数名() {\n       return 需要返回的结果;\n }\n 函数名();\n</code></pre>\n</blockquote>\n<p>代码验证</p>\n<blockquote>\n<pre><code>   function getSum(num1, num2) {\n       return num1 + num2;\n   }\n   console.log(getSum(1, 3));\n</code></pre>\n</blockquote>\n<p>这样输出的结果就是 4 (来自于 1+3)</p>\n<p>return 终止函数：函数遇到 return 就终止函数<br>\n return 的返回值:return 只能返回一个值，如果有多个值，return 只返回最后一个值<br>\n如果想要返回多个数值时，我们可以将数值放在一个数组里面，一个数组代表一个结果<br>\n函数如果 return 则返回的是 return 后面的值，如果函数没有 return 就返回 undefined<br>\nbreak,continue,return 的区别:<br>\n<img src=\"js_img/break,return.continue%E7%9A%84%E5%8C%BA%E5%88%AB.png\" alt=\"photo\"></p>\n<h4 id=\"函数的理解\"><a class=\"markdownIt-Anchor\" href=\"#函数的理解\">#</a> 函数的理解</h4>\n<p><img src=\"js_img/%E6%A6%A8%E6%B1%81%E6%9C%BA%E7%9C%8B%E9%80%8F%E5%87%BD%E6%95%B0.png\" alt=\"photo\"></p>\n<h4 id=\"函数的作业\"><a class=\"markdownIt-Anchor\" href=\"#函数的作业\">#</a> 函数的作业</h4>\n<p><img src=\"js_img/%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E4%B8%9A.png\" alt=\"photo\"></p>\n<h4 id=\"arguments的作用\"><a class=\"markdownIt-Anchor\" href=\"#arguments的作用\">#</a> arguments 的作用</h4>\n<p>当我们不确定有多少个参数传递时，可以用 argument 在获取，他实际上是当前函数的一个内置对象，arguements 存储了传递过来的所有实参</p>\n<p>arguments 实际上是伪数组.<br>\n 伪数组:<br>\n1. 具有数组的 length 属性.<br>\n2. 按照索引的方式进行存储.<br>\n3. 没有真正数组的一些方法:pop () 等</p>\n<h4 id=\"函数可以调用另外一个函数\"><a class=\"markdownIt-Anchor\" href=\"#函数可以调用另外一个函数\">#</a> 函数可以调用另外一个函数</h4>\n<h4 id=\"函数的两种声明方式\"><a class=\"markdownIt-Anchor\" href=\"#函数的两种声明方式\">#</a> 函数的两种声明方式</h4>\n<p>1. 利用函数关键字自定义函数</p>\n<blockquote>\n<pre><code>function fn() {\n}\nfn()\n</code></pre>\n</blockquote>\n<p>也被称为命名函数</p>\n<p>2. 函数表达式</p>\n<blockquote>\n<pre><code>var 变量名 = function() {}\n</code></pre>\n</blockquote>\n<p>又被叫做匿名函数<br>\n这是变量名不是函数名<br>\n函数表达式声明方式跟声明变量差不多，只不过变量里面存的是值，而函数表达式里面存的是函数。</p>\n<h3 id=\"作用域\"><a class=\"markdownIt-Anchor\" href=\"#作用域\">#</a> 作用域</h3>\n<h4 id=\"作用域概述\"><a class=\"markdownIt-Anchor\" href=\"#作用域概述\">#</a> 作用域概述</h4>\n<p>1.js 的作用域就是代码名字在某个范围内起作用和效果 目的是为了提高程序的可靠性，重要的是减少命名冲突<br>\n 2.js 的作用域 (es6) 之前：全局作用域 和 局部作用域<br>\n 3. 全局作用域：整个 script 标签 或者是一个单独的 js 文件<br>\n 4. 局部作用域：在函数内部就是局部作用域，这个代码的名字只在函数内部起作用和效果 又叫做函数作用域</p>\n<h4 id=\"变量的作用域\"><a class=\"markdownIt-Anchor\" href=\"#变量的作用域\">#</a> 变量的作用域</h4>\n<p>根据作用域的不同我们变量分为全局变量和局部变量<br>\n 1. 全局变量：在全局作用域下的变量 在全局下都可以使用 (当然包括函数内部)<br>\n 2. 局部变量：在局部作用域下的变量 在函数内部的变量就是局部变量 只能在函数内部使用<br>\n 3. 特殊情况：如果在函数内部没有声明直接赋值的变量也称为全局变量，函数的形参也可以看成局部变量</p>\n<p>从执行效率来看全局变量和局部变量<br>\n 1. 全局变量只有浏览器关闭的时候才会销毁，比较占内存资源<br>\n 2. 局部变量 当我们程序执行完毕就会销毁，比较节约内存支援<br>\n<strong>现阶段 js 没有块级作用域</strong></p>\n<h4 id=\"作用域链\"><a class=\"markdownIt-Anchor\" href=\"#作用域链\">#</a> 作用域链</h4>\n<p>内部函数访问外部函数的电量，采取的是链式查找的方式来决定取哪种值，这种结构我们称为作用域链<br>\n内部函数是可以访问外部函数的变量的</p>\n<h3 id=\"javascript预解析\"><a class=\"markdownIt-Anchor\" href=\"#javascript预解析\">#</a> javascript 预解析</h3>\n<p>1.js 解析器在运行 js 代码的时候分为两部分：先进行预解析，再进行代码执行<br>\n (2). 预解析:js 引擎会把 js 里面所有的 var 还有 function 提升到当前作用域的最前面<br>\n (3). 代码执行：按照代码书写的顺序从上往下执行.<br>\n2. 预解析分为变量预解析 (变量提升) 和函数预解析 (函数执行)<br>\n(1). 变量提升：就是把所有的变量声明提升到当前的作用域最前面 不提升赋值</p>\n<blockquote>\n<pre><code>console.log(num);\nvar num= 10;\n在预解析的时候执行顺序是这样的\nvar num;\nconsole.log(num);\nnum=10\n</code></pre>\n</blockquote>\n<p>(2). 函数声明：就是先把函数声明提升到当前作用域的最前面，不执行函数.</p>\n<h3 id=\"js对象\"><a class=\"markdownIt-Anchor\" href=\"#js对象\">#</a> js 对象</h3>\n<h4 id=\"对象概念\"><a class=\"markdownIt-Anchor\" href=\"#对象概念\">#</a> 对象概念</h4>\n<p>对象是一个具体的事物 (不是泛指)<br>\n 比如 明星不是对象 但刘德华是对象<br>\n<img src=\"js_img/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5.png\" alt=\"photo\"></p>\n<h4 id=\"对象的使用方向\"><a class=\"markdownIt-Anchor\" href=\"#对象的使用方向\">#</a> 对象的使用方向</h4>\n<p>保存一个值可以使用变量，保存多个值可以使用数组，但如果保存一个人的完整信就需要用到对象了</p>\n<h4 id=\"创建对象的三种方式\"><a class=\"markdownIt-Anchor\" href=\"#创建对象的三种方式\">#</a> 创建对象的三种方式</h4>\n<p>1. 利用字面量创建对象<br>\n 2. 利用 new Object 创建对象<br>\n 3. 利用构造函数创建对象</p>\n<h4 id=\"对象字面量\"><a class=\"markdownIt-Anchor\" href=\"#对象字面量\">#</a> 对象字面量</h4>\n<p>{} 是对象的字面量<br>\n 1. 里面的属性或者方法我们采取键值对的形式 键 属性名：值 属性值<br>\n 2. 多个属性或者方法中间用逗号隔开，函数后面加；而不加逗号<br>\n 3. 方法冒号后面跟的是一个匿名函数</p>\n<h4 id=\"使用对象\"><a class=\"markdownIt-Anchor\" href=\"#使用对象\">#</a> 使用对象</h4>\n<p>调用对象的属性 我们采取 对象名。属性名</p>\n<blockquote>\n<p>console.log(obj.uname)</p>\n</blockquote>\n<p>其中这个。我们可以理解为的 比如说对象的属性<br>\n调用属性还有一种方法 对象名 [‘属性名’]</p>\n<blockquote>\n<p>console.log(abj[‘age’])</p>\n</blockquote>\n<p>需要注意的是 后面这种方法需要’' 而前面一种方法不需要<br>\n调用对象中的函数时，千万不要忘记添加小括号<br>\n<img src=\"js_img/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%B0%83%E7%94%A8.png\" alt=\"photo\"></p>\n<h4 id=\"变量-属性-函数-方法的区别\"><a class=\"markdownIt-Anchor\" href=\"#变量-属性-函数-方法的区别\">#</a> 变量 属性 函数 方法的区别</h4>\n<p>相同点：都是用来存储数据的<br>\n不同点：1. 变量 单独声明并赋值 使用的时候直接写变量名 单独存在<br>\n 2. 属性 在对象里面的不需要声明的 使用的时候必须是 对象。属性</p>\n<p>函数和方法<br>\n相同点：都是实现某种功能 做某件事<br>\n不同点：函数时单独声明 并且调用的 是单独存在的<br>\n方法 在对象里面</p>\n<h4 id=\"利用new-object来创建对象\"><a class=\"markdownIt-Anchor\" href=\"#利用new-object来创建对象\">#</a> 利用 new Object 来创建对象</h4>\n<blockquote>\n<pre><code>var obj = new Object();   创建了一个空的对象\nobj.uname = '张三丰';\n</code></pre>\n</blockquote>\n<p>利用 等号 = 赋值的方法 添加对象的属性和方法<br>\n每个属性和方法之间用分号结束</p>\n<h4 id=\"利用构造函数创建对象\"><a class=\"markdownIt-Anchor\" href=\"#利用构造函数创建对象\">#</a> 利用构造函数创建对象</h4>\n<p>构造函数 就是把我们对象里面一些相同的属性和方法抽象出来封装到函数里面<br>\n语法格式:</p>\n<blockquote>\n<pre><code>function 构造函数名() {\n    this.属性 = 值;\n    this.方法 = function() {}\n }\n使用: new 构造函数名();\n</code></pre>\n</blockquote>\n<p>1. 构造函数名的首字母要大写<br>\n 2. 构造函数 不需要 return 就可以返回结果<br>\n 3. 我们调用构造函数必须使用 new<br>\n4. 属性和方法前面必须添加 this<br>\n<img src=\"js_img/new%E5%85%B3%E9%94%AE%E5%AD%97.png\" alt=\"photo\"></p>\n<h4 id=\"for-in遍历我们的对象\"><a class=\"markdownIt-Anchor\" href=\"#for-in遍历我们的对象\">#</a> for in 遍历我们的对象</h4>\n<blockquote>\n<pre><code>for (变量 in 对象) {\n  }\n</code></pre>\n</blockquote>\n<h3 id=\"javascript内置对象\"><a class=\"markdownIt-Anchor\" href=\"#javascript内置对象\">#</a> javascript 内置对象</h3>\n<p>1. 自定义对象<br>\n 2. 内置对象<br>\n 3. 浏览器对象 (js 特有)</p>\n<p>内置对象是 js 语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或者是最基本的属性和方法<br>\n Math Date Array String</p>\n<h4 id=\"查阅文档\"><a class=\"markdownIt-Anchor\" href=\"#查阅文档\">#</a> 查阅文档</h4>\n<blockquote>\n<pre><code>https://developer.mozilla.org/zh-CN\n</code></pre>\n</blockquote>\n<p><img src=\"js_img/%E6%9F%A5%E6%96%87%E6%A1%A31.png\" alt=\"photo\"></p>\n<h4 id=\"math对象\"><a class=\"markdownIt-Anchor\" href=\"#math对象\">#</a> Math 对象</h4>\n<p>不是一个构造函数，不用 new 来调用，直接使用即可<br>\n<img src=\"js_img/Math%E6%A6%82%E8%BF%B0.png\" alt=\"photo\"></p>\n<p>Math.round 四舍五入中.5 是特殊数字 他往大了去  比如 - 1.5 的结果是 - 1</p>\n<h5 id=\"math随机数法\"><a class=\"markdownIt-Anchor\" href=\"#math随机数法\">#</a> Math 随机数法</h5>\n<blockquote>\n<pre><code>console.log(Math.random());\n</code></pre>\n</blockquote>\n<h4 id=\"date日期数法\"><a class=\"markdownIt-Anchor\" href=\"#date日期数法\">#</a> Date 日期数法</h4>\n<p>是一个构造函数 必须使用 new 来调用创建我们的日期对象</p>\n<blockquote>\n<pre><code>   var day = new Date();\n   console.log(day);\n</code></pre>\n</blockquote>\n<p>使用 date 如果没有参数 返回当前系统的当前时间<br>\n参数常用的写法 数字型 2019,10,01 或者是字符串型’2019-10-01’<br>\n<img src=\"js_img/date%E6%97%A5%E6%9C%9F%E5%AF%B9%E8%B1%A1.png\" alt=\"photo\"></p>\n<h5 id=\"日期格式化date\"><a class=\"markdownIt-Anchor\" href=\"#日期格式化date\">#</a> 日期格式化 Date</h5>\n<p><img src=\"js_img/%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96.png\" alt=\"photo\"><br>\n 返回的月份小一个月 记得月份 +1</p>\n<h5 id=\"获取日期的总的毫秒形式\"><a class=\"markdownIt-Anchor\" href=\"#获取日期的总的毫秒形式\">#</a> 获取日期的总的毫秒形式</h5>\n<p>Date 对象是基于 1970 年 1 月 1 日 (世界标准时间) 起的毫秒数</p>\n<blockquote>\n<pre><code>1.valueOf()    getTime()\n2.var date1= +new Date();\n3.H5新增 console(Date.now());\n</code></pre>\n</blockquote>\n<h4 id=\"数组对象array\"><a class=\"markdownIt-Anchor\" href=\"#数组对象array\">#</a> 数组对象 Array</h4>\n<p>1. 数组字面量创建<br>\n 2. 利用 new Array () 创建</p>\n<p>检测是非为数组<br>\n 1.instanceof Array<br>\n2.Array.isArray (参数)</p>\n<h5 id=\"添加删除数组元素的方法\"><a class=\"markdownIt-Anchor\" href=\"#添加删除数组元素的方法\">#</a> 添加删除数组元素的方法</h5>\n<p><img src=\"js_img/%E6%B7%BB%E5%8A%A0%E6%88%96%E8%80%85%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95.png\" alt=\"photo\"><br>\n 添加:arr.push ();arr.unshift ();<br>\n 删除:arr.pop ();arr.shift;</p>\n<h5 id=\"数组排序\"><a class=\"markdownIt-Anchor\" href=\"#数组排序\">#</a> 数组排序</h5>\n<p><img src=\"js_img/%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F.png\" alt=\"photo\"></p>\n<blockquote>\n<pre><code>       arr1.sort(function (a, b) {\n       return a - b //升序的顺序排列\n       //return b - a 是降序的顺序排列\n        });\n</code></pre>\n</blockquote>\n<h5 id=\"数组索引方法\"><a class=\"markdownIt-Anchor\" href=\"#数组索引方法\">#</a> 数组索引方法</h5>\n<p><img src=\"js_img/%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E6%96%B9%E6%B3%95.png\" alt=\"photo\"><br>\n 注意，如果有两个重复 只范湖第一个满足条件的索引号。如果里面没有相对元素返回的结果是 - 1;</p>\n<h5 id=\"数组转化成字符串\"><a class=\"markdownIt-Anchor\" href=\"#数组转化成字符串\">#</a> 数组转化成字符串</h5>\n<p><img src=\"js_img/%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2.png\" alt=\"photo\"></p>\n<h4 id=\"字符串对象\"><a class=\"markdownIt-Anchor\" href=\"#字符串对象\">#</a> 字符串对象</h4>\n<p>基本包装类型：就是把简单数据类型 包装称为了 复杂数据类型<br>\n (1) 把简单数据类型包装称为复杂数据类型<br>\n var temp = new String (‘Andy’)<br>\n(2) 把临时变量的值给 str<br>\nstr=temp<br>\n (3) 销毁这个临时变量<br>\n temp = null<br>\n<img src=\"js_img/%E5%9F%BA%E6%9C%AC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B.png\" alt=\"photo\"></p>\n<h5 id=\"字符串的不可变型\"><a class=\"markdownIt-Anchor\" href=\"#字符串的不可变型\">#</a> 字符串的不可变型</h5>\n<p><img src=\"js_img/%E8%BF%94%E5%9B%9E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%8D%E7%BD%AE.png\" alt=\"photo\"></p>\n<blockquote>\n<pre><code>   var str = '改革吹风吹满地'\n   console.log(str.indexOf('吹',3));\n</code></pre>\n</blockquote>\n<h5 id=\"根据位置返回字符\"><a class=\"markdownIt-Anchor\" href=\"#根据位置返回字符\">#</a> 根据位置返回字符</h5>\n<p><img src=\"js_img/%E6%A0%B9%E6%8D%AE%E4%BD%8D%E7%BD%AE%E8%BF%94%E5%9B%9E%E5%AD%97%E7%AC%A6.png\" alt=\"photo\"></p>\n<h5 id=\"字符串操作方法\"><a class=\"markdownIt-Anchor\" href=\"#字符串操作方法\">#</a> 字符串操作方法</h5>\n<p><img src=\"js_img/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95.png\" alt=\"photo\"></p>\n<blockquote>\n<pre><code>   var str = '改革春风吹满地'\n   console.log(str.substr(2, 2));  //第一个2是索引号的2  第二个2是取几个字符\n</code></pre>\n</blockquote>\n<h5 id=\"替换字符串\"><a class=\"markdownIt-Anchor\" href=\"#替换字符串\">#</a> 替换字符串</h5>\n<blockquote>\n<pre><code>replace('被替换的字符','替换为的字符')\n</code></pre>\n</blockquote>\n<p>如果有相同的两个字符 只会替换前面一个字符</p>\n<h5 id=\"把字符串转化成数组\"><a class=\"markdownIt-Anchor\" href=\"#把字符串转化成数组\">#</a> 把字符串转化成数组</h5>\n<p>split (‘分隔符’) 把字符转换成数组<br>\n join (‘分隔符’) 把数组转换成字符串</p>\n<p>split 中的分隔符取决于原字符串中的分隔符是什么</p>\n<h3 id=\"web-apis\"><a class=\"markdownIt-Anchor\" href=\"#web-apis\">#</a> Web APIs</h3>\n<p>浏览器提供的一套操作浏览器功能和页面元素的 API</p>\n<h4 id=\"dom\"><a class=\"markdownIt-Anchor\" href=\"#dom\">#</a> DOM</h4>\n<p><img src=\"js_img/DOM%E5%AE%9A%E4%B9%89.png\" alt=\"photo\"></p>\n<h4 id=\"获取页面元素\"><a class=\"markdownIt-Anchor\" href=\"#获取页面元素\">#</a> 获取页面元素</h4>\n<h5 id=\"id获取\"><a class=\"markdownIt-Anchor\" href=\"#id获取\">#</a> ID 获取</h5>\n<p>getElementByld()<br>\n console.dir (); 打印我们返回的元素对象 更好地查看里面的属性和方法</p>\n<h5 id=\"根据标签名来获取\"><a class=\"markdownIt-Anchor\" href=\"#根据标签名来获取\">#</a> 根据标签名来获取</h5>\n<p>element.getElementsByTagName (‘标签名’)<br>\n 1. 获取过来元素对象的集合 以伪数组的形式储存<br>\n 2. 如果页面中只有一个元素 返回的还是伪数组的形式<br>\n 3. 如果页面中没有这个元素 返回的是空的伪数组</p>\n<blockquote>\n<pre><code>   var lis = document.getElementsByTagName('ul')\n   var li = lis[0].getElementsByTagName('li')\n</code></pre>\n</blockquote>\n<h5 id=\"根据类型来获取新增html5属性\"><a class=\"markdownIt-Anchor\" href=\"#根据类型来获取新增html5属性\">#</a> 根据类型来获取 (新增 Html5 属性)</h5>\n<p>document.getElementsByClassName (‘类名’)<br>\n document.querySelector (‘选择器’) 根据选择器返回第一个元素对象<br>\n document.querySelectorAll (‘选择器’) 根据选择器返回所有的集合</p>\n<h5 id=\"获取特殊元素\"><a class=\"markdownIt-Anchor\" href=\"#获取特殊元素\">#</a> 获取特殊元素</h5>\n<p>1. 获取 body 元素<br>\n document.body<br>\n2. 获取 html 元素<br>\n document.documentElement</p>\n<h4 id=\"事件基础\"><a class=\"markdownIt-Anchor\" href=\"#事件基础\">#</a> 事件基础</h4>\n<p>js 让我们有能力创建动态页面，而时间是可以被 js 侦测到的行为<br>\n在网页中每个元素都可以产生某些触发 js 的事件</p>\n<p>事件的组成部分<br>\n 1. 事件源：事件被触发的对象<br>\n 2. 事件类型：如何触发 什么事件 比如 鼠标点击 (onclick) 触发  还是鼠标经过触发<br>\n 3. 事件处理程序：通过函数赋值的方式完成</p>\n<h5 id=\"执行事件的步骤\"><a class=\"markdownIt-Anchor\" href=\"#执行事件的步骤\">#</a> 执行事件的步骤</h5>\n<p>1. 获取事件源<br>\n 2. 绑定事件<br>\n 3. 添加事件处理程序 (采取函数赋值的形式)</p>\n<h4 id=\"操作元素\"><a class=\"markdownIt-Anchor\" href=\"#操作元素\">#</a> 操作元素</h4>\n<h5 id=\"改变元素内容\"><a class=\"markdownIt-Anchor\" href=\"#改变元素内容\">#</a> 改变元素内容</h5>\n<p>element.innerText<br>\nelement.innerHTML<br>\n 这两个属性是可读写的 可以获取元素里面的内容<br>\n<img src=\"js_img/%E6%94%B9%E5%8F%98%E5%85%83%E7%B4%A0%E5%86%85%E5%AE%B9.png\" alt=\"photo\"></p>\n<h5 id=\"改变元素属性\"><a class=\"markdownIt-Anchor\" href=\"#改变元素属性\">#</a> 改变元素属性</h5>\n<h5 id=\"表单元素属性设置\"><a class=\"markdownIt-Anchor\" href=\"#表单元素属性设置\">#</a> 表单元素属性设置</h5>\n<p><img src=\"js_img/%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE.png\" alt=\"photo\"></p>\n<h5 id=\"修改样式属性\"><a class=\"markdownIt-Anchor\" href=\"#修改样式属性\">#</a> 修改样式属性</h5>\n<p>element.style 行内样式操作<br>\n element.className 类名样式操作<br>\n<img src=\"js_img/%E6%A0%B7%E5%BC%8F%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C%20%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.png\" alt=\"photo\"></p>\n<p>onfocus 获得焦点事件<br>\n onblur 失去焦点事件</p>\n<h5 id=\"操作元素总结\"><a class=\"markdownIt-Anchor\" href=\"#操作元素总结\">#</a> 操作元素总结</h5>\n<p><img src=\"js_img/%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0%E6%80%BB%E7%BB%93.png\" alt=\"photo\"></p>\n<h5 id=\"排他思想\"><a class=\"markdownIt-Anchor\" href=\"#排他思想\">#</a> 排他思想</h5>\n<p>先清除样式，再给当前元素设置样式</p>\n<blockquote>\n<pre><code>   var btn = document.getElementsByTagName('button')\n   for (i = 0; i &lt; btn.length; i++) {\n       btn[i].onclick = function () {\n           for (i = 0; i &lt; btn.length; i++) {\n               btn[i].style.backgroundColor = 'white'\n           }\n           this.style.backgroundColor = 'pink'\n       }\n   }\n</code></pre>\n</blockquote>\n<p>鼠标经过 onmouseover<br>\n 鼠标离开 onmouseout</p>\n<h5 id=\"自定义属性值的操作\"><a class=\"markdownIt-Anchor\" href=\"#自定义属性值的操作\">#</a> 自定义属性值的操作</h5>\n<h6 id=\"获取属性值\"><a class=\"markdownIt-Anchor\" href=\"#获取属性值\">#</a> 获取属性值</h6>\n<p><img src=\"js_img/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7.png\" alt=\"photo\"></p>\n<h6 id=\"设置属性值\"><a class=\"markdownIt-Anchor\" href=\"#设置属性值\">#</a> 设置属性值</h6>\n<p>element. 属性 = ‘值’<br>\nelement.setAttribute (‘属性’,‘值’)</p>\n<p>setAttribute 主要用于设置自定义属性</p>\n<p>removeAttribute 移除属性</p>\n<h6 id=\"h5自定义属性值\"><a class=\"markdownIt-Anchor\" href=\"#h5自定义属性值\">#</a> H5 自定义属性值</h6>\n<p>H5 新规范：自定义属性都用 data- 开头<br>\n H5 新增的获取自定义属性的方法 <a href=\"http://element.dataset.XXX\">element.dataset.XXX</a><br>\ndataset 是一个集合 里面存放了所有以 data 开头的自定义属性<br>\n入股哦自定义属性里面有多个 - 链接的单词，我们获取的时候采取驼峰命名法</p>\n<p><img src=\"js_img/H5%E8%8E%B7%E5%8F%96%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E5%AE%9E%E4%BE%8B.png\" alt=\"photo\"></p>\n<h4 id=\"节点操作\"><a class=\"markdownIt-Anchor\" href=\"#节点操作\">#</a> 节点操作</h4>\n<p>为什么要学节点操作<br>\n<img src=\"js_img/%E5%AD%A6%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C%E7%9A%84%E5%8E%9F%E5%9B%A0.png\" alt=\"photo\"></p>\n<h5 id=\"节点概述\"><a class=\"markdownIt-Anchor\" href=\"#节点概述\">#</a> 节点概述</h5>\n<p><img src=\"js_img/%E8%8A%82%E7%82%B9%E6%A6%82%E8%BF%B0.png\" alt=\"photo\"></p>\n<h5 id=\"节点层级\"><a class=\"markdownIt-Anchor\" href=\"#节点层级\">#</a> 节点层级</h5>\n<p><img src=\"js_img/%E8%8A%82%E7%82%B9%E5%B1%82%E7%BA%A7.png\" alt=\"photo\"></p>\n<h5 id=\"父节点\"><a class=\"markdownIt-Anchor\" href=\"#父节点\">#</a> 父节点</h5>\n<p><img src=\"js_img/%E7%88%B6%E8%8A%82%E7%82%B9.png\" alt=\"photo\"></p>\n<h5 id=\"子节点\"><a class=\"markdownIt-Anchor\" href=\"#子节点\">#</a> 子节点</h5>\n<p><img src=\"js_img/%E5%AD%90%E8%8A%82%E7%82%B91.png\" alt=\"photo\"><br>\n<img src=\"js_img/%E5%AD%90%E8%8A%82%E7%82%B92.png\" alt=\"photo\"><br>\n<img src=\"js_img/%E5%AD%90%E8%8A%82%E7%82%B9%E5%AE%9E%E4%BE%8B.png\" alt=\"photo\"></p>\n<h5 id=\"兄弟节点\"><a class=\"markdownIt-Anchor\" href=\"#兄弟节点\">#</a> 兄弟节点</h5>\n<p><img src=\"js_img/%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9.png\" alt=\"photo\"><br>\n 解决兄弟节点的兼容性问题:<br>\n<img src=\"js_img/%E8%A7%A3%E5%86%B3%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98.png\" alt=\"photo\"></p>\n<h5 id=\"创建和删除节点\"><a class=\"markdownIt-Anchor\" href=\"#创建和删除节点\">#</a> 创建和删除节点</h5>\n<h6 id=\"创建节点\"><a class=\"markdownIt-Anchor\" href=\"#创建节点\">#</a> 创建节点</h6>\n<p><img src=\"js_img/%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9.png\" alt=\"photo\"></p>\n<h6 id=\"添加节点\"><a class=\"markdownIt-Anchor\" href=\"#添加节点\">#</a> 添加节点</h6>\n<p><img src=\"js_img/%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9.png\" alt=\"photo\"><br>\nnode.appendChild(child)<br>\n node.insertbefore (child, 指定元素);</p>\n<h6 id=\"删除节点\"><a class=\"markdownIt-Anchor\" href=\"#删除节点\">#</a> 删除节点</h6>\n<p>code.removeChild (节点)<br>\neg:ul.removeChild(ul.children[0])</p>\n<h6 id=\"复制节点克隆节点\"><a class=\"markdownIt-Anchor\" href=\"#复制节点克隆节点\">#</a> 复制节点 (克隆节点)</h6>\n<p>node.cloneNode()<br>\n 如果括号为空，则只复制标签 不复制里面的内容<br>\n括号里面为 true 则里面的内容也跟着赋值</p>\n<h6 id=\"三种动态创建元素区别\"><a class=\"markdownIt-Anchor\" href=\"#三种动态创建元素区别\">#</a> 三种动态创建元素区别</h6>\n<p>document.write () 如果页面加载完毕 再执行这个指令 会导致页面全部重绘<br>\n innerHTML<br>\ndocument.createElement(’’)<br>\n 最后两个大致上没有区别 但是如果需要创造很多个元素 最后一个的效率会大大提高，因为最后一个不是拼接字符串 而是在电脑中重新开辟一个新的空间</p>\n<p><img src=\"%E4%B8%89%E7%A7%8D%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB\" alt=\"photo\"><br>\n 改进方法:innerHTML 不采用拼接字符串的方式，而是采用数组形式拼接，现在数组中拼接字符串，然后将数组引入到 innerHTML 中</p>\n<h4 id=\"dom重点核心\"><a class=\"markdownIt-Anchor\" href=\"#dom重点核心\">#</a> DOM 重点核心</h4>\n<p>(一) 创建<br>\n 1.document.write<br>\n2.innerHTML<br>\n3.createElement<br>\n (二) 增<br>\n 1.appendChild<br>\n2.innerBefore<br>\n (三) 删<br>\n 1.removeChild<br>\n (四) 改<br>\n 1. 修改元素属性:src,href,title<br>\n2. 修改普通元素内容:innerHTML,innerText<br>\n3. 修改表单元素:value,type,disabled<br>\n4. 修改元素样式:style,className<br>\n (五) 查<br>\n 1.DOM 提供的 API 方法:getElementById,getElementsByTagName  (<strong>古老用法不推荐</strong>)<br>\n 2.H5 提供的新方法:querySelector,querySelectorAll 提倡<br>\n 3. 利用节点获取元素：父 (parentNode), 子 (children), 兄 (previousElementSibing,nextElementSibing) 提倡<br>\n (六) 属性操作<br>\n 1.setAttribute: 设置 dom 的属性值<br>\n 2.getAttribute: 得到 dom 的属性值<br>\n 3.removeAttribute: 移除属性<br>\n (七) 事件操作<br>\n onclick: 鼠标点击左键触发<br>\n onmouseover: 鼠标经过触发<br>\n onmouseout: 鼠标离开触发<br>\n onfocus: 获得鼠标焦点触发<br>\n onblur: 失去鼠标焦点触发<br>\n onmousemove: 鼠标移动触发<br>\n onmouseup: 鼠标弹起触发<br>\n onmousedown: 鼠标按下触发</p>\n<h4 id=\"事件高级导读\"><a class=\"markdownIt-Anchor\" href=\"#事件高级导读\">#</a> 事件高级导读</h4>\n<h5 id=\"注册事件\"><a class=\"markdownIt-Anchor\" href=\"#注册事件\">#</a> 注册事件</h5>\n<p>传统方式和方法监听注册方式<br>\n<img src=\"js_img/%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6.png\" alt=\"photo\"></p>\n<blockquote>\n<pre><code>eventTarget.addEventListener(type,listener[,useCapture])\n</code></pre>\n</blockquote>\n<p><img src=\"js_img/addEventListener.png\" alt=\"photo\"><br>\n 里面的事件类型是字符串 必定加引号 不带 on<br>\n 同一个元素 同一个事件可以添加多个侦听器 (事件处理程序)</p>\n<p>AttachEvent 事件监听方式 (<strong>不提倡仅供了解</strong>)<br>\n<img src=\"js_img/attachEvent%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%96%B9%E5%BC%8F.png\" alt=\"photo\"></p>\n<p>注册事件兼容性解决方法<br>\n<img src=\"js_img/%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6%E5%85%BC%E5%AE%B9%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.png\" alt=\"photo\"></p>\n<h5 id=\"删除事件解绑事件\"><a class=\"markdownIt-Anchor\" href=\"#删除事件解绑事件\">#</a> 删除事件 (解绑事件)</h5>\n<p>1. 传统法式:element.onclick = null<br>\n2. 方法监听事件: eventTarget.removeEventListener (type,listener [,useCapture])<br>\n 删除事件兼容性解决方案:<br>\n<img src=\"js_img/%E5%88%A0%E9%99%A4%E4%BA%8B%E4%BB%B6%E5%85%BC%E5%AE%B9%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png\" alt=\"photo\"></p>\n<h5 id=\"dom事件流\"><a class=\"markdownIt-Anchor\" href=\"#dom事件流\">#</a> DOM 事件流</h5>\n<p><img src=\"js_img/DOM%E4%BA%8B%E4%BB%B6%E6%B5%81.png\" alt=\"photo\"></p>\n<p>注意事项<br>\n<img src=\"js_img/DOM%E4%BA%8B%E4%BB%B6%E6%B5%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.png\" alt=\"photo\"><br>\n 捕获阶段<br>\n<img src=\"js_img/dom%E4%BA%8B%E4%BB%B6%E6%B5%81%E6%8D%95%E8%8E%B7%E9%98%B6%E6%AE%B5.png\" alt=\"photo\"><br>\n 冒泡阶段<br>\n<img src=\"js_img/DOM%E4%BA%8B%E4%BB%B6%E6%B5%81%E5%86%92%E6%B3%A1%E9%98%B6%E6%AE%B5.png\" alt=\"photo\"></p>\n<h4 id=\"事件对象\"><a class=\"markdownIt-Anchor\" href=\"#事件对象\">#</a> 事件对象</h4>\n<p><img src=\"js_img/%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1.png\" alt=\"photo\"></p>\n<h5 id=\"事件对象的常见属性和方法\"><a class=\"markdownIt-Anchor\" href=\"#事件对象的常见属性和方法\">#</a> 事件对象的常见属性和方法</h5>\n<p><img src=\"js_img/%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E8%A7%81%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95.png\" alt=\"photo\"><br>\ne.target 返回的是触发事件的对象 而 this 返回的是绑定事件的对象，currentTarget 和 this 一样返回的是绑定事件的对象 ie678 不认识 currentTarget<br>\ne.type: 返回事件类型 例如 click,mouseover</p>\n<p>组织默认事件 让链接不跳转 或者让提交按钮不提交 e.preventDefault ();<br>\n![photo](js_img / 兼容.png</p>\n<p>组织事件冒泡 e.stopPropagation ()<br>\n 兼容性解决方法<br>\n<img src=\"js_img/%E7%BB%84%E7%BB%87%E5%86%92%E6%B3%A1%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E6%96%B9%E6%A1%88.png\" alt=\"photo\"></p>\n<h5 id=\"事件委托\"><a class=\"markdownIt-Anchor\" href=\"#事件委托\">#</a> 事件委托</h5>\n<p>原理：给父节点添加侦听器，利用事件冒泡影响每一个子节点</p>\n<h5 id=\"常用的鼠标事件\"><a class=\"markdownIt-Anchor\" href=\"#常用的鼠标事件\">#</a> 常用的鼠标事件</h5>\n<p><img src=\"js_img/%E5%B8%B8%E7%94%A8%E7%9A%84%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6.png\" alt=\"photo\"><br>\n 禁止鼠标右键菜单:contextmenu 主要控制应该在何时显示上下文菜单，主要用于程序员取消默认的上下文菜单<br>\n禁止鼠标选中:selectstart</p>\n<blockquote>\n<pre><code>   document.addEventListener('contextmenu', function (e) {\n       e.preventDefault();\n   })\n   document.addEventListener('selectstart', function (e) {\n       e.preventDefault();\n   })\n</code></pre>\n</blockquote>\n<h5 id=\"鼠标事件对象\"><a class=\"markdownIt-Anchor\" href=\"#鼠标事件对象\">#</a> 鼠标事件对象</h5>\n<p>Mouseevent 鼠标事件对象<br>\n keyboard 键盘事件对象<br>\n<img src=\"js_img/%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1.png\" alt=\"photo\"><br>\nclient 以可视区为主 跟屏幕滚动没有关系<br>\n page 相对于文档页面的 X 和 Y 坐标<br>\n screen 鼠标相当于电脑屏幕的 X 和 Y 坐标 (当浏览器缩小或者放大时会变化)<br>\n mousemove 鼠标移动事件</p>\n<h5 id=\"键盘事件对象\"><a class=\"markdownIt-Anchor\" href=\"#键盘事件对象\">#</a> 键盘事件对象</h5>\n<p><img src=\"js_img/%E5%B8%B8%E7%94%A8%E7%9A%84%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6.png\" alt=\"photo\"><br>\n 三个事件的执行顺序是 keydown keypress keyup</p>\n<p>KeyCode 返回键盘按键的 ASCII 的值<br>\n keyup 和 keydown 事件不区分字母大小写 a 和 A 得到的就是 65<br>\nkeypress 区分字母大小写</p>\n<h3 id=\"bom浏览器对象模型\"><a class=\"markdownIt-Anchor\" href=\"#bom浏览器对象模型\">#</a> BOM 浏览器对象模型</h3>\n<h4 id=\"bom概述\"><a class=\"markdownIt-Anchor\" href=\"#bom概述\">#</a> BOM 概述</h4>\n<p>BOM: 浏览器对象模型<br>\n<img src=\"js_img/BOM%E6%A6%82%E8%BF%B0.png\" alt=\"photo\"><br>\nBOM 的构成<br>\n<img src=\"js_img/BOM%E7%9A%84%E6%9E%84%E6%88%90.png\" alt=\"photo\"></p>\n<h4 id=\"浏览器顶级对象window\"><a class=\"markdownIt-Anchor\" href=\"#浏览器顶级对象window\">#</a> 浏览器顶级对象 window</h4>\n<p><img src=\"js_img/window%E5%AF%B9%E8%B1%A1.png\" alt=\"photo\"></p>\n<h5 id=\"窗口加载事件\"><a class=\"markdownIt-Anchor\" href=\"#窗口加载事件\">#</a> 窗口加载事件</h5>\n<p>window.onload 窗口加载事件，当文档内容完全加载完成后会触发该事件 (包括图像 css 脚本等等)<br>\n 注意:<br>\n1. 有了 window.onload 我们就可以将 js 写在任何位置 onload 是等页面文档加载完成后 最后加载的东西<br>\n 2.window,onload 传统注册事件只能写一次，如果有多个，会以最后一个 window.onload 为准<br>\n 3. 如果使用 AddEventListener 则没有限制<br>\n document.addEventListener (‘DOMContentLoaded’,function (){})<br>\n 仅当 DOM 加载完成就开始触发，不包括样式表，图片，flash 等等<br>\n后一个加载更快，如果是图片较多的网站等 会因为图片刷新过快 如果使用第一个方式 有可能无法加载出 js 文件 而使用后一个方式 则在 DOM 加载完成后 就加载 js</p>\n<h5 id=\"调整窗口大小事件\"><a class=\"markdownIt-Anchor\" href=\"#调整窗口大小事件\">#</a> 调整窗口大小事件</h5>\n<p><img src=\"js_img/%E8%B0%83%E6%95%B4%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F%E4%BA%8B%E4%BB%B6.png\" alt=\"photo\"></p>\n<h4 id=\"定时器\"><a class=\"markdownIt-Anchor\" href=\"#定时器\">#</a> 定时器</h4>\n<h5 id=\"settimeout定时器\"><a class=\"markdownIt-Anchor\" href=\"#settimeout定时器\">#</a> setTimeout () 定时器</h5>\n<p>window.setTimeout (调用函数，[延迟的毫秒数]);<br>\n 在定时器到期后执行函数<br>\n 1.window 在调用的时候可以省略<br>\n 2. 时间单位是毫秒，可以省略 如果省略默认为 0<br>\n3. 页面中可能有很多的定时器 我们经常给定时器起一个标识符</p>\n<p>callback 回调函数<br>\n<img src=\"js_img/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.png\" alt=\"photo\"></p>\n<h6 id=\"停止settimeout定时器\"><a class=\"markdownIt-Anchor\" href=\"#停止settimeout定时器\">#</a> 停止 setTimeout () 定时器</h6>\n<p>window.clearaTimeout (定时器名字)</p>\n<h5 id=\"setinterval定时器\"><a class=\"markdownIt-Anchor\" href=\"#setinterval定时器\">#</a> setInterval () 定时器</h5>\n<p><img src=\"js_img/setInterval()%E5%AE%9A%E6%97%B6%E5%99%A8.png\" alt=\"photo\"></p>\n<p>区别:setTimeout 只调用一次回调函数<br>\n setInterval 会一直调用函数</p>\n<h4 id=\"this指向问题\"><a class=\"markdownIt-Anchor\" href=\"#this指向问题\">#</a> this 指向问题</h4>\n<p>1. 全局作用域或者普通函数中 this 指向全局对象 window (定时器里面的 this 指向 window)<br>\n 2. 方法调用中谁调用 this 指向谁<br>\n 3. 构造函数中 this 可以指向构造函数</p>\n<h4 id=\"js的执行队列\"><a class=\"markdownIt-Anchor\" href=\"#js的执行队列\">#</a> js 的执行队列</h4>\n<p>js 是单线程的 同一个时间只能做一件事<br>\n为了解决这个问题，利用多核 CPU 的计算能力，HTML5 允许 js 脚本创建多个线程，于是 js 中出现了同步和异步<br>\n<img src=\"js_img/%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5.png\" alt=\"photo\"></p>\n<h5 id=\"js执行机制\"><a class=\"markdownIt-Anchor\" href=\"#js执行机制\">#</a> js 执行机制</h5>\n<p><img src=\"js_img/%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1.png\" alt=\"photo\"><br>\n<img src=\"js_img/%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E5%9B%BE%E7%A4%BA.png\" alt=\"photo\"><br>\n<img src=\"js_img/js%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6.png\" alt=\"photo\"><br>\n<img src=\"js_img/js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.png\" alt=\"photo\"></p>\n<h4 id=\"location对象\"><a class=\"markdownIt-Anchor\" href=\"#location对象\">#</a> location 对象</h4>\n<p><img src=\"js_img/location%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B1%9E%E6%80%A7.png\" alt=\"photo\"><br>\n<img src=\"js_img/url.png\" alt=\"photo\"></p>\n<h5 id=\"location对象方法\"><a class=\"markdownIt-Anchor\" href=\"#location对象方法\">#</a> location 对象方法</h5>\n<p><img src=\"js_img/location%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95.png\" alt=\"photo\"></p>\n<h4 id=\"navigator对象\"><a class=\"markdownIt-Anchor\" href=\"#navigator对象\">#</a> navigator 对象</h4>\n<p>包含浏览器的信息 我们最常用的属性是 userAgent</p>\n<p><img src=\"js_img/navigator.png\" alt=\"photo\"></p>\n<h4 id=\"history对象\"><a class=\"markdownIt-Anchor\" href=\"#history对象\">#</a> history 对象</h4>\n<p><img src=\"js_img/history%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95.png\" alt=\"photo\"></p>\n<h3 id=\"pc端网页特效\"><a class=\"markdownIt-Anchor\" href=\"#pc端网页特效\">#</a> PC 端网页特效</h3>\n<h4 id=\"元素偏移量offset系列\"><a class=\"markdownIt-Anchor\" href=\"#元素偏移量offset系列\">#</a> 元素偏移量 offset 系列</h4>\n<p>可以动态地获得元素的位移，大小<br>\n<img src=\"js_img/offset%E7%B3%BB%E5%88%97.png\" alt=\"photo\"><br>\n<img src=\"js_img/%E8%BF%94%E5%9B%9E%E7%88%B6%E4%BA%B2%E7%9A%84%E5%8C%BA%E5%88%AB.png\" alt=\"photo\"></p>\n<h5 id=\"offset和style的区别\"><a class=\"markdownIt-Anchor\" href=\"#offset和style的区别\">#</a> offset 和 style 的区别</h5>\n<p><img src=\"js_img/offset%E5%92%8Cstyle%E7%9A%84%E5%8C%BA%E5%88%AB.png\" alt=\"photo\"></p>\n",
            "tags": [
                "前端"
            ]
        }
    ]
}