<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C语言</title>
      <link href="/2021/11/06/c-yu-yan/"/>
      <url>/2021/11/06/c-yu-yan/</url>
      
        <content type="html"><![CDATA[<h1 id="c语言"><a class="markdownIt-Anchor" href="#c语言">#</a> C 语言</h1><!-- The Article Made by YogMas --><h2 id="the-article-made-by-yogmas"><a class="markdownIt-Anchor" href="#the-article-made-by-yogmas">#</a> The Article Made by YogMas</h2><p>推荐用书: C Primer Plus (本文章绝大部分内容来自于关于此书的学习过程中记录 还有部分来自于 C 语言程序设计第二版)</p><h3 id="c语言的执行过程"><a class="markdownIt-Anchor" href="#c语言的执行过程">#</a> C 语言的执行过程</h3><p>1. 预处理：可以给程序添加内容也可以修改程序 (例如: #include&lt;stdio.h&gt; 就会在预处理中运用 stdio.h 中的内容对源代码进行处理)<br> 2. 编译：将预处理过的语言转变为机器指令.<br>3. 链接：把编译器产生的目标代码和所需的其他附加代码整合到一起，产生最终完全可执行的程序.<br>(这三个过程是自动实现的)</p><h3 id="c语言开始"><a class="markdownIt-Anchor" href="#c语言开始">#</a> C 语言开始</h3><h4 id="基本结构"><a class="markdownIt-Anchor" href="#基本结构">#</a> 基本结构</h4><blockquote><p>指令<br> int main (void)<br>{<br>语句<br>}</p></blockquote><h4 id="指令"><a class="markdownIt-Anchor" href="#指令">#</a> 指令</h4><p>例如 #include &lt;stdio.h&gt; 这条指令说明在编译前将 &lt; stdio.h &gt; 中的信息包含到程序中</p><h4 id="函数"><a class="markdownIt-Anchor" href="#函数">#</a> 函数</h4><p>函数分为两类，一类是程序员写的函数，一类是作为 C 语言实现的一部分提供的函数，我们把后者称为库函数。</p><h4 id="语句"><a class="markdownIt-Anchor" href="#语句">#</a> 语句</h4><p>一种是调用语句 例如 printf (""); 就是调用打印函数，将内容打印在屏幕上</p><p>一种是返回语句<br><strong> C 语言的每条语句都要以；结尾</strong></p><h4 id="注释"><a class="markdownIt-Anchor" href="#注释">#</a> 注释</h4><blockquote><pre><code>/*     */ </code></pre></blockquote><p>注释中的内容不会计入到程序中，只是方便程序员观看理解内容</p><p>“盒子形状” 注释</p><blockquote><pre><code>    /*************************    *                        *    *                        *    *************************/</code></pre></blockquote><p>如此可以方便程序员更好地观察到注释</p><p>C99 提供了另一种注释的方法</p><blockquote><pre><code>// XXXXXXXXX  双斜杠注释   这种风格的注释会在行末自动终止，注释第二行还应该添加双斜杠</code></pre></blockquote><p>优点：多行 // 可以让注释更加醒目，由于每一行都必须添加 // 可以有效防止注释吞没程序的事情发生</p><h4 id="变量和赋值"><a class="markdownIt-Anchor" href="#变量和赋值">#</a> 变量和赋值</h4><p>程序进行一系列的运算，会有一种临时存储数据的方法，这种储存单元被称为变量</p><h4 id="类型"><a class="markdownIt-Anchor" href="#类型">#</a> 类型</h4><p>每个变量都有一个类型，来说明所储存的数据的种类<br>列入 int (整数) 类型和 float (小数) 类型</p><p>同时 float 类型可以储存的数可以比 int 大很多，但是坏处就是 float 的计算可能更加缓慢，而且会造成一定量的误差</p><h4 id="声明"><a class="markdownIt-Anchor" href="#声明">#</a> 声明</h4><p>声明变量首先确定变量的类型，然后说明变量的名字<br> eg int height<br>int 就是变量的类型，而 height 就是变量的名字<br><strong> main 的声明要放在语句之前</strong></p><h4 id="赋值"><a class="markdownIt-Anchor" href="#赋值">#</a> 赋值</h4><p>变量通过赋值语句获得值</p><blockquote><pre><code>eg: height=8</code></pre></blockquote><p>这种确定的数值称为常量<br>赋值右侧可以是一个含有常量，变量和运算符的公式，在 C 语言中称为<strong>表达式</strong></p><h4 id="显示变量的值"><a class="markdownIt-Anchor" href="#显示变量的值">#</a> 显示变量的值</h4><blockquote><p>eg:pritnf("%d \n",height)</p></blockquote><p>这里 % d 是一个占位符，用来指明在显示过程中变量 height 的显示位置</p><p>% d 只用于 int     % f 用于 float 类型变量 f 显示小数点后六位，没有的用 0 补齐<br><strong>注意声明和赋值可以同时进行</strong></p><blockquote><p>eg: int weight=8</p></blockquote><p>需要注意的是，以下这种情况只有 width 拥有初始化器 10</p><blockquote><p>int height,length,width=10</p></blockquote><h4 id="宏定义给常量命名"><a class="markdownIt-Anchor" href="#宏定义给常量命名">#</a> 宏定义给常量命名</h4><blockquote><p>eg:#define INCHES 166</p></blockquote><p>在后面的程序中所有的 INCHES 都会被替换成 166，这里需要注意的，一般宏定义的名称都用大写字母表示，这里没有硬性规定，但这是程序员遵循了几十年的基本准则，可以方便程序更方便的阅读<br>同样后面的 166 也可以为一个表达式，表达式建议用括号括上<br><strong>注意 C 语言四舍五入时向下取整</strong></p><h4 id="标识符"><a class="markdownIt-Anchor" href="#标识符">#</a> 标识符</h4><p>在编写程序时，需要进行大量的命名，这些名字被称为<strong>标识符</strong>，在 C 语言中标识符可以有字母，数字，和下划线，但是必须<strong>以字母或者下划线开头</strong></p><p>同时标识符是区分大小写的也就是说 JOB 和 job 是两个完全不同的标识符</p><h4 id="关键字"><a class="markdownIt-Anchor" href="#关键字">#</a> 关键字</h4><p>关键字对 C 编译器有着特殊的意义，因此这些关键字不能作为标识符来使用</p><p><a href="https://imgtu.com/i/IQ9uZQ"><img src="https://z3.ax1x.com/2021/11/06/IQ9uZQ.md.jpg" alt="IQ9uZQ.md.jpg"></a></p><h4 id="书写规范"><a class="markdownIt-Anchor" href="#书写规范">#</a> 书写规范</h4><p>语句可以分开放在任意多行内。<br>记号间的宫格可以让我们更容易区分记号，基于这个原因，我通常会在每个运算符的前后都放上一个空格</p><blockquote><pre><code> eg volume = height * width * length</code></pre></blockquote><p>缩进有助于轻松识别程序嵌套</p><p>空行可以把程序分为逻辑单元，从而使读者更容易辨别程序的结构，没有空行的程序很难阅读，就像不分章节的书一样.</p><h3 id="格式化输入输出"><a class="markdownIt-Anchor" href="#格式化输入输出">#</a> 格式化输入 / 输出</h3><h4 id="printf函数"><a class="markdownIt-Anchor" href="#printf函数">#</a> printf 函数</h4><blockquote><pre><code>   printf(" i = %d , j = %d",i,j);   printf(格式化字符串,表达式1，表达式2,...;)</code></pre></blockquote><p>格式化字母串包含<strong>普通字符</strong>和<strong>转换说明</strong><br>转换说明以 % 开头，% 后面的信息指定了把数值从内部形式转换为打印字母的方法<br> eg:% d 表示把 int 型数值从二进制转换成十进制的字符串</p><p>注意编译器不会检测格式串中转换说明的数量是否和输出项的数量相匹配，但是如果多于或者少于会让程序简单地无意义地输出<br>如果转换说明的个数小于变量数，多的变量就无法显示出来<br>变量和占位符不匹配时，就是显示出一个无意义的数值.<br><a href="https://imgtu.com/i/IQ9FPI"><img src="https://z3.ax1x.com/2021/11/06/IQ9FPI.png" alt="IQ9FPI.png"></a></p><h5 id="转换说明"><a class="markdownIt-Anchor" href="#转换说明">#</a> 转换说明</h5><h5 id="标志"><a class="markdownIt-Anchor" href="#标志">#</a> 标志</h5><p>-: 左对齐，也就是加空格或 0 时加在后面<br>不加 - 默认为右对齐，也就是加空格或 0 时加在前面</p><p>0: 加 0 表示用空格代替 0，不加 0 时输出的值多的用空格代替</p><h6 id="最小栏宽m"><a class="markdownIt-Anchor" href="#最小栏宽m">#</a> 最小栏宽 m</h6><p>最小栏宽 m 指定了要显示的最少字符数量 (<strong>m 表示了输出的数最少占几列</strong>)，如果要系那是的字符数少于 m，那么值在字段内是右对齐的 (换句话说，在值得前面显示空格)<br> 例如 %4d 将以<strong>空格 123</strong> 的形式显示数 123，如果要显示的值所需字符多于 m，那么栏宽会自动拓展为所需的尺寸。因此，转换说明 %4d 将以 12345 的形式显示数 12345，而不会丢失数字。在 m 前放上一个负号，会导致左对齐；转换说明 %-4d 将以<strong> 123 空格</strong>的形式显示 123</p><h6 id="精度p"><a class="markdownIt-Anchor" href="#精度p">#</a> 精度 p</h6><p>精度的含义很难 6+<br>+ 描述，因为他依赖于转换指定符号<br> d:p 指明了待限制数字的最少个数 (包括空格)<br>, 如果省略 p，则默认它的值为 1<br>e: 表示科学计数法形式的浮点数。p 指明了小数点后应该出现的数字个数 (默认值为 6) 如果 p 为 0 则不显示小数点<br> g: 自动选 f 格式或 e 格式中较短的一种输出，且不输出无意义的 0<br>o：无符号数转化为八进制数<br> x：无符号数转化为十六进制数<br><a href="https://imgtu.com/i/IQ9ARP"><img src="https://z3.ax1x.com/2021/11/06/IQ9ARP.png" alt="IQ9ARP.png"></a><br><a href="https://imgtu.com/i/IQ9Exf"><img src="https://z3.ax1x.com/2021/11/06/IQ9Exf.png" alt="IQ9Exf.png"></a></p><h5 id="转义序列"><a class="markdownIt-Anchor" href="#转义序列">#</a> 转义序列</h5><p>警报响铃符:    \a<br> 回退符:     \b<br> 换行符:     \n<br> 水平制表符：   \t<br>“:”( \  + 特殊字符 = 特殊字符 )</p><h4 id="scanf函数"><a class="markdownIt-Anchor" href="#scanf函数">#</a> scanf 函数</h4><blockquote><p>scanf ("&amp;d", 变量名)</p></blockquote><p>scanf 函数起到读取用户输入到屏幕的数据<br> pritnf 函数起到将程序中的数据显示到屏幕上的作用<br> scanf 与 prinf 函数是相对的<br> scanf 函数的工作原理 这里不一一叙述<br>可见程序与设计第 32 页 3.2.1</p><p>另外 % i 也可以充当整数的占位符，在 printf 中与 % d 没有区别，但是在 scanf 中 % i 可以储存 10 进制，8 进制，16 进制的数字，而 % d 只能储存 10 进制的数字，如果输入的数前面有 0 那么 % i 会当成 8 进制处理，如果前面有 0x 那么输入的数会当成 16 进制处理，所以一般情况下我们坚持使用 % d，防止因为在数字前面加入 0 而导致数据识别错误</p><h4 id="表达式"><a class="markdownIt-Anchor" href="#表达式">#</a> 表达式</h4><h5 id="算术运算符"><a class="markdownIt-Anchor" href="#算术运算符">#</a> 算术运算符</h5><blockquote><p>一元运算符: + 正号  - 负号<br>二元运算符: + 加法 - 减法  * 乘法  / 除法 % 求余</p></blockquote><p>可能产生的意外结果</p><blockquote><p>两个操作数都是整数时，结果会进行四舍五入，例如 1/2 的结果是 0 而不是 0.5<br>% 要求操作数是整数 如果两个操作数中有一个不是整数，程序将无法编译通过<br>根据 C89 标准，如果两个运算符中有一个为负数，那么结果不确定，可能向上取整，也可能向下取整<br>在 C99 标准中 除法的结果总是趋向 0 截取    i% j 的结果的值得负号与 i 相同 例如 - 9%7 的结果为 - 2</p></blockquote><h5 id="优先级和结合性"><a class="markdownIt-Anchor" href="#优先级和结合性">#</a> 优先级和结合性</h5><blockquote><p>最高优先级: + - (一元运算符)  *  /  %<br> 最低优先级:    +  -  (二元运算符)</p></blockquote><p>当有多个相同优先级的符号时，从左到右依次结合.<br><a href="https://imgtu.com/i/IQ99VH"><img src="https://z3.ax1x.com/2021/11/06/IQ99VH.png" alt="IQ99VH.png"></a></p><h5 id="赋值运算符"><a class="markdownIt-Anchor" href="#赋值运算符">#</a> 赋值运算符</h5><p>求出表达式的值后，将值储存在变量中，就需要对变量进行赋值</p><p>如果变量表示的含义和所输入的数字不同，将会把数字改成变量所对应的数字<br>例如: int i=72.999   这个时候 i 对应的值就是 72 而不是 72.999</p><p>多个运算符可以串联在一起<br> i = j = k = 0;<br> 需要注意的是，赋值表达式是从右开始赋值的<br> i = (j = (k = 0))</p><h5 id="左值"><a class="markdownIt-Anchor" href="#左值">#</a> 左值</h5><p>大多数 C 语言运算符允许他们的操作数是变量，常量，或者是其他运算符表达式，但是他们的<strong>左值</strong>必须是对象</p><p>目前为止<strong>变量</strong>是唯一的左值</p><h5 id="复合赋值"><a class="markdownIt-Anchor" href="#复合赋值">#</a> 复合赋值</h5><blockquote><p>复合运算符 -=,*=,/=,%=,+=<br> 另外 5 种赋值运算符将在后面的章节中介绍</p></blockquote><p>v += e 表示 v 加上 e 再把结果储存在 v 中<br>这并不等价于 v = v+e 例如变量 i*=j+k 就不等于 i= i*j + k</p><p>复合赋值运算符同样也是右结合的<br>语句 i += j += k 表示 i += (j += k)</p><p>最常使用的两种运算是 自增和自减<br>例如 i = i + 1 而复合运算符可以缩短这串代码 可以改写为 i += 1</p><h5 id="自增运算符和自减运算符"><a class="markdownIt-Anchor" href="#自增运算符和自减运算符">#</a> 自增运算符和自减运算符</h5><p>C 语言还允许使用 ++ (自增) 和 – (自减) 运算符将这些语句缩得更短<br>实际上自增和自减运算符的使用非常复杂，原因是 ++ 和 -- 既可以作为前缀，也可以作为后缀，根据实际使用情况而定</p><p>而这种情况实际上是有副作用的，副作用的效果就是自增 i</p><p>前缀自增和后缀自增的区别：前缀自增表示先自增 i 再将变量 i 代入表达式中，后缀自增表示先把变量 i 代入表达式中，再自增 i</p><p>并且在同一个句子中多次使用 ++ 和 -- 往往难以理解，例如<br> i = 1; j = 2 ; k = <ins>i + j</ins>;</p><p>后缀<ins>和 -- 优先级 比正号和负号高，并且都是左结合<br>前缀</ins>和 -- 优先级和正号负号相同，并且都是右结合</p><h4 id="选择语句"><a class="markdownIt-Anchor" href="#选择语句">#</a> 选择语句</h4><h5 id="逻辑表达式"><a class="markdownIt-Anchor" href="#逻辑表达式">#</a> 逻辑表达式</h5><p>测试表达式的结果是 "真" 还是 "假"，这类表达式只有这两个效果，翻译为电脑语言就是这个表示只会输出两个值 0 或者 1<br><a href="https://imgtu.com/i/IQ9ZM8"><img src="https://z3.ax1x.com/2021/11/06/IQ9ZM8.png" alt="IQ9ZM8.png"></a><br> 逻辑运算符对操作数进行短路计算，这些运算符首先计算出左操作数的值，然后计算出右操作数的值，如果做操作数的值可以直接推导表达式的值，那么将不计算右操作数的值</p><p>运算符！的优先级等于一元正负号的优先级，而运算符 &amp;&amp; 和 || 的优先级低于关系运算符和判等运算符，运算符！是右结合的，而运算符 &amp;&amp; 和运算符 || 是左结合的.</p><h5 id="关系运算符"><a class="markdownIt-Anchor" href="#关系运算符">#</a> 关系运算符</h5><p><a href="https://imgtu.com/i/IQ9PIA"><img src="https://z3.ax1x.com/2021/11/06/IQ9PIA.png" alt="IQ9PIA.png"></a></p><p>需要注意的是 i &lt; j &lt; k 并不是所想象的 j 处在 i 和 k 的中间值得意思，表达式是左结合的<br>所以原式式 (i &lt; j) &lt; k  先对 i &lt; j 进行判定，输出 0 或者 1 来和 k 进行比较</p><h5 id="判等运算符"><a class="markdownIt-Anchor" href="#判等运算符">#</a> 判等运算符</h5><p><a href="https://imgtu.com/i/IQ9esS"><img src="https://z3.ax1x.com/2021/11/06/IQ9esS.png" alt="IQ9esS.png"></a></p><p>i &lt;j == j &lt; k 等价于 (i &lt; j) == (j &lt; k)<br> 只有当 两边同为真或者同为假的时候 输出结果为真</p><h5 id="运算顺序"><a class="markdownIt-Anchor" href="#运算顺序">#</a> 运算顺序</h5><p>C 语言对括号的运算顺序没有进行规定，所以因为编译器的不同可能出现不同的结果<br>例如 a = 5 ;<br>c = (b = a + 2 ) - ( a = 1 )<br> 先算 b = a + 2 还是先算 a = 1 不同的编译器有着不一样的算法，所以如果编译器不同，可能产生不一样的结果</p><p>注意不要依赖特定的运算顺序</p><p>例如: i = 2 ;  j = i * i++;<br> 大部分人可能会认为输出的结果是 4，其实也可能为 6，不同的编译器有时候会出现不同的结果<br>最好的方法就是将长的运算表达式转化为短的运算表达式，如此就可以适应不同的编译器.</p><h4 id="if语句"><a class="markdownIt-Anchor" href="#if语句">#</a> if 语句</h4><blockquote><p>if (表达式) 语句</p></blockquote><p>注意表达式两边的括号是必须的<br>计算时先计算括号内表达式的值，如果表达式的值非零也就是真值，那么接着执行括号后面的语句.<br> 一定要注意区分 ==(判等) 和 =(赋值)<br> 前面我们说了例如 i &lt; j &lt; k 这样的写法是不行的，为了判定变量是否落在某个数值范围内，例如为了判定 0≤ i &lt; n 我们可以写成</p><blockquote><p>if (0 &lt;= i &amp;&amp; i&lt; n) …</p></blockquote><p>|| 运算符也是相同的道理</p><h5 id="复合语句"><a class="markdownIt-Anchor" href="#复合语句">#</a> 复合语句</h5><p>在 if 语句模板中，语句是一条语句而不是多条语句，如果想用 if 语句处理多条语句，我们引入了复合语句.<br> 复合语句由一对花括号和语句混合而成，可以有多个声明和多个语句，也可以什么都没有<br>为了表示清楚，通常将一条语句放在多行内，每行有一条语句，如下所示:<br>{<br>line_num = 0;<br>page_num++;<br>}<br> 注意，每条内部语句依然以<strong>分号</strong>结尾</p><h5 id="else子句"><a class="markdownIt-Anchor" href="#else子句">#</a> else 子句</h5><p>if 语句可以有 else 子句</p><blockquote><p>if (表达式) 语句 else 语句</p></blockquote><p>注意，出现的语句末尾都要以<strong>分号</strong>结尾</p><p>通常来说为了布局美观，和清楚显示代码，我们将 if 和 else 放在同一列，其内的内部语句同样进行缩进<br>可以为复合语句增加花括号，这不是必需的但是能够使复合语句更加清楚.</p><h4 id="条件表达式"><a class="markdownIt-Anchor" href="#条件表达式">#</a> 条件表达式</h4><blockquote><p>表达式 1 ? 表达式 2 : 表达式 3</p></blockquote><p>表达式 1,2,3 可以是任何类型的表达式，同时条件表达式被经常称为三元运算符.</p><p>条件表达式读作 如果表达式 1 成立，那么表达式 2，否则表达式 3<br> 求值步骤为：首先计算出表达式 1 的值，如果此值不为 0，那么计算表达式 2 的值，并且计算出来的值就是整个表达式的值，如果表达式 1 的值为 0，那么表达式 3 的值是整个条件表达式的值</p><p>条件表达式通常运用于 printf 中进行简化代码</p><p>例如 if (i&gt; j ) printf ("% d \n",i); else printf ("% d \n",j);<br> 可以简化为  printf ("% d \n",i&gt;j?i:j);<br> 同时在 return 中也经常使用，使用场景类似</p><h4 id="switch语句"><a class="markdownIt-Anchor" href="#switch语句">#</a> switch 语句</h4><p>通常来说可以用 switch 语句来代替级联式 if 语句</p><blockquote><p>switch (表达式) {<br>case 常量表达式：语句<br>…<br>case 常量表达式：语句<br> default : 语句<br>}</p></blockquote><p>同样这里的语句也要以<strong>分号</strong>结尾<br><a href="https://imgtu.com/i/IQ9mqg"><img src="https://z3.ax1x.com/2021/11/06/IQ9mqg.jpg" alt="IQ9mqg.jpg"></a></p><p>switch 语句实际上是一种给予计算的跳转。对控制表达式求值时， 控制会跳转到与 switch 表达式的值相匹配的分支标号处。在执行完一个分支后，程序控制向下跳转到下一个分支的第一条语句上，如果没有 break 语句，控制将从一个分支继续流向下一个分支。例如<br> switch (grade) {<br>case 4 :printf (“Excellent”);<br>case 3 :printf (“Good”);<br>case 2 :printf (“Average”);<br>case 1 :printf (“poor”);<br>case 0 :printf (“Falling”);<br>default : printf (“Illegal grade”)<br>}<br> 当你输入 3 时，显示的消息是：GoodAveragePoorFailingIllegal grade</p><h3 id="循环"><a class="markdownIt-Anchor" href="#循环">#</a> 循环</h3><h4 id="while语句"><a class="markdownIt-Anchor" href="#while语句">#</a> while 语句</h4><blockquote><pre><code>[while语句]:    while (表达式) 语句例如: while(i&lt;n) i=i*2;</code></pre></blockquote><p>因为 while 语句中有循环，为了让循环更简单，我们可以将 i++ 或者 i–直接加到 printf 中来使代码更加简洁</p><blockquote><pre><code>例如: while(i&gt;0) printf("%d \n",i--)这串代码可以一直输出0~i的数字，是不是这样更加简洁</code></pre></blockquote><h4 id="do语句"><a class="markdownIt-Anchor" href="#do语句">#</a> do 语句</h4><p>do 语句在本质上其实就是 while 语句只不过其控制表达式是在每次执行完循环体之后进行判定.</p><blockquote><pre><code>[do语句]: do 语句  while(表达式):</code></pre></blockquote><p>do 语句的循环体必须是一条语句和 while 一样，当然如果想用多条语句可以用复合语句.</p><p>执行 do 语句时，先执行循环体，再计算控制表达式的值</p><h4 id="for语句"><a class="markdownIt-Anchor" href="#for语句">#</a> for 语句</h4><blockquote><pre><code>[for语句]    for(表达式1或者声明;表达式2;表达式3)</code></pre></blockquote><p><a href="https://imgtu.com/i/IQpd8P"><img src="https://z3.ax1x.com/2021/11/06/IQpd8P.png" alt="IQpd8P.png"></a></p><p>对于向上增或向下减的循环来说，for 语句通常是最好的选择</p><p>从 0 向上加到 n-1</p><blockquote><pre><code>for (i=0;i&lt;n;i++)</code></pre></blockquote><p>从 1 向上加到 n</p><blockquote><pre><code>for(i=1;i&lt;=n,i++)</code></pre></blockquote><p>等等同理</p><p>如果所需要的语句没有那么多，for 语句允许省略语句，注意，即使省略了表达式，括号中也许有两个<strong>分号</strong><br>当 for 语句同时省略第一个和第三个表达式时，那么他和 while 语句没有任何区别<br>省略第一个语句时，程序会默认为真值，会一直循环下去</p><p>在 C99 中第一个表达式可以替换成一个声明，但在 for 语言中的声明，仅可以在 for 语句内部使用，在 for 循环的外部不可用</p><p>同时 for 语言中可以声明多个变量，但是他们的类型需要相同</p><h4 id="逗号运算符"><a class="markdownIt-Anchor" href="#逗号运算符">#</a> 逗号运算符</h4><blockquote><pre><code>[逗号表达式] 表达式1,表达式2</code></pre></blockquote><p>第一步计算出表达式 1 的值，抛弃。第二部计算出表达式 2 的值，并将表达式 2 的值作为整个表达式的值，需要注意的是这里并不是说表达式 1 的值并没有用，表达式 1 中例如 i++，i–等仍然会对表达式 2 中的 i 和 j 造成一定的影响</p><p>逗号运算符是左结合的，并且逗号运算符的优先级比其他所有运算符的优先级都更低</p><p>for 语句是唯一可以发现逗号运算符的地方.<br>for 语句可以利用逗号表达式来声明更多的变量</p><h3 id="跳出循环"><a class="markdownIt-Anchor" href="#跳出循环">#</a> 跳出循环</h3><h4 id="break语句"><a class="markdownIt-Anchor" href="#break语句">#</a> break 语句</h4><p>前面讨论过 break 语句跳出 switch 语句，同时 break 语句还可以用于跳出 while,do,for 循环</p><p>需要注意的时，如果有嵌套的情况存在，break 语句只能跳出一层循环</p><h4 id="continue语句"><a class="markdownIt-Anchor" href="#continue语句">#</a> continue 语句</h4><p>continue 语句与 break 语句的区别在于，break 语句把程序控制转移到循环体末尾之后，而 continue 语句刚好把程序控制转移到循环体末尾之前.<br>continue 语句会把程序控制留在循环内，而 break 语句会使程序控制跳出循环<br> continue 语句只能用于循环，而 break 语句可以用于 switch 语句和循环</p><p>continue 语句不会跳出循环，但会直接跳过 continue 之后的一系列语句，重新开始循环</p><h4 id="goto语句"><a class="markdownIt-Anchor" href="#goto语句">#</a> goto 语句</h4><p>goto 语句可以跳转到函数中任何有<strong>标号</strong>的语句处</p><blockquote><pre><code>[标号语句]  标识符:语句[goto语句]  goto 标识符;</code></pre></blockquote><p>两个语句必须在同一个函数中<br> goto 语句对于嵌套循环的退出是很有用的</p><h4 id="空语句"><a class="markdownIt-Anchor" href="#空语句">#</a> 空语句</h4><blockquote><pre><code>eg:for(XX;XX;XX);</code></pre></blockquote><p>空语句的一个好处：编写空循环体的循环.<br>C 程序员习惯性地把空语句单独放置在一行</p><h3 id="基本类型"><a class="markdownIt-Anchor" href="#基本类型">#</a> 基本类型</h3><p>C 语言支持两种根本的数据类型 分别是 整数类型 和浮点数类型  简单来说 整数和其他数 (包括小数等等) 的区别</p><h4 id="整数类型"><a class="markdownIt-Anchor" href="#整数类型">#</a> 整数类型</h4><p>正说类型 分为 有符号整数和无符号整数</p><p>有符号整数：如果整数为正数或者 0 那么最左边的符号位为 0; 如果为负数 那么最左边的符号位为 1 储存的时候都是按有符号整数来储存 如果要当成无符号整数来储存 需要声明整数类型为 unsigned<br> 无符号整数：最左边的位是数值的一部分</p><p>C 语言的整数类型 有着不同的大小 int 类型通常为 32 位   有些数字很大 所以 C 语言还提供了 长整型 和 需要很小空间来储存的数 这样的数称为短整型</p><p>整型分为 4 种 long short signed unsigned 他们之间可以互相组合</p><blockquote><pre><code>short intunsigned short intintunsigned intlong intunsigned long int</code></pre></blockquote><p>其他组合都是上述组合的同义词<br> C 语言允许通过省略单词 int 来缩写整数类型的名字<br>但很多基于 c 语言的程序 甚至不允许程序员写 short int 这样的名字 而必须写成 short 或者 long<br> 不同类型的取值范围也可能一样<br> eg: long int 可能和 int 有相同的取值范围  但是 long int 永远不可能比 int 的取值范围短<br><a href="https://imgtu.com/i/IQpcUs"><img src="https://z3.ax1x.com/2021/11/06/IQpcUs.png" alt="IQpcUs.png"></a><br><a href="https://imgtu.com/i/IQpsbQ"><img src="https://z3.ax1x.com/2021/11/06/IQpsbQ.png" alt="IQpsbQ.png"></a><br><a href="https://imgtu.com/i/IQp0v8"><img src="https://z3.ax1x.com/2021/11/06/IQp0v8.png" alt="IQp0v8.png"></a><br> 但是这种范围会随着编译器的不同而不同 好的解决方法是检查 &lt;limis.h&gt; 头文件定义了每种整数类型的最大值和最小值的宏<br> C99 新增了 2 个 long long int 和 unsigned long long int</p><h5 id="整数常量"><a class="markdownIt-Anchor" href="#整数常量">#</a> 整数常量</h5><p>常量：在程序中以文本形式出现的数，而不是读，写，计算出来的数.C 语言允许用十进制，八进制，十六进制来表示常量</p><p>十进制不能以 0 开头 八进制必须以 0 开头 十六进制总是以 0x 开头<br>这里需要注意的是  这些只是书写数的方式 并不会对数的储存方式产生英雄 数都是以二进制储存的 所以我们进行计算的时候甚至可以将他们三个混合使用 程序仍然能够识别 并且计算出值<br>十进制整数常量的类型同城为 nit 但如果常量的值大得无法储存在 int 型中 那就用 long int 类型。如果出现 long int 还不够用的罕见情况 编译器会用 unsigned long int 做最后的尝试<br>八进制和十六进制 会从范围最小的整数型开始尝试 直至找到能表示该常量的类型</p><p>要强制编译器把常量作为长整数来处理，只需要在后边加上一个字母 L/l  <strong>大小写无所谓</strong><br>同样 要指明是无符号变量 可以在常量后边加上字母 U/u<br><strong>L 和 U 可以混合使用 顺序和大小都无所谓</strong></p><h5 id="c99中的整型变量"><a class="markdownIt-Anchor" href="#c99中的整型变量">#</a> C99 中的整型变量</h5><p>在 C99 中 出现了 LL (long long) 在 ll 前面 U 的通常是 unsigned long long  需要注意的是 <strong>这里两个 l 的大小写需要一致</strong><br>十进制储存 按照 int      long int   long long int 中的最小的能适合的方式储存<br>而八进制和十六进制 按照 int        unsigned int          long int           unsigned long int   ……</p><h5 id="整数溢出"><a class="markdownIt-Anchor" href="#整数溢出">#</a> 整数溢出</h5><p>对整数执行算数运算时，其结果有可能因为太大而无法显示，这时候就会发生整数溢出<br>有符号整数溢出时 会出现没有定义的情况 无法预估最后会发生的情况<br>无符号整数溢出时 结果会有定义的：正确答案对 2 的 n 次方取模 例如 65535+1 的结果 (能够被 2 除尽) 其结果可以保证为 0</p><h5 id="读写整数"><a class="markdownIt-Anchor" href="#读写整数">#</a> 读 / 写整数</h5><p>通常我们发生整数溢出时，会马上去更换整数类型 但单单这样做是不够的 我们还必须检查数据类型的改变对程序其他部分的影响</p><p>读写无符号整数时 使用 u,o,x 代替转换说明中的 d<br>u 表示十进制 o 表示八进制 x 表示十六进制</p><p>读写短整数时 在 d,o,x 或者 u 前面加上字母 h</p><p>读写长整数时，在 d,o,x 或者 u 前面加上字母 l</p><p>读写尝尝整数时，在 d,o,x 或者 u 前面加上字母 ll</p><h4 id="浮点类型"><a class="markdownIt-Anchor" href="#浮点类型">#</a> 浮点类型</h4><p>float: 单精度浮点数<br> double: 双精度浮点数<br> long double: 扩展精度浮点数</p><p>C 语言没有明确的说明精度到底是多少 不同的计算机可以以不同的方法储存浮点数</p><p>数值是由三部分组成：符号，指数和小数 指数部分的位数说明了数值可能大小程度 而小数部分的位数说明了精度<br><a href="https://imgtu.com/i/IQpwgf"><img src="https://z3.ax1x.com/2021/11/06/IQpwgf.png" alt="IQpwgf.png"></a><br>long double 类型没有出现在表中 因为它的长度随着机器的不同而变化 最常见的大小是 80 位和 128 位</p><p>C99 中 浮点类型分为两种 一种是实浮点类型 包括 float,double,long double 类型<br>另一种是 C99 新增的复数类型  包括 float ,_Complex ,double ,_Complex ,long double _Complex</p><h5 id="浮点常量"><a class="markdownIt-Anchor" href="#浮点常量">#</a> 浮点常量</h5><p>浮点常量必须包括小数点或者指数 其中指数指明了对前面的数进行缩放所需的 10 的幂次 如果有指数 则需要在指数数值前放置字母 E 或者 e 可选符号 + 或者 - 可以出现在字母 E 或者 e 的后边 为了表明只需要单精度 可以在常量的末尾处加上字母 F/f; 而为了说明常量必须以 long double 的形式储存可以在常量的末尾处 加上字母 L 或者 l</p><h5 id="读写浮点数"><a class="markdownIt-Anchor" href="#读写浮点数">#</a> 读写浮点数</h5><p>前面已讨论过，转换说明 % e,% f 和 % g 用于读写单精度浮点数 读写 double 和 long double 类型的值所需的转换说明略有不同<br>读写 double 类型的值时，在 e,f,g 前面放置字母 l   <strong>注意只能在字符串 scanf 中使用 在 printf 函数调用中使用额 e,f,g 可以用来写 float 类型或者 double 类型的值</strong><br>读写 long double 类型时，在 e,f,g 前面放置字母 L<br><strong> 注意 double 和 long double 这里有字母大小写的区别</strong></p><h4 id="字符类型char"><a class="markdownIt-Anchor" href="#字符类型char">#</a> 字符类型 char</h4><p>当前最常用的字符集是 ASCII 字符集，用 7 位代码表示 128 个字符<br> char 类型的变量可以用任意单字符赋值</p><h5 id="字符操作"><a class="markdownIt-Anchor" href="#字符操作">#</a> 字符操作</h5><p>C 语言将字符当做整数进行处理 毕竟所有的字符都是以二进制的形式进行编码的</p><blockquote><pre><code>char ch;ch = 65      此时ch是Ach = ch+1    此时ch是B</code></pre></blockquote><h5 id="有符号字符和无符号字符"><a class="markdownIt-Anchor" href="#有符号字符和无符号字符">#</a> 有符号字符和无符号字符</h5><p>char 类型像整数类型一样存在符号性和无符号性两种 通常有符号型的取值是 - 128~127 而无符号字符的取值是 0~255<br> 所有 C 语言允许单词 signed 和 unsigned 来修饰 char 类型</p><h4 id="算数类型"><a class="markdownIt-Anchor" href="#算数类型">#</a> 算数类型</h4><p><a href="https://imgtu.com/i/IQp6Ej"><img src="https://z3.ax1x.com/2021/11/06/IQp6Ej.png" alt="IQp6Ej.png"></a></p><h4 id="转义序列-2"><a class="markdownIt-Anchor" href="#转义序列-2">#</a> 转义序列</h4><p>转义序列分为字符转义序列和数字转义序列</p><h5 id="字符转义序列"><a class="markdownIt-Anchor" href="#字符转义序列">#</a> 字符转义序列</h5><p><a href="https://imgtu.com/i/IQprDg"><img src="https://z3.ax1x.com/2021/11/06/IQprDg.png" alt="IQprDg.png"></a></p><h5 id="数字转义序列"><a class="markdownIt-Anchor" href="#数字转义序列">#</a> 数字转义序列</h5><p>字符转义序列没有包含所有无法打印的 ASCII 字符 字符转义序列也无法包含 128 个 ASICC 字符以外的字符 而数字转义字符可以表示任何字符 所有它可以解决上述问题</p><p>作为字符常量来使用时，<strong> 转义序列必须用一堆单引号括起来</strong></p><h4 id="字符处理函数"><a class="markdownIt-Anchor" href="#字符处理函数">#</a> 字符处理函数</h4><p>例如 toupper 函数可以将小写字母转化为大写字母 但要调用这类使用的字符处理函数 需要在顶部放置 #include &lt;ctype.h&gt; 这一条指令</p><h5 id="用scanf-和printf读写字符"><a class="markdownIt-Anchor" href="#用scanf-和printf读写字符">#</a> 用 scanf 和 printf 读写字符</h5><p>scanf 读写字符时 并不会跳过空白字符 为了强制 scanf 在读入字符前跳过空白字符，需要在格式串中的转换说明 % C 前面加上一个空格</p><h5 id="用getchar和putchar用于读写字符"><a class="markdownIt-Anchor" href="#用getchar和putchar用于读写字符">#</a> 用 getchar 和 putchar 用于读写字符</h5><p>getchar 函数和 putchar 函数可以用来取代 scanf 和 printf 函数 putchar 函数用于写单个字符<br>每次调用时他会读写一个字符并将其返回 为了保存这个字符 必须使用赋值操作将其储存在变量中<br>当混用 getchar 函数和 scanf 函数要小心 scanf 函数仅消耗掉匹配的输入数据 其余部分仍然留在缓冲区 (包括换行符)</p><h4 id="类型转换"><a class="markdownIt-Anchor" href="#类型转换">#</a> 类型转换</h4><h5 id="隐式类型转换规则"><a class="markdownIt-Anchor" href="#隐式类型转换规则">#</a> 隐式类型转换规则</h5><p>较低级向较高级转换 (按存储长度)<br> 其中有一个操作数是浮点型时 把整型操作数往浮点型转换 而浮点型往精度更高的浮点型转换<br>两个操作数都不是浮点数时，如果有 char 或者 short int 类型 首先对两个操作数进行整型提升<br><strong>特例</strong>:long int 和 unsigned int 数据类型长度相同时 则两个操作数均转换为 unsigned long<br><a href="https://imgtu.com/i/IQ9FPI"><img src="https://z3.ax1x.com/2021/11/06/IQ9FPI.png" alt="IQ9FPI.png"></a><br> 赋值中的类型转换：把赋值运算符右侧表达式的值转换为左侧变量的类型.</p><h5 id="强制类型转换"><a class="markdownIt-Anchor" href="#强制类型转换">#</a> 强制类型转换</h5><blockquote><pre><code>(类型)变量   eg(char)i  表示把i的类型强制转换为char的类型(类型)(表达式)</code></pre></blockquote><p>这些转换类型只是一次有效的 不会改变变量定义时的数据类型<br> C 语言把类型名视为一元运算符</p><h4 id="类型定义"><a class="markdownIt-Anchor" href="#类型定义">#</a> 类型定义</h4><blockquote><pre><code>typedef 数据类型 别名</code></pre></blockquote><p>用于对另一个数据类型创建一个别名<br>注意并没有创建一个新的类型 仅仅是对某个已有的类型增加一个别名<br>可以让程序更加易于理解 可读性更高</p><h4 id="sizeof-运算符"><a class="markdownIt-Anchor" href="#sizeof-运算符">#</a> sizeof 运算符</h4><p>取数据类型 常量 变量或者表达式值得存储长度的运算符 (以字节为单位)</p><blockquote><pre><code>sizeof(数据类型说明符/表达式)用于类型名 sizeof(类型名)用于表达式 sizeof 表达式</code></pre></blockquote><h3 id="第八章-字符输入输出和输入验证"><a class="markdownIt-Anchor" href="#第八章-字符输入输出和输入验证">#</a> 第八章 字符输入 / 输出和输入验证</h3><h4 id="单字符io-getchar和putchar"><a class="markdownIt-Anchor" href="#单字符io-getchar和putchar">#</a> 单字符 I/O getchar () 和 putchar ()</h4><h4 id="缓冲区"><a class="markdownIt-Anchor" href="#缓冲区">#</a> 缓冲区</h4><p>用户输入的字符被收集并存储在一个被称为缓冲区的临时存储区 按下 enter 键后 程序才可以使用用户输入的字符<br>某些交互式系统无缓冲区 比如游戏中按下一个键需要立即执行按下的操作<br>缓冲区分为完全缓冲和行缓冲</p><blockquote><pre><code>完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区行缓冲指的是在出现换行时刷新缓冲区(键盘输入)</code></pre></blockquote><p>是否能进行无缓冲输入取决于计算机系统 大部分直接规定输入都会缓冲输入</p><h4 id="结束键盘输入"><a class="markdownIt-Anchor" href="#结束键盘输入">#</a> 结束键盘输入</h4><h5 id="文件流和键盘输入"><a class="markdownIt-Anchor" href="#文件流和键盘输入">#</a> 文件，流和键盘输入</h5><h5 id="文件结尾"><a class="markdownIt-Anchor" href="#文件结尾">#</a> 文件结尾</h5><p>方法 1 文件末尾放置一个特殊字符 来标记末尾<br>方法 2 存储文件大小的信息。如果程序有 3000 字节 那么程序在读到 3000 字节的时候便达到文件末尾</p><p>在 C 语言中 用 getchar 或者 scanf 检测文件末尾时都将放回一个特殊值 即 EOF</p><h3 id="第九章函数"><a class="markdownIt-Anchor" href="#第九章函数">#</a> 第九章函数</h3><h4 id="复习函数"><a class="markdownIt-Anchor" href="#复习函数">#</a> 复习函数</h4><h5 id="创建并使用简单函数"><a class="markdownIt-Anchor" href="#创建并使用简单函数">#</a> 创建并使用简单函数</h5><blockquote><pre><code>#include &lt;stdio.h&gt;#define NAME "GIGATHINK,INC"#define ADDRESS "101 Megabuck plaza"#define PLACE "MEGAPOLIS,CA 94904"#define WIDTH 40void starbar(void);int main(void){    starbar();    printf("%s \n", NAME);    printf("%s \n", ADDRESS);    printf("%s \n", PLACE);    starbar(); //使用函数    return 0;}void starbar(void) //定义函数{    int count;    for (count = 1; count &lt;= WIDTH; count++)    {        putchar('*');    }    putchar('\n');}</code></pre></blockquote><h5 id="分析程序"><a class="markdownIt-Anchor" href="#分析程序">#</a> 分析程序</h5><p>函数原型：告诉编译器函数的类型<br>函数调用：表明在此处执行函数<br>函数定义：明确地指出函数要做什么</p><p>函数和变量有一样有多种类型 任何程序在使用函数之前都要声明该函数的类型</p><blockquote><pre><code>void starbar(void);圆括号表示starbar是一个函数名 第一个void是函数类型 void类型表明函数没有返回值 第二个void(圆括号中)表明该函数不带参数。分号表示这是在申明函数不是在定义函数 这行表明了程序将使用一个名为starbar(),没有返回值,没有参数的函数,并告诉编译器在别处查找该函数的定义</code></pre></blockquote><p>一般而言 函数原型指明了函数的返回值类型和函数接受的参数类型 这些信息称为函数的<strong>签名</strong><br>这里对于 starbar () 函数而言 其签名是该函数没有返回值，没有参数<br> starbar () 原型放在任何位置都可以<br>执行顺序:<br> 在 main () 中 当计算机执行到 starbar () 函数时，会找到该函数的定义并执行其中的内容，执行完 starbar () 中的代码后，计算机返回主调函数继续执行下一行<br>函数头包括函数类型，函数名和圆括号，接着是左花括号，变量声明，函数表达式语句，最后以又花括号结束<br> ** 注意函数头中的 starbar () 没有分号 这是在告诉编译器这是定义 starbar ()，而不是调用函数或者声明函数类型<br> starbar () 函数中的 count 变量是局部变量，意思是该变量只属于 starbar () 函数，可以在程序中的其他地方使用 count 这并不会引起名称冲突 他们是同名的不同函数</p><h5 id="函数参数"><a class="markdownIt-Anchor" href="#函数参数">#</a> 函数参数</h5><blockquote><pre><code>void show_n_char(char ch,int num);   shou_n_char('*',12)</code></pre></blockquote><h5 id="定义带形式参数的函数"><a class="markdownIt-Anchor" href="#定义带形式参数的函数">#</a> 定义带形式参数的函数</h5><p>第一行告知编译器 show_n_char 使用两个参数 ch 和 num,ch 是 char 类型 num 是 int 类型。这两个变量被称为形式参数，简称形参。和定义在函数中变量一样 形参也是局部变量属于该函数私有。这以为着在其他函数中使用同名变量不会引起名称冲突 每次调用函数 就会给这些变量赋值<br>值得一提的是 虽然 show_n_char () 接受来自 main () 的值 但是它没有返回值。因此，show_n_char () 的类型是 void</p><h5 id="声明带形式参数函数的原型"><a class="markdownIt-Anchor" href="#声明带形式参数函数的原型">#</a> 声明带形式参数函数的原型</h5><p>使用函数之前要声明函数原型: void shou_n_char (char ch,int num) 当然根据个人喜好 你也可以省略变量名<br>在原型中使用变量名并没有实际创建变量，char 仅代表了一个 char 类型的变量</p><h5 id="调用带实际参数的函数"><a class="markdownIt-Anchor" href="#调用带实际参数的函数">#</a> 调用带实际参数的函数</h5><p>在函数的调用中 实际参数 (简称实参) 提供了 ch 和 num 的值 比如 show_n_char (’*’,12); 这两个值被赋值给函数中的形式参数<br>简而言之形式参数是被调函数中的变量 实际参数是主调函数赋值给被调函数的具体值 实际参数可以是常量变量甚至是更复杂的表达式 无论实际参数是何种形式都要被求值 然后该值被拷贝给被调函数相应的形式参数.</p><h5 id="使用return从函数中返回值"><a class="markdownIt-Anchor" href="#使用return从函数中返回值">#</a> 使用 return 从函数中返回值</h5><blockquote><pre><code>int imin(int n , int m)int imin(int n , int m){int min ;if (n&lt;m) min=n;else min = m;return min;}int a = imin(1,2)</code></pre></blockquote><p>关键字 return 后面的表达式的值就是函数的返回值 在该例中，函数的返回值就是变量 min 的值<br>变量 min 属于 imin () 函数私有 但是 return 语句把 min 的值传回了主调函数<br> return; return 语句还可以这样使用 这样使用 retrun 语句将会终止函数并把控制返回给主调函数</p><h5 id="函数类型"><a class="markdownIt-Anchor" href="#函数类型">#</a> 函数类型</h5><p>声明函数必须声明函数的类型 带返回值的函数类型应该与其返回值得类型相同 没有返回值的函数声明为 void 类型<br><strong>值得注意的是 函数类型指的是函数返回值的类型 而不是参数的类型</strong><br>函数的前置声明可以放在主调函数外面也可以放在主调函数里面<br> ANSIC 标准库中，函数被封城了多个系列，每一个系列都有各自的头文件，这些头文件中包含了本系列所有函数的声明。例如 stdio.h 头文件中包括了标准的 I/O 库函数 (如 printf he scanf 函数) 的声明</p><h4 id="ansi-c-函数类型"><a class="markdownIt-Anchor" href="#ansi-c-函数类型">#</a> ANSI C 函数类型</h4><p>旨在说明老式声明函数的问题所在和解决方案 这里不做过多描述 可自行搜索</p><p>ANSI C 使用了逗号分割的类型列表 eg imax (int a , int b) 如此 编译器可以检查函数调用是否和函数原型匹配 参数的数量是否匹配 参数的类型是否匹配</p><h5 id="无参数和未指定参数"><a class="markdownIt-Anchor" href="#无参数和未指定参数">#</a> 无参数和未指定参数</h5><blockquote><pre><code>void print_name()</code></pre></blockquote><p>接受 ANSI C 的编译器截石位 print_name () 不接受任何参数，然后在调用该函数时，编译器会检查来确保没有使用参数</p><h5 id="函数原型的优点"><a class="markdownIt-Anchor" href="#函数原型的优点">#</a> 函数原型的优点</h5><p>使用函数原型会让编译器捕获在使用函数时可能出现的许多错误或疏漏，如果编译器没有发现这些问题，就很难觉察出来.<br> 有一种方法可以省略函数原型却保留函数原型的优点<br>把整个函数定义放在第一次调用该函数之前，也有相同的效果 此时函数定义也相当于函数原型。对于代码量较少的函数 这种用法很普遍</p><blockquote><pre><code>int imax(int a , int b ) {return a&gt;b?a:b}</code></pre></blockquote><h4 id="递归"><a class="markdownIt-Anchor" href="#递归">#</a> 递归</h4><p>C 允许函数调用他自己 这种调用过程称为<strong>递归</strong><br>难点：结束递归 (如果递归代码中没有终止递归的条件测试部分，一个调用自己的函数就会无限递归)<br> 注：可以使用循环的地方<strong>通常</strong>都可以使用递归</p><h5 id="演示递归"><a class="markdownIt-Anchor" href="#演示递归">#</a> 演示递归</h5><p><a href="https://imgtu.com/i/IlPHk4"><img src="https://z3.ax1x.com/2021/11/06/IlPHk4.jpg" alt="IlPHk4.jpg"></a><br><a href="https://imgtu.com/i/IlPbtJ"><img src="https://z3.ax1x.com/2021/11/06/IlPbtJ.jpg" alt="IlPbtJ.jpg"></a></p><h5 id="递归的基本原理"><a class="markdownIt-Anchor" href="#递归的基本原理">#</a> 递归的基本原理</h5><p>1. 每级函数调用都有自己的变量 也就是说第一级的 n 和第二的 n 不一样 当程序最终返回第一级的时候 最初的 n 仍然是它的初值 1 (局部变量)<br> 2. 每次幻术调用都会返回一次 当函数执行完毕后 控制权将被传回上一级递归。程序必须按照顺序逐级返回递归 不能跳级<br> 3. 递归函数中位于递归调用之前的语句 均按被调函数的顺序执行<br> 4. 递归函数中位于递归调用之后的语句 均按被调函数的<strong>相反</strong>顺序执行<br> 5. 虽然每级递归都有自己的变量 但是并没有拷贝函数的代码，所以程序按顺序执行函数中的代码 而递归调用就相当于又从头开始执行函数的代码 除了为每次递归调用创建变量外 递归调用非常类似于一个循环语句<br> 6. 递归函数必须包含能让递归调用停止的语句。通常递归函数都使用 if 或者其他等价的测试条件在函数形参等于某个特定值时终止递归。为此 每次递归调用的形参都要使用不同的值</p><h5 id="尾递归"><a class="markdownIt-Anchor" href="#尾递归">#</a> 尾递归</h5><p>将递归放置在函数的末尾 即正好在 return 语句之前 这种形式的递归被称为尾递归 相当于循环</p><h5 id="递归和倒序计算"><a class="markdownIt-Anchor" href="#递归和倒序计算">#</a> 递归和倒序计算</h5><p>在处理这类倒序问题时  递归比循环简单</p><h5 id="递归的优缺点"><a class="markdownIt-Anchor" href="#递归的优缺点">#</a> 递归的优缺点</h5><p>优点：为某些编程问题提供了最简单的解决方案，缺点是一些递归算法会快速消耗计算机的内存资源 另外递归不方便阅读和维护<br><strong>在程序中使用递归要格外注意 尤其是效率优先的程序</strong></p><h4 id="编译多源代码文件的程序"><a class="markdownIt-Anchor" href="#编译多源代码文件的程序">#</a> 编译多源代码文件的程序</h4><p>使用多个函数最简单的方法是把他们都放在同一个文件中 然后像编译只有一个函数的文件那样编译该文件即可。其他方法因操作系统而异，下面将举例说明.</p><h5 id="unix"><a class="markdownIt-Anchor" href="#unix">#</a> UNIX</h5><p>假设 filel.c 和 file2.c 是两个内涵 C 函数的文件 下面的命令将编译两个文件并生成一个名为 a.out 的可执行文件:<br>cc filel.c file2.c<br> 另外还生成两个名为 file1.o 和 file2.o 的目标文件。如果后来改动了 filel.c 而 file2.c 不变 可以使用以下命令编译第一个文件 并与第二个文件的目标代码合并<br> cc filel.c file2.o</p><h5 id="linux"><a class="markdownIt-Anchor" href="#linux">#</a> Linux</h5><p>假定 linux 系统安装了 GNU C 编译器 GCC 假设 filel.c 和 file2.c 是两个内含 C 函数的文件 下面的命令将编译两个文件并生成名为 a.out 的可执行文件<br> gcc filel.c file2.c<br> 另外还生成两个名为 file1.o 和 file2.o 的目标文件。如果后来改动了 filel.c 而 file2.c 不变 可以使用以下命令编译第一个文件 并与第二个文件的目标代码合并<br> gcc filel.c file2.o</p><h5 id="dos命令行编译器"><a class="markdownIt-Anchor" href="#dos命令行编译器">#</a> DOS 命令行编译器</h5><p>绝大多数 DIS 命令行编译器的工作员刘和 UNIX 的 CC 命令类似 只不过使用不同的名称而已 其中一个区别是 对象文件的扩展名是.obj 而不是.o 一些编译器生成的不是目标代码文件 而是汇编语言或其他特殊代码的中间文件</p><h5 id="windows和苹果的ide编译器"><a class="markdownIt-Anchor" href="#windows和苹果的ide编译器">#</a> windows 和苹果的 IDE 编译器</h5><p>windows 和 Macintosh 系统使用的集成开发环境中的编译器是面向项目的<br>项目 描述的是特定程序使用的资源 (资源包括源代码文件)<br> 这种 IDE 中的编译器要创建项目来运行单文件程序 对于多文件程序 要使用相应的菜单命令 把源代码文件加入到一个项目中 要确保所有的源代码文件都在项目列表中列出 许多 IDE 都不用在项目列表中列出头文件 (扩展名为.h 的文件) 因为项目只管理使用的源代码文件源代码文件中的 #include 指令管理该文件中使用的头文件 但是 Xcode 要在项目中添加头文件</p><h5 id="使用头文件"><a class="markdownIt-Anchor" href="#使用头文件">#</a> 使用头文件</h5><p>如果把 main () 放在第一个文件中 把函数定义放在第二个文件中 那么第一个文件仍然要使用函数原型<br>把函数原型放在头文件中 就不用再每次使用函数文件时都要写出函数的原型</p><h4 id="查找地址-运算符"><a class="markdownIt-Anchor" href="#查找地址-运算符">#</a> 查找地址: &amp; 运算符</h4><p>指针是 C 语言中最重要的概念之一 用于存储变量的地址。前面使用的 scanf () 函数中就是用地址最为参数<br>一元运算符 &amp; 给出变量的存储地址，如果 posh 是变量名那么 &amp; posh 就是变量的地址 可以把地址看做是变量在内存中的位置<br>不同的变量所处的位置是不同的</p><h4 id="更改主调函数中的变量"><a class="markdownIt-Anchor" href="#更改主调函数中的变量">#</a> 更改主调函数中的变量</h4><p>例如要更改两个数 x,y 的位置 简单地 x = y, y = x 并没有作用<br>下面实现简单地交换值得功能</p><blockquote><pre><code>void interchange(int u ,int v ) {int temp;temp = uu = vv = temp}</code></pre></blockquote><p>虽然这个函数表面上实现了交换的功能 但事实上 调用函数输出结果的时候 并不会交换这两个数值<br>因为在 interchange () 传回的变量并不是 main () 中的变量 (局部变量问题：在函数中的变量虽然表面上和 main 中的变量一样 但是实际上这两个变量是完全不同的 存储地址也不一样的两个变量). 因此交换 u 和 v 的值 对 x 和 y 的值没有影响<br>可以使用 return 语句把值传回 main () 比如 在函数末尾加上 return (u), 然后修改 main 中而定调用 x = interchange (x,y) 但是这只能改变 x 的值 return 语句只能把被调函数中的一个值传回主调函数 但是现在要传回两个值 这就需要指针了 下面开始概述指针</p><h4 id="指针简介"><a class="markdownIt-Anchor" href="#指针简介">#</a> 指针简介</h4><p>指针：一个值为内存地址的变量 (或数据对象)<br><strong> 例如:int 类型变量的值为整数 char 类型变量的值为字符 而指针变量的值为地址</strong></p><blockquote><pre><code>ptr = &amp;pooh</code></pre></blockquote><p>其中 表示 ptr"指向"pooh ptr 和 &amp; pooh 的区别是 ptr 是变量 而 &amp;pooh 是常量<br>这样 ptr 的值 就是 pooh 的地址<br>创建指针变量 要先声明指针变量的类型</p><h5 id="间接运算符解引用运算符"><a class="markdownIt-Anchor" href="#间接运算符解引用运算符">#</a> 间接运算符 (解引用运算符) *</h5><p>间接运算符可以找出存储在内存地址下的值<br>注意分清楚 间接运算符 和 二元乘号运算符 虽然他们长得一样</p><blockquote><pre><code>val = *ptrptr = &amp;bhb上面这串代码就相当于是 val = bhb&amp;后跟一个变量名 表示该变量名的地址*后跟一个地址 或者指针名 表示存储在指针指向地址上的值</code></pre></blockquote><h5 id="声明指针"><a class="markdownIt-Anchor" href="#声明指针">#</a> 声明指针</h5><blockquote><pre><code>int * pi         pi是指向int类型变量的指针char * p         p是指向char类型变量的指针float * pf,*pg   pf,pg是指向float类型变量的指针</code></pre></blockquote><p>其中 * 表明声明的变量是一个指针 前面表示指针指向的类型<br> pi 指向的值是 int 类型 pi 本身叫做 指向 int 类型的指针 pi 的值是一个地址</p><h5 id="使用指针在函数间通信"><a class="markdownIt-Anchor" href="#使用指针在函数间通信">#</a> 使用指针在函数间通信</h5><blockquote><pre><code>void interchange(int * u, int * v){int temp;temp = *u;*u = *v;*v = temp;}interchange(&amp;x,&amp;y)</code></pre></blockquote><p>该函数传递的就不是 x 和 y 的值 而是存储 x 和 y 的值的地址<br>函数中的第二个语句表示 把 u 地址中的值给 temp 第三个语句表示把 V 地址中存储的值赋值给 U 这样 U 地址存储的值变成了 V 地址存储的值第四个语句同样</p><h5 id="小结来自c-primer-plus"><a class="markdownIt-Anchor" href="#小结来自c-primer-plus">#</a> 小结 (来自 C primer Plus)</h5><p><a href="https://imgtu.com/i/IlXp9K"><img src="https://z3.ax1x.com/2021/11/07/IlXp9K.jpg" alt="IlXp9K.jpg"></a><br><a href="https://imgtu.com/i/IlOxtx"><img src="https://z3.ax1x.com/2021/11/07/IlOxtx.jpg" alt="IlOxtx.jpg"></a></p><h4 id="关键概念"><a class="markdownIt-Anchor" href="#关键概念">#</a> 关键概念</h4><p>想用 C 编出高效灵活的程序，必须理解函数.<br> 函数是如何把信息从一个函数传递到另一函数 理解函数参数和返回值之间的工作原理<br>明白函数形参和其他局部变量属于函数私有因此 声明在不同函数中的同名变量是完全不同的变量<br>函数无法直接访问在其他函数中的变量 这样限制访问保护了数据的完整性<br>但是 当确实需要在函数中访问另一个函数的数据时 可以把指针作为函数的参数</p><h4 id="本章小结"><a class="markdownIt-Anchor" href="#本章小结">#</a> 本章小结</h4><p>函数使用参数把值传给函数 使用关键字 return 把值返回函数 必须在函数定义和函数原型中指定函数的原型，如果需要在被调函数中修改主调函数的变量，使用地址或指针作为参数<br> ANSI C 提供了函数原型 允许编译器验证函数调用中使用的参数个数和类型是否正确<br> C 函数可以调用本身 即递归 一些编程问题要用递归来解决 但是递归消耗内存多 效率不高 而且费时</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Html-first</title>
      <link href="/2021/11/06/html-shang/"/>
      <url>/2021/11/06/html-shang/</url>
      
        <content type="html"><![CDATA[<h1 id="html上"><a class="markdownIt-Anchor" href="#html上">#</a> Html (上)</h1><h3 id="the-article-from-yogmas-also-sam"><a class="markdownIt-Anchor" href="#the-article-from-yogmas-also-sam">#</a> the article from yogmas also sam</h3><h4 id="1基本架构"><a class="markdownIt-Anchor" href="#1基本架构">#</a> 1. 基本架构</h4><blockquote><pre><code>&lt;html&gt; &lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; </code></pre></blockquote><h4 id="2html标签"><a class="markdownIt-Anchor" href="#2html标签">#</a> 2.html 标签</h4><h6 id="标题标签"><a class="markdownIt-Anchor" href="#标题标签">#</a> 标题标签</h6><blockquote><pre><code>&lt;h1&gt;&lt;/h1&gt;   ……  &lt;h6&gt;&lt;/h6&gt;</code></pre></blockquote><p>一共六级标题，文字加粗，由大到小依次减小。<br><strong>大多数标签都是成对存在的，只有少数例如 br 的单标签</strong></p><h6 id="段落和换行标签"><a class="markdownIt-Anchor" href="#段落和换行标签">#</a> 段落和换行标签</h6><blockquote><pre><code>&lt;p&gt;&lt;/p&gt;&lt;/br&gt;</code></pre></blockquote><p>p 标签会自动换行，不用添加 br</p><h6 id="文本格式化标签"><a class="markdownIt-Anchor" href="#文本格式化标签">#</a> 文本格式化标签</h6><blockquote><pre><code>&lt;strong&gt;加粗&lt;/strong&gt; 或者 &lt;b&gt;加粗&lt;/b&gt;&lt;em&gt;倾斜&lt;/em&gt; 或者 &lt;i&gt;倾斜&lt;/i&gt;&lt;del&gt;删除线&lt;/del&gt; 或者 &lt;s&gt;删除线&lt;/s&gt;&lt;ins&gt;下划线&lt;/ins&gt; 或者 &lt;u&gt;下划线&lt;/u&gt;</code></pre></blockquote><h6 id="div和span标签"><a class="markdownIt-Anchor" href="#div和span标签">#</a> div 和 span 标签</h6><blockquote><pre><code>&lt;span&gt;&lt;/span&gt;</code></pre></blockquote><p>形象来说 div 是一个大盒子，span 通常是用来放在大盒子里面的小盒子（后期 div 在页面构造中非常常用)</p><h6 id="图像标签"><a class="markdownIt-Anchor" href="#图像标签">#</a> 图像标签</h6><blockquote><pre><code>&lt;img src="路径" alt="图片不显示时显示出来的" title="鼠标放在图片上面显示出来的文字" width="" height="" border=""&gt;</code></pre></blockquote><p>在后期使用的 width,height,border, 都会放入<strong> css</strong> 中来运行使用不会单独列入 img 中<br>图像标签的路径<br> 1. 同一级路径<br> eg:(img.jpg)<br> 2. 下一级路径<br> eg:(images/img.jpg)<br> 3. 绝对路径<br> eg:(C:\Users\apple\Desktop\ 前端基础第一天 - HTML\ 案例 \img.jpg)<br>eg：(<a href="http://www.itcast.cn/2018czgw/images/logo.png">http://www.itcast.cn/2018czgw/images/logo.png</a>)<br><a href="https://imgtu.com/i/IQmLi8"><img src="https://z3.ax1x.com/2021/11/06/IQmLi8.png" alt="IQmLi8.png"></a></p><h6 id="超链接标签"><a class="markdownIt-Anchor" href="#超链接标签">#</a> 超链接标签</h6><blockquote><pre><code>&lt;a href="链接"&gt;LOL&lt;/a&gt;</code></pre><p>LOL 可以以图片文字等等代替，点击就可以跳转到 href 所在的链接</p></blockquote><p>可以添加的元素：target=“X”<br>X 包括_self (覆盖当前页面)<br> 和_blank 重新启动新的页面<br>链接分类<br> 1. 内部链接：存放在你网站前端的链接也就是你写前端时电脑里面的链接<br> 2. 外部链接：例如 http 这类的其他网站的链接<br> 3. 空链接：当你还没有链接可以填时，留出空位用 #代替<br> 4. 下载链接：通常是以.zip 结尾的压缩包<br><a href="https://imgtu.com/i/IQC8kd"><img src="https://z3.ax1x.com/2021/11/06/IQC8kd.png" alt="IQC8kd.png"></a></p><h6 id="锚点定位"><a class="markdownIt-Anchor" href="#锚点定位">#</a> 锚点定位</h6><p>由两个相互呼应的标签组成<br>可以从页面的一个地方跳转到当前页面的另外一个地方</p><blockquote><pre><code>&lt;a href="#ID"&gt;&lt;/a&gt;&lt;h3 id="ID"&gt;</code></pre></blockquote><p>ID 可以写成任何你定义的名称<br> h3 并不是固定的，可以换成任意标签<br>当你点击 a 中携带的元素或标签时你将会跳转到拥有 id=“” 且和 a 相同 id 的标签这</p><h6 id="注释标签和特殊字符"><a class="markdownIt-Anchor" href="#注释标签和特殊字符">#</a> 注释标签和特殊字符</h6><blockquote><pre><code>&lt;!-- 注释内容 --&gt; &lt;用&amp;lt  &gt;用&amp;gt；(由于&lt;&gt;符号在html中的特殊性)</code></pre></blockquote><p>特殊内容可以用 ctrl+l 快速注释</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Html-second</title>
      <link href="/2021/11/06/html-xia/"/>
      <url>/2021/11/06/html-xia/</url>
      
        <content type="html"><![CDATA[<p>。</p><h1 id="html下"><a class="markdownIt-Anchor" href="#html下">#</a> Html (下)</h1><h3 id="the-article-from-yogmas-also-sam"><a class="markdownIt-Anchor" href="#the-article-from-yogmas-also-sam">#</a> the article from yogmas also sam</h3><h4 id="1表格"><a class="markdownIt-Anchor" href="#1表格">#</a> 1. 表格</h4><h6 id="表格基本语法"><a class="markdownIt-Anchor" href="#表格基本语法">#</a> 表格基本语法</h6><blockquote><pre><code>&lt;table&gt;  &lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;/tr&gt;  &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</code></pre></blockquote><h6 id="表头单元格标签"><a class="markdownIt-Anchor" href="#表头单元格标签">#</a> 表头单元格标签</h6><blockquote><p>align=""<br>border=""<br>cellpadding=""<br>cellspacing=""<br>width=""<br>height=""<br><strong> 这些标签要写到 table 里面去</strong></p></blockquote><p>align: 表格中的文字所处的文字 eg.center 就是未于中间类似的还有 left,right<br>border：表示表格边框的大小 0 表示没有 <strong>此属性的参数值是数字</strong><br> cellpadding：代表单元格边框到内容之间的距离（留白）<br>cellspacing：用来指定表格各单元格之间的空隙。<strong>此属性的参数值是数字</strong>，表示单元格间隙所占的像素点数。<br>同样 width,height 已经介绍过了 ，大多数时候都会用<strong> CSS</strong> 来写</p><h6 id="合并单元格"><a class="markdownIt-Anchor" href="#合并单元格">#</a> 合并单元格</h6><blockquote><p>rowspan=“合并单元格数目”<br>colspan=“合并单元格数目”</p></blockquote><p>rowspan: 合并行 (也就是将一列上的各行合并)<br> colspan: 合并列 (也就是将一行上的各列合并)<br> 合并准则：如果 rowspan 就在最上面的表格的标签里面加上 rowspan="合并数目" 并且删除已经被合并的表格<br> colspan 同理，注意 colspan 加在最左边的表格标签<br> eg.</p><blockquote><pre><code>  &lt;tr&gt;     &lt;td&gt;&lt;/td&gt;      &lt;td colspan="2"&gt;&lt;/td&gt;  &lt;/tr&gt;</code></pre></blockquote><p>表示合并一行上的 2 列 第三列删除 colspan 写在第二列的 td 表格标签内</p><h4 id="2列表"><a class="markdownIt-Anchor" href="#2列表">#</a> 2. 列表</h4><h6 id="无序列表"><a class="markdownIt-Anchor" href="#无序列表">#</a> 无序列表</h6><blockquote><pre><code>&lt;ul&gt;  &lt;li&gt;&lt;/li&gt;    …………  &lt;li&gt;&lt;/li&gt;  &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;</code></pre></blockquote><p>其中的 li 标签各位根据需要而定<br> ul:unorderlist<br>li:list</p><h6 id="有序列表"><a class="markdownIt-Anchor" href="#有序列表">#</a> 有序列表</h6><blockquote><pre><code>&lt;ol&gt;  &lt;li&gt;&lt;/li&gt;    …………  &lt;li&gt;&lt;/li&gt;&lt;/ol&gt;</code></pre></blockquote><p>ol:orderlist<br>li:list</p><h6 id="自定义列表"><a class="markdownIt-Anchor" href="#自定义列表">#</a> 自定义列表</h6><blockquote><pre><code> &lt;dl&gt;   &lt;dt&gt;&lt;/dt&gt;顶部总标签   &lt;dd&gt;&lt;/dd&gt;   &lt;dt&gt;&lt;/dt&gt;   &lt;dd&gt;&lt;/dd &lt;/dl&gt; 一个&lt;dt&gt;和&lt;/dt&gt;标签出现代表一列 直到下一个&lt;dt&gt;和&lt;/dt&gt;出现才换列</code></pre></blockquote><h4 id="3表单"><a class="markdownIt-Anchor" href="#3表单">#</a> 3. 表单</h4><h6 id="表单域"><a class="markdownIt-Anchor" href="#表单域">#</a> 表单域</h6><blockquote><pre><code>&lt;form action="" method="" name=""&gt;&lt;/form&gt;</code></pre></blockquote><p>表单域需要与后端结合使用只是接下来的一系列需要传输数据到后端的都需要写到表单域内<br>附：此时作者还不知道表单域的 action 等标签充当的角色和用处</p><h6 id="input表单元素"><a class="markdownIt-Anchor" href="#input表单元素">#</a> input 表单元素</h6><blockquote><pre><code>&lt;input type="" value="" name="" &gt;</code></pre></blockquote><p><img src="images/26.png" alt="photo"><br>type 里面可以填写的元素<br> text: 文本框，用户可以输入任何文字，但可以用 maxlength 等来加以限定<br> password：密码框，可以对你输入的数字进行保密 此时显示 *******<br>radio: 单选按钮</p><blockquote><p>将两个 input+radio 元素的标签 name 设置成相同 才可以进行单选 具体下面看图</p></blockquote><p>checkbox: 复选框，可以进行多个选择<br> submit: 提交按钮，点击可以将数据提交给后端<br> reset: 重新填写<br> button: 点击  例如：获取短信验证码需要使用</p><p>与 type 同等级的元素作用<br> value：提前显示在文本框内的文字<br> name：传送给后端时的数据名称，radio 只有 name 相同才能单选<br><a href="https://imgtu.com/i/IQmXRg"><img src="https://z3.ax1x.com/2021/11/06/IQmXRg.png" alt="IQmXRg.png"></a></p><h6 id="label标签"><a class="markdownIt-Anchor" href="#label标签">#</a> label 标签</h6><p>点击添加了 label 标签的元素等于点击 label 标签的输出端</p><blockquote><pre><code>&lt;label for="XXX"&gt; &lt;/label&gt;&lt;input type="" id="XXX"&gt;</code></pre></blockquote><p>并不一定要是 input 只是在 input 等填写数据中较为广泛地使用，xxx 可以换成任何自己命名的单词字母等<br> for 和 id 中填写的必须相同</p><h6 id="select下拉表单"><a class="markdownIt-Anchor" href="#select下拉表单">#</a> select 下拉表单</h6><blockquote><pre><code>&lt;select&gt;&lt;option&gt;&lt;/option&gt;&lt;option selected="selected"&gt; &lt;/potion&gt;&lt;/select&gt;</code></pre></blockquote><p>option 标签中间填写下拉菜单中的文字等<br>添加了 selected 元素的表示 未下拉时显示在表面的选项</p><h6 id="textarea文本域"><a class="markdownIt-Anchor" href="#textarea文本域">#</a> textarea 文本域</h6><blockquote><pre><code>&lt;textarea cols="" rows=""&gt;&lt;/textarea&gt;</code></pre></blockquote><p>文本域通常很大所以用 cols 和 rows 来进行限定<br> cols 限定一行的字数 rows 限定行数<br>在后期的学习中可以用<strong> css</strong> 将文本域的右下角拉伸和上下滑动进行去除，增加美观性</p><h4 id="4html5新增"><a class="markdownIt-Anchor" href="#4html5新增">#</a> 4.html5 新增</h4><h6 id="语义化标签"><a class="markdownIt-Anchor" href="#语义化标签">#</a> 语义化标签</h6><blockquote><pre><code>&lt;header&gt;头部标签&lt;/header&gt;&lt;nav&gt;导航栏标签&lt;/nav&gt;   &lt;section&gt;某个区域&lt;/section&gt;</code></pre></blockquote><h6 id="视频标签"><a class="markdownIt-Anchor" href="#视频标签">#</a> 视频标签</h6><blockquote><pre><code>&lt;video src="" autoplay=""muted="muted"  loop="loop" poster="media/mi9.jpg"&gt;</code></pre></blockquote><p>src: 路径<br> autoplay: 写入 autoplay 代表自动播放<br> mute: 播放时静音<br> loop: 预先加载<br> poster: 播放还没有加载出来的时候显示的图片<br> controls: 是否显示控制按钮</p><h6 id="音频标签"><a class="markdownIt-Anchor" href="#音频标签">#</a> 音频标签</h6><blockquote><pre><code>&lt;audio src="media/music.mp3" autoplay="autoplay" controls="controls"&gt;&lt;/audio&gt;</code></pre></blockquote><p>与视频标签相差无几</p><h6 id="input表单"><a class="markdownIt-Anchor" href="#input表单">#</a> input 表单</h6><p><img src="images/46.png" alt="photo"></p><h6 id="表单属性"><a class="markdownIt-Anchor" href="#表单属性">#</a> 表单属性</h6><blockquote><pre><code>&lt;input type="search" name="sear" id="" required="required" placeholder="pink老师" autofocus="autofocus" autocomplete="off"&gt;</code></pre></blockquote><pre><code> &lt;input type="file" name="" id="" multiple="multiple"&gt;</code></pre><p>required: 需要填写才能点确定<br> placeholder: 还没有填写时候显示的文字<br> autofocus: 打开网页时，指标会自动点一下这里<br> autocomplete: 自动储存你输入过的信息 (容易暴露信息，所以一般都会关闭)<br> multiple: 可以选取多个文件</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Css-first</title>
      <link href="/2021/11/06/css1/"/>
      <url>/2021/11/06/css1/</url>
      
        <content type="html"><![CDATA[<h1 id="css1"><a class="markdownIt-Anchor" href="#css1">#</a> css1</h1><h3 id="the-article-from-yogmas-also-sam"><a class="markdownIt-Anchor" href="#the-article-from-yogmas-also-sam">#</a> the article from yogmas also sam</h3><h4 id="1css基本架构"><a class="markdownIt-Anchor" href="#1css基本架构">#</a> 1.css 基本架构</h4><blockquote><pre><code>&lt;html&gt; &lt;head&gt;&lt;style&gt;&lt;/style&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;/html&gt; style为css放置位置</code></pre></blockquote><p>前期学习先将 css 放置在 html 文件夹里面后期会单独利用 css 文件来写 css</p><h4 id="2选择器"><a class="markdownIt-Anchor" href="#2选择器">#</a> 2. 选择器</h4><h6 id="标签选择器"><a class="markdownIt-Anchor" href="#标签选择器">#</a> 标签选择器</h6><blockquote><p>选择器 {样式}<br> 给谁改样式 {改什么样式}<br>eg.p { color: red;<br>font-size: 12px; }</p></blockquote><p>标签选择器为大类选择，同一类标签全部都会被 css 修改</p><h6 id="类选择器"><a class="markdownIt-Anchor" href="#类选择器">#</a> 类选择器</h6><blockquote><pre><code>.id {} eg .red {color:red;}&lt;# class="id"&gt;  &lt;/#&gt;</code></pre></blockquote><p>这里的 ID 还需要与 html 中的 class 相互匹配 #可以替换成任何你想选择的类别 id 可以替换成任何你命名的字母或者单词<br><strong>类选择器口诀：样式点定义  结构类 (class) 调用  一个或多个 开发最常用</strong><br><a href="https://imgtu.com/i/IQmbIf"><img src="https://z3.ax1x.com/2021/11/06/IQmbIf.png" alt="IQmbIf.png"></a><br> 同时类选择器可以有多个 ID 都会起作用 中间用空格隔开 例如<br><a href="https://imgtu.com/i/IQmHdP"><img src="https://z3.ax1x.com/2021/11/06/IQmHdP.png" alt="IQmHdP.png"></a></p><h6 id="id选择器"><a class="markdownIt-Anchor" href="#id选择器">#</a> id 选择器</h6><p>id 选择器与类选择器相似，不过 ID 选择器只能使用一次 并且一个 ID 只能调用一次</p><blockquote><pre><code>#ID {}&lt;XX id=""&gt;  &lt;/XX&gt;</code></pre></blockquote><h6 id="通配符选择器"><a class="markdownIt-Anchor" href="#通配符选择器">#</a> 通配符选择器</h6><blockquote><pre><code>* { }</code></pre></blockquote><p>通配符 简而言之就是对所有元素和类都有作用，后期主要用来先去除掉浏览器自身所带的一些 css 属性方便我们后续进行 css 操作</p><h4 id="3css字体属性"><a class="markdownIt-Anchor" href="#3css字体属性">#</a> 3.CSS 字体属性</h4><p><a href="https://imgtu.com/i/IQmjzQ"><img src="https://z3.ax1x.com/2021/11/06/IQmjzQ.png" alt="IQmjzQ.png"></a></p><h6 id="字体系列"><a class="markdownIt-Anchor" href="#字体系列">#</a> 字体系列</h6><blockquote><p>font-family:’   ';</p></blockquote><p>通常会根据团队的要求来确定书写的字体 一般来说是微软雅黑也就是 microsoft YaHei 当然也可以有其他的一系列字体<br>比如在后期的<strong>字体图标</strong>中就需要修改 font-family</p><h6 id="字体大小"><a class="markdownIt-Anchor" href="#字体大小">#</a> 字体大小</h6><blockquote><p>font-size:;</p></blockquote><p>顾名思义，是修改字体的大小，不过需要注意的是这后面不能跟单独的数字 这样是没有效果的 需要跟单位 px</p><h6 id="字体粗细"><a class="markdownIt-Anchor" href="#字体粗细">#</a> 字体粗细</h6><blockquote><p>font-weight:  ;</p></blockquote><p>这里需要谨记 2 个数字<br> 700: 加粗<br> 400: 正常大小<br> font-weight 后面跟数字，可以根据需要来进行调整 不过一般都是 700 和 400 之间切换</p><h6 id="文字样式风格"><a class="markdownIt-Anchor" href="#文字样式风格">#</a> 文字样式风格</h6><blockquote><p>font-style: ;</p></blockquote><p>一般运用的都 italic (倾斜) 和 normal (正常) 两种<br>实际运用场景：<br>1. 用来修改需要倾斜的汉字<br> 2. 当没有标签可用时，可以用 em 倾斜标签先将汉字包括，在通过 font-style:normal；将倾斜属性去掉</p><h6 id="字体复合属性"><a class="markdownIt-Anchor" href="#字体复合属性">#</a> 字体复合属性</h6><p>通过简写的方式来节约代码 (不过有顺序要求)</p><blockquote><pre><code>font: font-style  font-weight  font-size/line-height  font-family;eg:font: italic 700 16px 'Microsoft yahei'; 前面两个可以省略，但是后面连个一定要写</code></pre></blockquote><h4 id="4文本外观属性"><a class="markdownIt-Anchor" href="#4文本外观属性">#</a> 4. 文本外观属性</h4><p><a href="https://imgtu.com/i/IQn9Zq"><img src="https://z3.ax1x.com/2021/11/06/IQn9Zq.png" alt="IQn9Zq.png"></a></p><h6 id="颜色"><a class="markdownIt-Anchor" href="#颜色">#</a> 颜色</h6><blockquote><pre><code>color: "</code></pre></blockquote><p>这里 color 后面所带有 4 种写法<br> 1. 直接加颜色例如 red,blue<br>2. 加颜色编号，主要这里 #必须加例如 #123456 (常用) 后期通常会用吸色笔 然后负值颜色编号<br> 3.rgb (X,X,X) 三色的搭配<br> 4.rgba (X,X,X,G) 这个主要是用来设置颜色的透明度 G 取值从 0~1<br> 用来设置颜色的透明度</p><h6 id="文字对齐"><a class="markdownIt-Anchor" href="#文字对齐">#</a> 文字对齐</h6><blockquote><p>text-align: ;</p></blockquote><p>设置文字的对齐方式，<br>left,center,right</p><h6 id="装饰文本"><a class="markdownIt-Anchor" href="#装饰文本">#</a> 装饰文本</h6><blockquote><pre><code>text-deroration: ;</code></pre></blockquote><p>可加元素:<br>line-through 删除线<br> overline 上划线<br><strong> none</strong> (常用) 通常用来配合通配符选择器来取消 a 的下划线</p><h6 id="文本缩进"><a class="markdownIt-Anchor" href="#文本缩进">#</a> 文本缩进</h6><blockquote><p>text-indent: ;</p></blockquote><p>后面添加数据时需要注意单位 用像素 (px) 或者 em (一个汉字所占的大小)</p><h6 id="行间距"><a class="markdownIt-Anchor" href="#行间距">#</a> 行间距</h6><blockquote><p>line-height: ;</p></blockquote><p>也需要加 px<br> 后期通常使 line-height 和 height 相等，来使文字垂直对齐</p><h4 id="5style样式表"><a class="markdownIt-Anchor" href="#5style样式表">#</a> 5.style 样式表</h4><h6 id="内部样式表"><a class="markdownIt-Anchor" href="#内部样式表">#</a> 内部样式表</h6><p>也就是我们最开始介绍，直到现在一直在使用的加到 style 里面的 css 属性</p><h6 id="行内样式表"><a class="markdownIt-Anchor" href="#行内样式表">#</a> 行内样式表</h6><p>直接加在 html 标签中的样式表</p><blockquote><pre><code> 例如: &lt;div style="";&gt; &lt;/div&gt; 不常使用，会使html标签显得臃肿</code></pre></blockquote><h6 id="外部样式表"><a class="markdownIt-Anchor" href="#外部样式表">#</a> 外部样式表</h6><blockquote><pre><code>&lt;link rel=""; href="文件地址";&gt;</code></pre></blockquote><p>另建一个.css 文件，在另外一个文件中书写 css 属性<br>再通过在 style 中书写 link 将其引入</p><h4 id="6vscode中使用emmet语法快速书写代码"><a class="markdownIt-Anchor" href="#6vscode中使用emmet语法快速书写代码">#</a> 6.vscode 中使用 emmet 语法快速书写代码</h4><p><a href="https://imgtu.com/i/IQnSLn"><img src="https://z3.ax1x.com/2021/11/06/IQnSLn.png" alt="IQnSLn.png"></a></p><h4 id="7选择器拓展"><a class="markdownIt-Anchor" href="#7选择器拓展">#</a> 7. 选择器拓展</h4><p><a href="https://imgtu.com/i/IQnZQJ"><img src="https://z3.ax1x.com/2021/11/06/IQnZQJ.png" alt="IQnZQJ.png"></a></p><h6 id="后代选择器"><a class="markdownIt-Anchor" href="#后代选择器">#</a> 后代选择器</h6><p>顾名思义就是将大元素中包括的小元素提取出来，这里通过列子来展示<br><a href="https://imgtu.com/i/IQnCd0"><img src="https://z3.ax1x.com/2021/11/06/IQnCd0.png" alt="IQnCd0.png"></a></p><h6 id="子元素选择器"><a class="markdownIt-Anchor" href="#子元素选择器">#</a> 子元素选择器</h6><p>例如上面的 ol li 变成 ol&gt;li 就只对 ol 中的下一级 li 有用也就是他的儿子，而他的下下级，也就是孙子则不起作用</p><h6 id="并集选择器"><a class="markdownIt-Anchor" href="#并集选择器">#</a> 并集选择器</h6><p>在标签和标签中间用逗号连接，这样就可以达到同时对两个盒子都起作用的效果</p><blockquote><p>例如 div,p,li {}</p></blockquote><p>需要注意的是最后一个选择器不需要加逗号</p><h6 id="链接伪类选择器"><a class="markdownIt-Anchor" href="#链接伪类选择器">#</a> 链接伪类选择器</h6><p><img src="images/27.png" alt="photo"></p><blockquote><p>X:GGGG {}</p></blockquote><p>X 可以是你的选择器中的任何<br>：后面可以添加 4 中元素 (其中 hover 最经常使用)：<br>link: 未访问链接：把没有点击过的链接选择出来<br> visited: 访问过的链接，把点击过的链接选择出来<br> hover: 当鼠标经过时<br> active: 鼠标点击但是还未弹起来时<br><a href="https://imgtu.com/i/IQmxMj"><img src="https://z3.ax1x.com/2021/11/06/IQmxMj.png" alt="IQmxMj.png"></a></p><h6 id="focus选择器"><a class="markdownIt-Anchor" href="#focus选择器">#</a> focus 选择器</h6><p>把获得光标的 input 选择显示出来<br>下面是代码，可以通过自己运行来进行查看<br><a href="https://imgtu.com/i/IQnPoV"><img src="https://z3.ax1x.com/2021/11/06/IQnPoV.png" alt="IQnPoV.png"></a></p><h4 id="8元素显示模式"><a class="markdownIt-Anchor" href="#8元素显示模式">#</a> 8. 元素显示模式</h4><p><img src="images/28.png" alt="photo"></p><h6 id="块级元素"><a class="markdownIt-Anchor" href="#块级元素">#</a> 块级元素</h6><p><a href="https://imgtu.com/i/IQnkJU"><img src="https://z3.ax1x.com/2021/11/06/IQnkJU.png" alt="IQnkJU.png"></a></p><h6 id="行内元素"><a class="markdownIt-Anchor" href="#行内元素">#</a> 行内元素</h6><p><a href="https://imgtu.com/i/IQnAWF"><img src="https://z3.ax1x.com/2021/11/06/IQnAWF.png" alt="IQnAWF.png"></a></p><h6 id="行内块元素"><a class="markdownIt-Anchor" href="#行内块元素">#</a> 行内块元素</h6><p>特殊情况，同时具有块级元素和行内元素的特点，可以进行的大小设置，也可以书写汉字，但是大小会随着汉字的多少而改变</p><h6 id="元素显示模式转换"><a class="markdownIt-Anchor" href="#元素显示模式转换">#</a> 元素显示模式转换</h6><blockquote><pre><code> display:   ;</code></pre></blockquote><p>inline: 行内元素<br> block: 块级元素<br> inline-block: 行内块元素<br><strong>学到这里去做一下小米侧边栏试试吧</strong></p><h6 id="单行文字垂直居中"><a class="markdownIt-Anchor" href="#单行文字垂直居中">#</a> 单行文字垂直居中</h6><p>也就是上面和大家提及过的，这里让 height 和 line-height 相同即可</p><h4 id="9背景"><a class="markdownIt-Anchor" href="#9背景">#</a> 9. 背景</h4><p><a href="https://imgtu.com/i/IQ6dHA"><img src="https://z3.ax1x.com/2021/11/06/IQ6dHA.png" alt="IQ6dHA.png"></a></p><h6 id="背景颜色"><a class="markdownIt-Anchor" href="#背景颜色">#</a> 背景颜色</h6><blockquote><p>background-color: ;</p></blockquote><p>后面的元素参照前面 color 属性</p><h6 id="背景图片"><a class="markdownIt-Anchor" href="#背景图片">#</a> 背景图片</h6><blockquote><p>background-image: url (链接 / 地址)；</p></blockquote><h6 id="背景平铺"><a class="markdownIt-Anchor" href="#背景平铺">#</a> 背景平铺</h6><blockquote><p>background-repeat: ;</p></blockquote><p>no-repeat (常用): 不平铺<br> repeat (默认): 平铺<br> repeat-x: 沿着 X 轴平铺<br> repeat-y: 沿着 Y 轴平铺<br><strong>背景图片会压住背景颜色</strong><br><a href="https://imgtu.com/i/IQnFiT"><img src="https://z3.ax1x.com/2021/11/06/IQnFiT.png" alt="IQnFiT.png"></a></p><h6 id="背景位置"><a class="markdownIt-Anchor" href="#背景位置">#</a> 背景位置</h6><blockquote><p>background-position: ;</p></blockquote><p>left top center right bottom<br> 也可以用 right center 等同时使用 但是有几点需要注意<br> 1. 如果是方位名词  right center 和 center right 效果是等价的 跟顺序没有关系<br> 2. 当有参数省略时，并且不全是方位名字时，例如 right top ,<br> 省略 right，此时 top 会自动顶部对齐，而省略的会被判定为水平居中<br>省略 top，则会被判定为垂直居中<br><a href="https://imgtu.com/i/IQnEz4"><img src="https://z3.ax1x.com/2021/11/06/IQnEz4.png" alt="IQnEz4.png"></a><br> 也可以用具体的数据来进行移动，主要用于精灵图<br><a href="https://imgtu.com/i/IQney9"><img src="https://z3.ax1x.com/2021/11/06/IQney9.png" alt="IQney9.png"></a><br> 需要注意的时，html 的 X 轴向右，而 y 轴是向下的，需要向反方向移动时可以添加负号</p><h6 id="背景固定"><a class="markdownIt-Anchor" href="#背景固定">#</a> 背景固定</h6><blockquote><p>backgrounf-attachment: fixed;</p></blockquote><p>将背景图片固定，这样滑动鼠标滚轮时，背景图片会一直存在于网页上，并不会滑走<br><a href="https://imgtu.com/i/IQnmLR"><img src="https://z3.ax1x.com/2021/11/06/IQnmLR.png" alt="IQnmLR.png"></a></p><h6 id="背景属性复合写法"><a class="markdownIt-Anchor" href="#背景属性复合写法">#</a> 背景属性复合写法</h6><p><a href="https://imgtu.com/i/IQ6tje"><img src="https://z3.ax1x.com/2021/11/06/IQ6tje.png" alt="IQ6tje.png"></a></p><h6 id="背景半透明"><a class="markdownIt-Anchor" href="#背景半透明">#</a> 背景半透明</h6><p>主要这个不是放在 background-color 中</p><blockquote><p>background: rgba(X,X,X,X);</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Css-second</title>
      <link href="/2021/11/06/css2/"/>
      <url>/2021/11/06/css2/</url>
      
        <content type="html"><![CDATA[<h1 id="css2"><a class="markdownIt-Anchor" href="#css2">#</a> css2</h1><h3 id="the-article-from-yogmas-also-sam"><a class="markdownIt-Anchor" href="#the-article-from-yogmas-also-sam">#</a> the article from yogmas also sam</h3><h4 id="1css选择器的性质"><a class="markdownIt-Anchor" href="#1css选择器的性质">#</a> 1.css 选择器的性质</h4><h6 id="css层叠性"><a class="markdownIt-Anchor" href="#css层叠性">#</a> css 层叠性</h6><p>长江后浪推前浪，前浪死在沙滩上<br>当两个完全相同的选择器写在一起时，此时根据就近原则处理</p><h6 id="css继承性"><a class="markdownIt-Anchor" href="#css继承性">#</a> css 继承性</h6><p>大元素中的小元素会继承写在大元素中的属性</p><h6 id="行高的继承"><a class="markdownIt-Anchor" href="#行高的继承">#</a> 行高的继承</h6><p><a href="https://imgtu.com/i/IQ6YcD"><img src="https://z3.ax1x.com/2021/11/06/IQ6YcD.png" alt="IQ6YcD.png"></a></p><p>孩子拥有 font-size 元素会优先使用定义在自身的，而后面的倍数孩子自身没有就会继承父亲的倍数</p><h6 id="css优先级"><a class="markdownIt-Anchor" href="#css优先级">#</a> css 优先级</h6><p>这个主要是根据后面的权重的大小而判定的，权重大的优先。</p><h6 id="css权重"><a class="markdownIt-Anchor" href="#css权重">#</a> css 权重</h6><p><a href="https://imgtu.com/i/IQ6UnH"><img src="https://z3.ax1x.com/2021/11/06/IQ6UnH.png" alt="IQ6UnH.png"></a></p><h6 id="权重的叠加"><a class="markdownIt-Anchor" href="#权重的叠加">#</a> 权重的叠加</h6><p>权重的叠加可以用加减法来计算<br>例如 0,1,0,0 相当于 100</p><h4 id="2盒子模型"><a class="markdownIt-Anchor" href="#2盒子模型">#</a> 2. 盒子模型</h4><p>盒子通常是块级元素<br>也可以通过 display 将其变成块级元素 a 元素通常使用这种方法</p><h6 id="盒子边框"><a class="markdownIt-Anchor" href="#盒子边框">#</a> 盒子边框</h6><p><a href="https://imgtu.com/i/IQ6aBd"><img src="https://z3.ax1x.com/2021/11/06/IQ6aBd.png" alt="IQ6aBd.png"></a></p><blockquote><p>border-width: ;<br>border-style: ;<br>border-color: ;<br>border:width style color ; 复合写法</p></blockquote><p>这边建议大家使用复合写法<br> style:solid 实线 dotted 虚线 dashed 更大点的虚线</p><p><strong>边框会影响盒子的实际大小</strong></p><h6 id="盒子内边框"><a class="markdownIt-Anchor" href="#盒子内边框">#</a> 盒子内边框</h6><p><a href="https://imgtu.com/i/IQ66gS"><img src="https://z3.ax1x.com/2021/11/06/IQ66gS.png" alt="IQ66gS.png"></a></p><blockquote><p>padding: ;<br>padding-left: ;</p></blockquote><p>同理 left 可以换成其他的方位</p><p>内边距复合写法：从顶部顺时针数<br><strong>内边距会影响盒子的大小</strong></p><p>内边距不会影响盒子大小的情况:<br> 当盒子内没有给宽时，padding-left/right 不会影响<br>没有给高时 padding-top/bottom 不会影响</p><h6 id="盒子外边距"><a class="markdownIt-Anchor" href="#盒子外边距">#</a> 盒子外边距</h6><blockquote><p>margin:  ;<br>margin-top/XXX: ;</p></blockquote><p>复合写法和内边距同理</p><p><strong>外边距典型应用</strong>:<br>margin: XXXpx auto;<br> 此时 auto 代表左右两边自动设置可以让盒子水平对齐</p><h6 id="行内元素或行内块元素水平居中对齐"><a class="markdownIt-Anchor" href="#行内元素或行内块元素水平居中对齐">#</a> 行内元素或行内块元素水平居中对齐</h6><p>margin 对行内元素没有作用，但是可以给这两种元素的父盒子添加 text-align:center;</p><h6 id="外边距合并"><a class="markdownIt-Anchor" href="#外边距合并">#</a> 外边距合并</h6><p>当子盒子给 margin 时，父盒子和子盒子会塌陷，两个盒子会边框重合</p><h6 id="清除内外边距"><a class="markdownIt-Anchor" href="#清除内外边距">#</a> 清除内外边距</h6><p>通常浏览器会自带内外边距这时就需要使用通用符选择器将浏览器自带的边距出去</p><blockquote><pre><code>* {padding:0 ;   margin:0;}</code></pre></blockquote><h6 id="圆角边框"><a class="markdownIt-Anchor" href="#圆角边框">#</a> 圆角边框</h6><blockquote><p>border-radius: Xpx ;</p></blockquote><p>原理：利用一个半径为 Xpx 的圆，与边角重叠，然后切去没有重叠的边角；</p><h6 id="盒子阴影"><a class="markdownIt-Anchor" href="#盒子阴影">#</a> 盒子阴影</h6><p><a href="https://imgtu.com/i/IQCJfI"><img src="https://z3.ax1x.com/2021/11/06/IQCJfI.png" alt="IQCJfI.png"></a></p><blockquote><p>box-shadow: X X X X X;</p></blockquote><p>由左到右依次为 往右边移动的距离 往下面移动的距离 阴影发散度 (往四面八方发散)  往四面八方扩散的距离 颜色 (通常是 rgba 控制)</p><h6 id="文字阴影"><a class="markdownIt-Anchor" href="#文字阴影">#</a> 文字阴影</h6><blockquote><p>text-shadow:X X X rgba;</p></blockquote><p>分别是 往右边移动的距离 往下面移动的距离 虚实度 (越大越虚)</p><h6 id="行内块元素中间有缝隙"><a class="markdownIt-Anchor" href="#行内块元素中间有缝隙">#</a> 行内块元素中间有缝隙</h6><h4 id="3浮动"><a class="markdownIt-Anchor" href="#3浮动">#</a> 3. 浮动</h4><blockquote><pre><code>  float: left/right;</code></pre></blockquote><h6 id="浮动特性-脱标"><a class="markdownIt-Anchor" href="#浮动特性-脱标">#</a> 浮动特性 - 脱标</h6><p>1. 脱离标准普通流的控制（浮）移动到指定位置（动）。<br>2. 浮动的盒子不在保留原先的位置</p><p><strong>浮动元素具有行内块元素的特点</strong><br>浮动盒子通常搭配标准流父盒子</p><h6 id="浮动的注意点"><a class="markdownIt-Anchor" href="#浮动的注意点">#</a> 浮动的注意点</h6><p>1. 如果一个子元素浮动了，尽量其他盒子也浮动，这样保证这些子元素一行显示</p><h6 id="清除浮动的方法"><a class="markdownIt-Anchor" href="#清除浮动的方法">#</a> 清除浮动的方法</h6><p><a href="https://imgtu.com/i/IQCN1P"><img src="https://z3.ax1x.com/2021/11/06/IQCN1P.png" alt="IQCN1P.png"></a></p><p><img src="images/29.png" alt="photo"></p><p>额外标签法：在子盒子的最后新增一个块级盒子 并且用 css 给快捷盒子加上 clear:both; 属性</p><p>父元素 overflow: 给父元素加上一个 overflow: hidden; 的 css 属性<br><img src="images/25.png" alt="photo"></p><p>伪元素清除:</p><blockquote><p>.clearfix:after {<br>content: “”;<br>display: block;<br>height: 0;<br>clear: both;<br>visibility: hidden;<br>}<br>.clearfix {<br>IE6、7 专有<br> zoom: 1;<br>}</p></blockquote><p><a href="https://imgtu.com/i/IQ60AI"><img src="https://z3.ax1x.com/2021/11/06/IQ60AI.png" alt="IQ60AI.png"></a></p><p>给父盒子一个 class 为 clearfix 然后将这串代码心如 css 中</p><p>双伪元素清除:</p><blockquote><p>.clearfix:before,<br>.clearfix:after {<br>content: “”;<br>display: table;<br>}<br>.clearfix:after {<br>clear: both;<br>}<br>.clearfix {<br>*zoom: 1;<br>}</p></blockquote><p>同理给一个 clearfix 标签，然后将这串代码写入 css 中</p><h4 id="4定位"><a class="markdownIt-Anchor" href="#4定位">#</a> 4. 定位</h4><p><a href="https://imgtu.com/i/IQCGtA"><img src="https://z3.ax1x.com/2021/11/06/IQCGtA.png" alt="IQCGtA.png"></a><br><img src="images/40.png" alt="photo"></p><blockquote><p>position: ;</p></blockquote><p>static: 默认静态定位<br> absolute: 绝对定位<br> relative: 相对定位<br> fixed: 固定定位<br> sticky: 粘性定位</p><p>相对定位：可以进行定位，但依旧会占用空间<br>绝对定位<br>如果没施加绝对定位的盒子没有父盒子，那么绝对定位就是在浏览器的基础上的<br>如果绝对定位的盒子有父盒子，那么绝对定位就是在父盒子的基础上，并且<strong>父盒子一定要有定位，否则绝对定位就会失效</strong>所以通常说相对定位就是给绝对定位当爹的</p><p>固定定位：会固定在屏幕上，无视浏览器的滑块移动</p><p>粘性定位：会先随着浏览器滑块的滑动而滑动，但是后来会静止，并且无法滑出浏览器屏幕</p><h6 id="定位的堆叠顺序"><a class="markdownIt-Anchor" href="#定位的堆叠顺序">#</a> 定位的堆叠顺序</h6><p>如果有很多个绝对定位，可能会放在同一个位置，这时候需要确定谁放置在最上面</p><blockquote><pre><code>z-index: ;</code></pre></blockquote><p>默认为 0，数值越大显示等级越高</p><h6 id="小技巧-绝对定位的水平垂直居中"><a class="markdownIt-Anchor" href="#小技巧-绝对定位的水平垂直居中">#</a> 小技巧 - 绝对定位的水平垂直居中</h6><p>1.left 走 50%  父容器宽度的一半<br> 2.margin 负值 往左边走 自己盒子宽度的一半</p><h6 id="定位的特殊特性"><a class="markdownIt-Anchor" href="#定位的特殊特性">#</a> 定位的特殊特性</h6><p><a href="https://imgtu.com/i/IQC1TH"><img src="https://z3.ax1x.com/2021/11/06/IQC1TH.png" alt="IQC1TH.png"></a><br><a href="https://imgtu.com/i/IQCtpt"><img src="https://z3.ax1x.com/2021/11/06/IQCtpt.png" alt="IQCtpt.png"></a></p><h6 id="定位和浮动的差异"><a class="markdownIt-Anchor" href="#定位和浮动的差异">#</a> 定位和浮动的差异</h6><p>定位和浮动有相似部分，类如都会转化为行内块元素，都会压住盒子，但是浮动不会压住文字，定位会将所有东西压住</p><h4 id="5显示隐藏"><a class="markdownIt-Anchor" href="#5显示隐藏">#</a> 5. 显示隐藏</h4><h6 id="display"><a class="markdownIt-Anchor" href="#display">#</a> display</h6><blockquote><p>display: ;</p></blockquote><p><a href="https://imgtu.com/i/IQCaX8"><img src="https://z3.ax1x.com/2021/11/06/IQCaX8.png" alt="IQCaX8.png"></a></p><h6 id="visibility"><a class="markdownIt-Anchor" href="#visibility">#</a> visibility</h6><p><a href="https://imgtu.com/i/IQCwnS"><img src="https://z3.ax1x.com/2021/11/06/IQCwnS.png" alt="IQCwnS.png"></a></p><h6 id="overflow"><a class="markdownIt-Anchor" href="#overflow">#</a> overflow</h6><blockquote><p>overflow: ;</p></blockquote><p><a href="https://imgtu.com/i/IQC00g"><img src="https://z3.ax1x.com/2021/11/06/IQC00g.png" alt="IQC00g.png"></a><br><a href="https://imgtu.com/i/IQCB7Q"><img src="https://z3.ax1x.com/2021/11/06/IQCB7Q.png" alt="IQCB7Q.png"></a></p><h4 id="6精灵图"><a class="markdownIt-Anchor" href="#6精灵图">#</a> 6. 精灵图</h4><p>这里不好介绍怎样操作只能简单而言<br>一张包含各种小图片的大图片<br>利用前面所讲的背景图片位置的移动使其只能显示出一张小图片来<br>问：为什么需要精灵图<br>利用精灵图可以将多张图片整合在一起，从而可以减少信息的发送和接受量，减少服务器的负担</p><h4 id="7字体图标的使用"><a class="markdownIt-Anchor" href="#7字体图标的使用">#</a> 7. 字体图标的使用</h4><p>通过在网站上寻找字体图标，下载</p><p>然后将代码写入 css 中</p><blockquote><p>@font-face {<br>font-family: ‘icomoon’;<br>src:  url(‘fonts/icomoon.eot?p4ssmb’);<br>src:  url(‘fonts/icomoon.eot?p4ssmb#iefix’) format(‘embedded-opentype’),<br>url(‘fonts/icomoon.ttf?p4ssmb’) format(‘truetype’),<br>url(‘fonts/icomoon.woff?p4ssmb’) format(‘woff’),<br>url(‘fonts/icomoon.svg?p4ssmb#icomoon’) format(‘svg’);<br>font-weight: normal;<br>font-style: normal;<br>font-display: block;<br>}</p></blockquote><p>font 文件夹移动到主文件夹中</p><p>此时就可以用字体图标代码来进行表示字体图标</p><p>好处：可以对图标进行改变颜色大小等等的改变字体时用到的属性</p><h4 id="8css三角的制作"><a class="markdownIt-Anchor" href="#8css三角的制作">#</a> 8.css 三角的制作</h4><p>利用 cssborder 属性来进行三角的制作<br>由于不好叙述，自己输入，理解并体验这几组代码，应该就能理解 css 三角的制作<br><a href="https://imgtu.com/i/IQCsts"><img src="https://z3.ax1x.com/2021/11/06/IQCsts.png" alt="IQCsts.png"></a><br><a href="https://imgtu.com/i/IQCrkj"><img src="https://z3.ax1x.com/2021/11/06/IQCrkj.png" alt="IQCrkj.png"></a></p><h4 id="9用户界面样式"><a class="markdownIt-Anchor" href="#9用户界面样式">#</a> 9. 用户界面样式</h4><h6 id="表单轮廓"><a class="markdownIt-Anchor" href="#表单轮廓">#</a> 表单轮廓</h6><p>由于点击表单或者 text 文本框时边框上会出现颜色变化边框变大拖拽文本域等一系列的反应，从而利用 css 取消边框的轮廓</p><blockquote><pre><code>outline: none;  (input,textarea)</code></pre></blockquote><blockquote><pre><code>resize:none; (textarea)</code></pre><p>用来防止拖拽文本域的</p></blockquote><h6 id="鼠标样式"><a class="markdownIt-Anchor" href="#鼠标样式">#</a> 鼠标样式</h6><blockquote><p>cursor: ;</p></blockquote><p>default: 小白鼠标样式<br> pointer: 鼠标小手样式<br> move: 鼠标移动样式<br> text: 鼠标文本样式<br> not-allowed: 鼠标禁止样式</p><h6 id="图片文字垂直居中"><a class="markdownIt-Anchor" href="#图片文字垂直居中">#</a> 图片文字垂直居中</h6><p><img src="images/43.png" alt="photo"></p><h6 id="图片底侧有空白缝隙的解决方案"><a class="markdownIt-Anchor" href="#图片底侧有空白缝隙的解决方案">#</a> 图片底侧有空白缝隙的解决方案</h6><p>先将图片变为块级元素，然后再给块级元素设置边框就可以解决</p><h4 id="10文字溢出显示"><a class="markdownIt-Anchor" href="#10文字溢出显示">#</a> 10. 文字溢出显示</h4><h6 id="单行文字溢出显示"><a class="markdownIt-Anchor" href="#单行文字溢出显示">#</a> 单行文字溢出显示</h6><p><a href="https://imgtu.com/i/IQCyhn"><img src="https://z3.ax1x.com/2021/11/06/IQCyhn.png" alt="IQCyhn.png"></a></p><h6 id="多行文字溢出显示"><a class="markdownIt-Anchor" href="#多行文字溢出显示">#</a> 多行文字溢出显示</h6><p><img src="images/45.png" alt="photo"></p><h4 id="11margin负值的巧妙运动"><a class="markdownIt-Anchor" href="#11margin负值的巧妙运动">#</a> 11.margin 负值的巧妙运动</h4><p>如果多个盒子都有边框，此时相交部分边框会重合在一起，从而增加边框的大小，此时只需要写入 margin-left: -1px; 就可以得到解决</p><h4 id="12文字围绕浮动元素"><a class="markdownIt-Anchor" href="#12文字围绕浮动元素">#</a> 12. 文字围绕浮动元素</h4><p>众所周知浮动元素是不占用空间的，此时如果将一个照片浮动，而需要在照片旁边写入汉字的话，汉字是否会出现在图片的下方呢，答案是不会，因为汉字会围绕浮动元素</p><h4 id="13css初始化"><a class="markdownIt-Anchor" href="#13css初始化">#</a> 13.css 初始化</h4><p>这里给出一串代码，初始化网页，将网页元素自带的一些 css 属性给去掉</p><blockquote><p>/* 把我们所有标签的内外边距清零 <em>/<br>* {<br>margin: 0;<br>padding: 0<br>}<br>/</em>em 和 i 斜体的文字不倾斜 <em>/<br>em,<br>i {<br>font-style: normal<br>}<br>/</em> 去掉 li 的小圆点 <em>/<br>li {<br>list-style: none<br>}<br>img {<br>/</em>border 0 照顾低版本浏览器 如果 图片外面包含了链接会有边框的问题 <em>/<br>border: 0;<br>/</em> 取消图片底侧有空白缝隙的问题 <em>/<br>vertical-align: middle<br>}<br>button {<br>/</em> 当我们鼠标经过 button 按钮的时候，鼠标变成小手 <em>/<br>cursor: pointer<br>}<br>a {<br>color: #666;<br>text-decoration: none<br>}<br>a:hover {<br>color: #c81623<br>}<br>button,<br>input {<br>/</em> “\5B8B\4F53” 就是宋体的意思 这样浏览器兼容性比较好 <em>/<br>font-family: Microsoft YaHei, Heiti SC, tahoma, arial, Hiragino Sans GB, “\5B8B\4F53”, sans-serif<br>}<br>body {<br>/</em> CSS3 抗锯齿形 让文字显示的更加清晰 <em>/<br>-webkit-font-smoothing: antialiased;<br>background-color: #fff;<br>font: 12px/1.5 Microsoft YaHei, Heiti SC, tahoma, arial, Hiragino Sans GB, “\5B8B\4F53”, sans-serif;<br>color: #666<br>}<br>.hide,<br>.none {<br>display: none<br>}<br>/</em> 清除浮动 */<br>.clearfix:after {<br>visibility: hidden;<br>clear: both;<br>display: block;<br>content: “.”;<br>height: 0<br>}<br>.clearfix {<br>*zoom: 1<br>}</p></blockquote><h4 id="14css新增属性"><a class="markdownIt-Anchor" href="#14css新增属性">#</a> 14.css 新增属性</h4><h6 id="新增属性选择器"><a class="markdownIt-Anchor" href="#新增属性选择器">#</a> 新增属性选择器</h6><p><img src="images/47.png" alt="photo"></p><p>通过举例进行说明<br> input [type=text] {}<br> 这个表示选出 input 中 type=text 的元素</p><p>div [class^=XXX]: 选出以 XXX 开头的元素</p><p>div [class$=XXX]: 选出以 XXX 结尾的元素</p><h6 id="结构伪类选择器"><a class="markdownIt-Anchor" href="#结构伪类选择器">#</a> 结构伪类选择器</h6><p><img src="images/48.png" alt="photo"></p><blockquote><pre><code>xxx:firstchildxxx:secondchildxxx:nth-child(number)</code></pre></blockquote><p>都是选出第几个子元素的意思</p><p><img src="images/49.png" alt="photo"></p><p>括号里面不仅仅可以跟数字，也可以很有特殊意义的单词，甚至可以跟公式 n 将取自然数</p><p>nth-of-type 选择器</p><p>两个选择器的区别如下<br><img src="images/50.png" alt="photo"><br> 举例子来说明:</p><blockquote><pre><code>&lt;p&gt;光头强&lt;/p&gt;&lt;div&gt;熊大&lt;/div&gt;&lt;div&gt;熊二&lt;/div&gt;</code></pre></blockquote><p>此时如果给一个 section div:nth-child (1) { background-color: red; } 指令，你觉得谁会被加上红色呢<br>答案是都不会<br> child 先看后面的数字 1   ，此时第一个孩子是 p，然后再来看前面的 div，发现 div 不是 P，所以不成立 谁都不给</p><p>但如果给一个 section div:nth-of-type (1) {<br>background-color: blue;} 指令呢<br>答案是会给熊大，type 先看前面的 div，找出 div，再发现后面的 1，所以会给 div 中的第一个孩子</p><h6 id="伪元素选择器"><a class="markdownIt-Anchor" href="#伪元素选择器">#</a> 伪元素选择器</h6><blockquote><p>XXX::before/after {<br>content:’’;<br>}<br> 这里面的 content 是必须加的，表示里面的内容，即使你没有内容要写，也需要写出 content 否则无效，注意是单引号</p></blockquote><p>用处：可以里面 css 来个父元素添加盒子 词的的 before 表示出现在父元素的左边 after 表示出现在父元素的右边</p><h6 id="css3盒子模型"><a class="markdownIt-Anchor" href="#css3盒子模型">#</a> css3 盒子模型</h6><p>前面我们说了 padding 和边框都会撑大盒子，所以说我们使用 border 和 padding 还需要减去其尺寸，现在我们提供了修复的方法</p><blockquote><p>box-sizing:  ;</p></blockquote><p>content-box: 按照原来会撑大盒子的方式<br> border-box: 会自动减去撑大的尺寸，保证盒子的尺寸不变</p><h6 id="图片模糊处理"><a class="markdownIt-Anchor" href="#图片模糊处理">#</a> 图片模糊处理</h6><blockquote><p>filter:blur()</p></blockquote><p>blur 是一个函数 小括号里面数值越大，图片越模糊 注意数值要加 px 单位</p><h6 id="css3宽度calc函数"><a class="markdownIt-Anchor" href="#css3宽度calc函数">#</a> css3 宽度 calc 函数</h6><p>calc 函数主要提供了一个计算的方法<br>例如在有一个父盒子的前提下，子盒子写出这样一个函数 width: calc (100% - 30px); 表示在父亲 100% 尺寸的前提下始终减去 30px 的宽度</p><h6 id="过渡效果"><a class="markdownIt-Anchor" href="#过渡效果">#</a> 过渡效果</h6><p>大概来说就是将一个瞬间变化的过程转化成阶段性有时间长短的变化<br><img src="images/51.png" alt="photo0"><br> 在这里 0s 开始一般可以不写而省略，变化曲线也一遍使用 ease 这是最常用的变化曲线</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript基础(未完待续)</title>
      <link href="/2021/11/06/javascript-ji-chu-ban/"/>
      <url>/2021/11/06/javascript-ji-chu-ban/</url>
      
        <content type="html"><![CDATA[<h1 id="javascript"><a class="markdownIt-Anchor" href="#javascript">#</a> javascript</h1><h2 id="article-by-yogmas"><a class="markdownIt-Anchor" href="#article-by-yogmas">#</a> Article By Yogmas</h2><h3 id="js的组成"><a class="markdownIt-Anchor" href="#js的组成">#</a> js 的组成</h3><p>1.ECNscript:JS 语法<br> 2.DOM: 页面文档模型<br> 3.BOM: 浏览器对象模型</p><h4 id="js初体验"><a class="markdownIt-Anchor" href="#js初体验">#</a> js 初体验</h4><p>1. 行内式 js: 直接写到元素的内部<br><a href="https://imgtu.com/i/IGFyQJ"><img src="https://z3.ax1x.com/2021/11/08/IGFyQJ.png" alt="IGFyQJ.png"></a><br>2. 内嵌式的 js:</p><blockquote><pre><code>&lt;head&gt;&lt;script&gt; &lt;/script&gt;&lt;/head&gt;</code></pre></blockquote><p>3. 外部式 js: 创建 XXX.js 文件在通过标签引出到 html 文件中<br><a href="https://imgtu.com/i/IGF2e1"><img src="https://z3.ax1x.com/2021/11/08/IGF2e1.png" alt="IGF2e1.png"></a></p><h4 id="js注释"><a class="markdownIt-Anchor" href="#js注释">#</a> js 注释</h4><blockquote><pre><code>1.单行注释    //    ctrl + /2.多行注释     /*    */    shift + alt + a</code></pre></blockquote><h4 id="js输入输出语句"><a class="markdownIt-Anchor" href="#js输入输出语句">#</a> js 输入输出语句</h4><p><a href="https://imgtu.com/i/IGFWo6"><img src="https://z3.ax1x.com/2021/11/08/IGFWo6.png" alt="IGFWo6.png"></a></p><blockquote><pre><code>prompt('') 输入框 alert('')警示框  展示给用户的console 控制台打印的信息 给程序员看的</code></pre></blockquote><h3 id="变量概述"><a class="markdownIt-Anchor" href="#变量概述">#</a> 变量概述</h3><h4 id="什么是变量"><a class="markdownIt-Anchor" href="#什么是变量">#</a> 什么是变量</h4><p>变量是用来存放数据的容器，简而言之就是一个装东西的盒子<br>变量是内存中申请的一部分用来存放数据的空间</p><h3 id="变量的使用"><a class="markdownIt-Anchor" href="#变量的使用">#</a> 变量的使用</h3><h4 id="声明变量"><a class="markdownIt-Anchor" href="#声明变量">#</a> 声明变量</h4><blockquote><p>var age;</p></blockquote><p>var 是一个 js 关键字用来声明变量<br> age 是程序员取的名字</p><h4 id="赋值"><a class="markdownIt-Anchor" href="#赋值">#</a> 赋值</h4><p>赋值就是把值存入变量中</p><blockquote><p>age=10</p></blockquote><p>这里的 = 是赋值的意思 在变量中存储一个数据</p><h4 id="变量的初始化"><a class="markdownIt-Anchor" href="#变量的初始化">#</a> 变量的初始化</h4><blockquote><p>var age=18;</p></blockquote><p>在声明变量的同时赋值给 18  使程序变得更加简便</p><blockquote><pre><code>var myname = prompt('请输入你的名字')</code></pre></blockquote><p>这样在弹出的对话框里面输入的名字 可以储存到变量 myname 中去</p><h4 id="变量语法扩展"><a class="markdownIt-Anchor" href="#变量语法扩展">#</a> 变量语法扩展</h4><h5 id="更新变量"><a class="markdownIt-Anchor" href="#更新变量">#</a> 更新变量</h5><blockquote><pre><code> var myname = 'pink'; console.log(myname);  myname = '迪丽热巴';  console.log(myname);</code></pre></blockquote><p>这样从上到下 第一次输出的 pink 第二次输出的是迪丽热巴  变量在不断更新</p><h5 id="声明多个变量"><a class="markdownIt-Anchor" href="#声明多个变量">#</a> 声明多个变量</h5><blockquote><pre><code>eg:var age=18,address='火影村'</code></pre></blockquote><p>这里声明了 age 和 address 多个变量，变量与变量之间通过英文的逗号隔开</p><h5 id="声明变量的特殊情况"><a class="markdownIt-Anchor" href="#声明变量的特殊情况">#</a> 声明变量的特殊情况</h5><p>1. 只声明不赋值 这时候输出的结果是 undefined (未定义的)<br> 2. 不声明不赋值 直接使用 浏览器会进行报错<br> 3. 不声明直接赋值使用 在 js 之中只可以使用的</p><p>注意:js 是从上到下处理的，如果中间有错误的代码，那么错误代码下面的代码将不再被 js 处理<br><a href="https://imgtu.com/i/IG0QRf"><img src="https://z3.ax1x.com/2021/11/08/IG0QRf.png" alt="IG0QRf.png"></a></p><h5 id="变量命名规范"><a class="markdownIt-Anchor" href="#变量命名规范">#</a> 变量命名规范</h5><p><a href="https://imgtu.com/i/IGieEV"><img src="https://z3.ax1x.com/2021/11/08/IGieEV.png" alt="IGieEV.png"></a><br> 尽量不要直接使用 name 作为变量名，name 在大部分浏览器中有变量含义</p><h4 id="小结"><a class="markdownIt-Anchor" href="#小结">#</a> 小结</h4><p>自我问答环节<br><a href="https://imgtu.com/i/IGin4U"><img src="https://z3.ax1x.com/2021/11/08/IGin4U.png" alt="IGin4U.png"></a><br><a href="https://imgtu.com/i/IGiM34"><img src="https://z3.ax1x.com/2021/11/08/IGiM34.png" alt="IGiM34.png"></a></p><h3 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型">#</a> 数据类型</h3><h4 id="简介"><a class="markdownIt-Anchor" href="#简介">#</a> 简介</h4><p>不同的数据占用的存储空间不同，为了充分利用存储空间，于是定义了不同的数据类型.</p><h4 id="变量的数据类型"><a class="markdownIt-Anchor" href="#变量的数据类型">#</a> 变量的数据类型</h4><p>js 是一种弱类型或者说动态语言，这意味着不用提前声明变量的类型，在程序运行的过程中，类型会自动确定.</p><p>js 的变量数据类型是只有程序在运行过程中，根据等号右边的值来确定的.</p><p>js 是动态语言，变量的数据类型是可以变化的</p><blockquote><p>var x = 10;x 是数字型<br> var x = ‘yogmas’; x 是字符串型</p></blockquote><h5 id="简单数据类型"><a class="markdownIt-Anchor" href="#简单数据类型">#</a> 简单数据类型</h5><p><a href="https://imgtu.com/i/IGFTQH"><img src="https://z3.ax1x.com/2021/11/08/IGFTQH.png" alt="IGFTQH.png"></a></p><h6 id="数字型"><a class="markdownIt-Anchor" href="#数字型">#</a> 数字型</h6><p>1. 在我们程序里面数字前面加 0 表示 8 进制</p><blockquote><pre><code>eg:var num = 010 转化为10进制就是8</code></pre></blockquote><p>2. 十六进制 0~9 a~f<br> 在数字前面加 0x 表示 16 进制</p><blockquote><pre><code>eg:var num = 0xa 转外为10进制就是10</code></pre></blockquote><p>3. 数字型的最大值</p><blockquote><pre><code>console.log(Number.MAX_VALUE)  1.7976e+308</code></pre></blockquote><p>4. 数字型的最小值</p><blockquote><pre><code>console.log(Number.MIN_VALUE)  5e-324</code></pre></blockquote><p>数字型的三个特殊数值<br> alert (infinity) 无穷大<br> alert (-infinity) 无穷小<br>这两个数都可以通过将前面的最大数或者最小数通过加减乘除扩大或缩小得到<br> alert (NAN) 非数值</p><p>可以通过 isNAN 用来判断非数字 并且返回一个值， 如果是数值返回的是 false 如果不是数字 返回的是 true<br>console.log(isNaN(XX));<br><a href="https://imgtu.com/i/IGFOTP"><img src="https://z3.ax1x.com/2021/11/08/IGFOTP.png" alt="IGFOTP.png"></a></p><h5 id="字符串型"><a class="markdownIt-Anchor" href="#字符串型">#</a> 字符串型</h5><p>字符串数据类型用单引号圈出 (字符串必须加引号，不然会提示错误)</p><p>注意引号内不能内嵌引号，如果要引号内嵌，使用不同的引号 (<strong>引号判定是就近一致原则</strong>)</p><blockquote><pre><code>例如:var str = "我是一个'高富帅'程序员";</code></pre></blockquote><h6 id="字符串长度"><a class="markdownIt-Anchor" href="#字符串长度">#</a> 字符串长度</h6><p>检测获取字符串的长度 用 length</p><blockquote><pre><code>        var str = 'my name is andy ';        console.log(str.length)</code></pre></blockquote><h6 id="字符转义符"><a class="markdownIt-Anchor" href="#字符转义符">#</a> 字符转义符</h6><p><a href="https://imgtu.com/i/IGkmpF"><img src="https://z3.ax1x.com/2021/11/08/IGkmpF.png" alt="IGkmpF.png"></a><br> 都是以 \ 开头 ，但是这些转义字符要写到引号里面</p><h6 id="字符串的拼接"><a class="markdownIt-Anchor" href="#字符串的拼接">#</a> 字符串的拼接</h6><blockquote><pre><code>console.log ('' + '' + '')字符串之间通过加号连接eg:console.log ('沙漠'+'骆驼 ') = '沙漠骆驼'console.log ('12' + 12) 最后为1212  这是字符串的相加   console.log (12 + 12) 最后为24   这是数字型的相加</code></pre></blockquote><p>只要有一个是字符串 其他全部都会以字符串相连<br><strong>数字相加，字符相连</strong></p><h6 id="字符串拼接加强"><a class="markdownIt-Anchor" href="#字符串拼接加强">#</a> 字符串拼接加强</h6><p>通过改变变量中的值 来改变显示中的值</p><blockquote><pre><code>eg:var age = 18;   console.log('pink老师'+age+'岁')</code></pre></blockquote><p>需要注意的时，<strong>变量不要写到字符串里面，是通过和字符串相连的方式实现的</strong></p><blockquote><pre><code>  console.log ('pink老师age岁')  console.log ('pink老师'+'age'+'岁')  console.log ('pink老师'+'age岁')</code></pre></blockquote><p>如上这些等等做法，都是不能实现的.<br><a href="https://imgtu.com/i/IGku6J"><img src="https://z3.ax1x.com/2021/11/08/IGku6J.png" alt="IGku6J.png"></a><br> 交互编程：</p><p>用户输入 → 处理 → 输出</p><blockquote><pre><code>eg         var age = prompt('请输入您的年龄');           var str = '你今年已经' + age + '岁了';           alert(str);</code></pre></blockquote><h5 id="布尔型boolean"><a class="markdownIt-Anchor" href="#布尔型boolean">#</a> 布尔型 Boolean</h5><p>布尔型中有两个值 true 和 false</p><blockquote><pre><code>eg         var flag = true; 布尔型           var flag1 = false; 布尔型</code></pre></blockquote><p>需要注意的是参与加法运算时布尔型 true 就是 1，false 就是 0.</p><h5 id="undefined-和null"><a class="markdownIt-Anchor" href="#undefined-和null">#</a> Undefined 和 Null</h5><p>如果一个变量声明未赋值 就是 undefined 未定义数据类型</p><blockquote><pre><code>   eg: var str;       console.log(var);</code></pre></blockquote><p>未定义和字符串相加，最终的结果是 undefined+ 字符串的内容</p><p>undefined 和数字相加 最后得到的结果是 NaN: not a number</p><p>null : 空值</p><blockquote><pre><code>var space = nullconsole.log(space + 'yogmas')  输出的结果是 spaceyogmasconsole.log(space + 1) 输出的结果是1  (和undefined区别)</code></pre></blockquote><h4 id="获取变量数据类型"><a class="markdownIt-Anchor" href="#获取变量数据类型">#</a> 获取变量数据类型</h4><h5 id="使用typeof来检测"><a class="markdownIt-Anchor" href="#使用typeof来检测">#</a> 使用 typeof 来检测</h5><blockquote><pre><code>   eg:   var num = 10;         console.log(typeof num);</code></pre></blockquote><p>比较特殊的是 在这里对 null 进行数据类型检测 输出来的是 object (对象)</p><p>经过检测发现 我们 prompt 取过来的值是字符型的</p><h5 id="观察控制台中的数据颜色"><a class="markdownIt-Anchor" href="#观察控制台中的数据颜色">#</a> 观察控制台中的数据颜色</h5><p>数字型 浅蓝色<br>字符型 黑色<br>布尔型 深蓝色<br> undefined 和 null 灰色</p><h4 id="字面量"><a class="markdownIt-Anchor" href="#字面量">#</a> 字面量</h4><p>字面量是在源代码中一个固定值得表示法，通俗来说，就是字面量表示如何表达这个值<br><a href="https://imgtu.com/i/IGkQmR"><img src="https://z3.ax1x.com/2021/11/08/IGkQmR.png" alt="IGkQmR.png"></a></p><h4 id="数据类型转换"><a class="markdownIt-Anchor" href="#数据类型转换">#</a> 数据类型转换</h4><p>通常会实现 3 中方式的转换<br> 1. 转换为字符串类型<br> 2. 转换为数字型<br> 3. 转换为布尔型</p><h5 id="转换成字符串型"><a class="markdownIt-Anchor" href="#转换成字符串型">#</a> 转换成字符串型</h5><p><a href="https://imgtu.com/i/IGkGtK"><img src="https://z3.ax1x.com/2021/11/08/IGkGtK.png" alt="IGkGtK.png"></a></p><blockquote><pre><code>var num = 18;console.log(num.toString())console.log(String(num))console.log(num + '')</code></pre></blockquote><p>注意:toString () 和 String () 的使用方法不同<br>三种方法中 其中拼接转换字符串最为实用</p><h5 id="转换为数字型重点"><a class="markdownIt-Anchor" href="#转换为数字型重点">#</a> 转换为数字型 (重点)</h5><p><a href="https://imgtu.com/i/IGkN1e"><img src="https://z3.ax1x.com/2021/11/08/IGkN1e.png" alt="IGkN1e.png"></a><br> 其中前两个较为实用<br> 1.parseInt (变量) 可以把字符型的转换为数字型 但是得到的是整数 并且约分不会四舍五入，会直接去掉小数点后面的数字 如果数字后面有单位，也会去掉单位，如果以字母开头那么输出的为 NaN<br>2.paseFloat (变量) 可以把字符型的转化为数字型，得到的是浮点数也就是小数，但同样也会把后面的单位去掉<br> 3.Number (变量)<br> 4. 利用了算数运算 - * / 隐式转换<br><a href="https://imgtu.com/i/IGk2cQ"><img src="https://z3.ax1x.com/2021/11/08/IGk2cQ.png" alt="IGk2cQ.png"></a></p><blockquote><pre><code>   console.log(parseInt('123'));   console.log(parseFloat('123'));   console.log(Number('123'));   console.log('12' - 0);   console.log('123' - '123');   console.log('123' * 1);</code></pre></blockquote><h5 id="转化为布尔型"><a class="markdownIt-Anchor" href="#转化为布尔型">#</a> 转化为布尔型</h5><p>代表<strong>空，否定</strong>的值会被转化为 false，如’’,0,NaN,null,undefined. 其他的值都会被转化成 true<br><a href="https://imgtu.com/i/IGkjBR"><img src="https://z3.ax1x.com/2021/11/08/IGkjBR.png" alt="IGkjBR.png"></a></p><blockquote><pre><code>eg: console.log(Boolean(''));      这是false</code></pre></blockquote><h4 id="解释型语言和编译型语言"><a class="markdownIt-Anchor" href="#解释型语言和编译型语言">#</a> 解释型语言和编译型语言</h4><p>编译型语言：全部编译成功后再执行代码.(做好菜 再吃饭)<br> 解释型语言：解释一行代码后就执行一行代码.(吃火锅：边吃边涮)</p><h4 id="标识符关键字保留字"><a class="markdownIt-Anchor" href="#标识符关键字保留字">#</a> 标识符，关键字，保留字</h4><p>标识符：开发人员为变量，属性，函数，参数取的名字<br><strong>标识符不能是关键字和保留字</strong><br>关键字：是指 js 本身已经使用了子，不能充当变量名和方法名<br><a href="https://imgtu.com/i/IGBhAs"><img src="https://z3.ax1x.com/2021/11/08/IGBhAs.png" alt="IGBhAs.png"></a><br> 保留字：预留的关键字，未来可能会成为关键字<br><a href="https://imgtu.com/i/IGBHjU"><img src="https://z3.ax1x.com/2021/11/08/IGBHjU.png" alt="IGBHjU.png"></a></p><h3 id="运算符"><a class="markdownIt-Anchor" href="#运算符">#</a> 运算符</h3><h4 id="算数运算符"><a class="markdownIt-Anchor" href="#算数运算符">#</a> 算数运算符</h4><p><a href="https://imgtu.com/i/IGAQgg"><img src="https://z3.ax1x.com/2021/11/08/IGAQgg.png" alt="IGAQgg.png"></a><br> 需要注意的是浮点数在算数运算里面会有问题 (会有一定的误差)</p><blockquote><pre><code>eg:console.log(0.07*100); 最终的结果是7.000000000000001</code></pre></blockquote><p><a href="https://imgtu.com/i/IGAaCT"><img src="https://z3.ax1x.com/2021/11/08/IGAaCT.png" alt="IGAaCT.png"></a><br> 我们不能拿着浮点数来进行相比较是否相等</p><h5 id="表达式返回值"><a class="markdownIt-Anchor" href="#表达式返回值">#</a> 表达式，返回值</h5><p>由数字，运算符，变量等组成的式子</p><p>在程序中的计算是把右边表达式计算完毕把返回值给左边</p><p>式子通过计算得到的结果 称为返回值</p><h4 id="自增和自减运算符"><a class="markdownIt-Anchor" href="#自增和自减运算符">#</a> 自增和自减运算符</h4><p>反复用给数字变量添加或者减去 1，可以用 ++ 或者–来实现<br>在 js 中，自增自减运算符既可以放在变量前面又可以放在变量后面，称为前置或者后置.<br> 需要注意的是 这个运算符必须和变量配合才能使用<br>前置和后置有区别的是，前置表示先自增或自减再返回，后置表示先返回再自增或自减<br><a href="https://imgtu.com/i/IGYJ4U"><img src="https://z3.ax1x.com/2021/11/08/IGYJ4U.png" alt="IGYJ4U.png"></a></p><h4 id="比较运算符关系运算符"><a class="markdownIt-Anchor" href="#比较运算符关系运算符">#</a> 比较运算符 &amp; 关系运算符</h4><p><a href="https://imgtu.com/i/IGYwuR"><img src="https://z3.ax1x.com/2021/11/08/IGYwuR.png" alt="IGYwuR.png"></a><br><a href="https://imgtu.com/i/IGYy4O"><img src="https://z3.ax1x.com/2021/11/08/IGYy4O.png" alt="IGYy4O.png"></a></p><h4 id="逻辑运算符"><a class="markdownIt-Anchor" href="#逻辑运算符">#</a> 逻辑运算符</h4><p><a href="https://imgtu.com/i/IGYhDI"><img src="https://z3.ax1x.com/2021/11/08/IGYhDI.png" alt="IGYhDI.png"></a></p><h5 id="短路运算逻辑中断"><a class="markdownIt-Anchor" href="#短路运算逻辑中断">#</a> 短路运算 (逻辑中断)</h5><p>原理：左边表达式的值可以确定结果时，就不再继续运算右边的值</p><p>逻辑与：如果表达式 1 结果为真，则返回表达式 2. 如果表达式 1 结果为假，则返回表达式 1<br><a href="https://imgtu.com/i/IGYIVP"><img src="https://z3.ax1x.com/2021/11/08/IGYIVP.png" alt="IGYIVP.png"></a><br><a href="https://imgtu.com/i/IGYoUf"><img src="https://z3.ax1x.com/2021/11/08/IGYoUf.png" alt="IGYoUf.png"></a><br> 逻辑或：如果表达式 1 结果为真，则返回表达式 1. 如果表达式 1 结果为假，则返回表达式 2.<br><a href="https://imgtu.com/i/IGYT58"><img src="https://z3.ax1x.com/2021/11/08/IGYT58.png" alt="IGYT58.png"></a></p><h5 id="赋值运算符"><a class="markdownIt-Anchor" href="#赋值运算符">#</a> 赋值运算符</h5><p>把右边的数据赋给左边的变量<br><a href="https://imgtu.com/i/IGYLvj"><img src="https://z3.ax1x.com/2021/11/08/IGYLvj.png" alt="IGYLvj.png"></a></p><h5 id="运算符优先级"><a class="markdownIt-Anchor" href="#运算符优先级">#</a> 运算符优先级</h5><p><a href="https://imgtu.com/i/IGtSaV"><img src="https://z3.ax1x.com/2021/11/08/IGtSaV.png" alt="IGtSaV.png"></a><br> 注意逻辑与的权重大于逻辑或的权重</p><h3 id="流程控制-分支"><a class="markdownIt-Anchor" href="#流程控制-分支">#</a> 流程控制 - 分支</h3><h4 id="流程控制"><a class="markdownIt-Anchor" href="#流程控制">#</a> 流程控制</h4><p>控制代码按照什么结构顺序来执行</p><p>流程控制有三种结构，分别是顺序结构，分支结构和循环结构<br><a href="https://imgtu.com/i/IGti24"><img src="https://z3.ax1x.com/2021/11/08/IGti24.png" alt="IGti24.png"></a></p><h5 id="顺序流程控制"><a class="markdownIt-Anchor" href="#顺序流程控制">#</a> 顺序流程控制</h5><p>按照写的代码的顺序从上到下执行，我们现在的代码大多数都是按照顺序流程控制来写的</p><h5 id="分支流程控制"><a class="markdownIt-Anchor" href="#分支流程控制">#</a> 分支流程控制</h5><p>从上到下执行代码的过程中，根据不同的条件，执行不同的路径代码，从而得到不同的结果</p><h4 id="if分支语句"><a class="markdownIt-Anchor" href="#if分支语句">#</a> if 分支语句</h4><blockquote><pre><code>if (条件表达式) {执行语句}</code></pre></blockquote><p>如果条件表达式结果为真就执行大括号里面的执行语句<br>如果条件表达式结果为假就执行 if 语句后面的代码<br><a href="https://imgtu.com/i/IGBOHJ"><img src="https://z3.ax1x.com/2021/11/08/IGBOHJ.png" alt="IGBOHJ.png"></a><br><a href="https://imgtu.com/i/IGBx41"><img src="https://z3.ax1x.com/2021/11/08/IGBx41.png" alt="IGBx41.png"></a></p><h5 id="if-else-双分支语句"><a class="markdownIt-Anchor" href="#if-else-双分支语句">#</a> if else 双分支语句</h5><p><a href="https://imgtu.com/i/IGDp36"><img src="https://z3.ax1x.com/2021/11/08/IGDp36.png" alt="IGDp36.png"></a><br> 如果表达式结果为真，那么执行语句 1 否则执行语句 2<br> 语句 1 和语句 2 只能二选一执行<br> else 后面直接加大括号而不是小括号<br><a href="https://imgtu.com/i/IGDVUA"><img src="https://z3.ax1x.com/2021/11/08/IGDVUA.png" alt="IGDVUA.png"></a></p><h5 id="if-else-多分支语句"><a class="markdownIt-Anchor" href="#if-else-多分支语句">#</a> if else 多分支语句</h5><p>利用多个条件来选择不同的语句执行，得到不同的结果，是多选 1 的过程</p><p>语法规范:<br>if (条件表达式 1) {</p><p>} else if (条件表达式 2) {</p><p>} else if …{</p><p>} else {<br>最后的语句<br>}<br> 如果条件表达式 1 满足就执行语句 1，执行完毕后退出整个 if 分支语句<br>如果条件 1 不满足就判断表达式 2 以此类推<br>如果全都不成立，则执行最后的 else 里面的语句<br>注意<br> 1. 多分支语句还是多选 1 最后只有 1 个语句能执行<br> 2.else if 里面的条件理论上是可以任意多个的<br> 3.else if 中间有个空格<br><a href="https://imgtu.com/i/IGD9gK"><img src="https://z3.ax1x.com/2021/11/08/IGD9gK.png" alt="IGD9gK.png"></a></p><h4 id="三元表达式"><a class="markdownIt-Anchor" href="#三元表达式">#</a> 三元表达式</h4><p>有三元运算符组成的式子我们称为三元表达式</p><p>条件表达式 1? 表达式 1: 表达式 2</p><p>如果条件表达式结果为真，则返回表达式 1 的值，如果条件表达式的结果为假，则返回表达式 2 的值</p><h4 id="switch语句"><a class="markdownIt-Anchor" href="#switch语句">#</a> switch 语句</h4><p>也是多分支语句可以实现多选 1 的效果<br><a href="https://imgtu.com/i/IGDn8P"><img src="https://z3.ax1x.com/2021/11/08/IGDn8P.png" alt="IGDn8P.png"></a><br> 语法结构:<br>switch (表达式) {<br>case value1:<br> 执行语句 1;<br>break;<br>case value2:<br> 执行语句 2;<br>break;<br>…………<br>default :<br> 执行最后的语句；<br>}<br> 利用表达式的值和 case 里面的选项匹配如果匹配上就执行相应的 case 里面的值，如果都没有匹配上就执行 default 里面的语句<br><a href="https://imgtu.com/i/IGDKv8"><img src="https://z3.ax1x.com/2021/11/08/IGDKv8.png" alt="IGDKv8.png"></a></p><h4 id="switch语句和-if-else-if语句的区别"><a class="markdownIt-Anchor" href="#switch语句和-if-else-if语句的区别">#</a> switch 语句和 if else if 语句的区别</h4><p>一般情况下，他们两个语句可以相互替换<br> switch…case 语句 一般在 case 为比较固定值得情况下而 if…else 语句一般来判断范围<br> switch 判断时直接跳到判断语句上而 if 语句从上往下一次判断，这样 switch 语句的效率更高一点，但是如果分支少的话 if else if 的效率会更高一点，分支多的时候 switch 语句的效率更高<br><a href="https://imgtu.com/i/IGDQKS"><img src="https://z3.ax1x.com/2021/11/08/IGDQKS.png" alt="IGDQKS.png"></a></p><h3 id="流程控制-循环"><a class="markdownIt-Anchor" href="#流程控制-循环">#</a> 流程控制 - 循环</h3><p>可以反复不断地循环执行某些代码</p><h4 id="for循环"><a class="markdownIt-Anchor" href="#for循环">#</a> for 循环</h4><p>for 循环重复执行某些代码，通常和计数有关<br>被重复的语句称为循环体，是否重复执行取决于循环的终止条件，由循环体及循环的终止条件<br>初始化变量 就是用 var 声明的一个普通变量，通常用于作为计数器使用<br>条件表达式 就是用来决定每一次循环是否继续执行 就是终止的条件<br>操作表达式 是每次循环最后执行的代码，经常用来对我们的计数器进行更新 (递增或者递减)</p><h5 id="断点调试"><a class="markdownIt-Anchor" href="#断点调试">#</a> 断点调试</h5><p>自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看着各个变量当前的值，出错的话，调试到出错的代码行及硻错误，停下.</p><p>在浏览器调试中的 source 中可以进行断点调试<br><a href="https://imgtu.com/i/IGtai8"><img src="https://z3.ax1x.com/2021/11/08/IGtai8.png" alt="IGtai8.png"></a></p><h5 id="for循环重复相同的代码"><a class="markdownIt-Anchor" href="#for循环重复相同的代码">#</a> for 循环重复相同的代码</h5><blockquote><pre><code>   var num = prompt('请输入重复的次数');   for (i = 1; i &lt;= num; i++) {   console.log('你是大傻逼');   }</code></pre></blockquote><h5 id="for循环重复不同的代码"><a class="markdownIt-Anchor" href="#for循环重复不同的代码">#</a> for 循环重复不同的代码</h5><p>循环可以重复执行不同的代码，因为计数器变量 i 的存在 i 每次循环值都会变化</p><blockquote><pre><code>   for (var i = 1; i &lt;= 100; i++) {   console.log('这个人今年' + i + '岁了');   }</code></pre></blockquote><h5 id="for循环重复相同的操作"><a class="markdownIt-Anchor" href="#for循环重复相同的操作">#</a> for 循环重复相同的操作</h5><p>例如:</p><blockquote><pre><code>   var sum = 0, aver = 0;   for (var i = 1; i &lt;= 100; i++) {   sum += i   }   aver = sum / i   console.log(aver);</code></pre></blockquote><h5 id="双重for循环"><a class="markdownIt-Anchor" href="#双重for循环">#</a> 双重 for 循环</h5><p>也就是 for 循环嵌套，在一个循环语句中 再定义一个循环语句.</p><blockquote><pre><code>for (外层的初始化变量;外层的条件表达式;外层的操作表达式) {     for (初始化变量;条件表达式;操作表达式){     }     }</code></pre></blockquote><p>里层的循环可以看成是外层循环的语句</p><h5 id="for循环小结"><a class="markdownIt-Anchor" href="#for循环小结">#</a> for 循环小结</h5><p><a href="https://imgtu.com/i/IGD1bQ"><img src="https://z3.ax1x.com/2021/11/08/IGD1bQ.png" alt="IGD1bQ.png"></a></p><h4 id="while循环"><a class="markdownIt-Anchor" href="#while循环">#</a> while 循环</h4><p><a href="https://imgtu.com/i/IGD8Ej"><img src="https://z3.ax1x.com/2021/11/08/IGD8Ej.png" alt="IGD8Ej.png"></a></p><p>条件表达式结果为 true 则执行循环体 否则 退出循环</p><p>while 循环中应该也有计数器初始化变量，也该有操作表达式完成计数器的更新防止死循环</p><h4 id="do-while-循环"><a class="markdownIt-Anchor" href="#do-while-循环">#</a> do while 循环</h4><p>语法结构</p><blockquote><p>do {循环体} while (条件表达式)</p></blockquote><p>执行思路不同的地方跟 while 在于 do whild 先执行一遍循环体再判断条件<br> do while 语句至少执行一次循环体</p><p><a href="https://imgtu.com/i/IGDwKU"><img src="https://z3.ax1x.com/2021/11/08/IGDwKU.png" alt="IGDwKU.png"></a></p><h4 id="循环小结"><a class="markdownIt-Anchor" href="#循环小结">#</a> 循环小结</h4><p><a href="https://imgtu.com/i/IGtwRg"><img src="https://z3.ax1x.com/2021/11/08/IGtwRg.png" alt="IGtwRg.png"></a></p><h3 id="continue关键字"><a class="markdownIt-Anchor" href="#continue关键字">#</a> continue 关键字</h3><p>用于立即跳出本次循环，继续下一次循环.</p><h3 id="break关键字"><a class="markdownIt-Anchor" href="#break关键字">#</a> break 关键字</h3><p>break 退出整个循环，使循环立马结束</p><h3 id="命名规范"><a class="markdownIt-Anchor" href="#命名规范">#</a> 命名规范</h3><h4 id="标志符命名规范"><a class="markdownIt-Anchor" href="#标志符命名规范">#</a> 标志符命名规范</h4><p><a href="https://imgtu.com/i/IGtrss"><img src="https://z3.ax1x.com/2021/11/08/IGtrss.png" alt="IGtrss.png"></a></p><h4 id="操作符规范"><a class="markdownIt-Anchor" href="#操作符规范">#</a> 操作符规范</h4><p>操作符左右两侧各保留一个空格<br>单行注释在 // 后面敲个空格</p><h4 id="循环作业"><a class="markdownIt-Anchor" href="#循环作业">#</a> 循环作业</h4><p><a href="https://imgtu.com/i/IGtgoV"><img src="https://z3.ax1x.com/2021/11/08/IGtgoV.png" alt="IGtgoV.png"></a></p><h3 id="javascript数组"><a class="markdownIt-Anchor" href="#javascript数组">#</a> javascript 数组</h3><h4 id="数组的概念"><a class="markdownIt-Anchor" href="#数组的概念">#</a> 数组的概念</h4><p>数组是一组数据的集合，其中每个数据都被称为元素，在数组中可以存放任何类型的元素，数组是可以将数据存储在单个变量下的优雅方式</p><h4 id="创建数组"><a class="markdownIt-Anchor" href="#创建数组">#</a> 创建数组</h4><p>1.new 创建数组<br> 2. 利用数组关键字创造数组</p><h5 id="利用new创建数组"><a class="markdownIt-Anchor" href="#利用new创建数组">#</a> 利用 new 创建数组</h5><p><a href="https://imgtu.com/i/IGrSaj"><img src="https://z3.ax1x.com/2021/11/08/IGrSaj.png" alt="IGrSaj.png"></a><br> 注意 Array 的 A 要大写</p><h5 id="利用数组字面量创建数组"><a class="markdownIt-Anchor" href="#利用数组字面量创建数组">#</a> 利用数组字面量创建数组</h5><p>[] 是数组的的字面量</p><blockquote><p>var arr = [];<br> 这样便创建了一个空的数组<br> var arr = [1,1,2,3,‘pink’,true]</p></blockquote><p>在数组内可以放任何的数据类型，但是每一个数据之间必须用逗号分隔.</p><h4 id="获取数组元素"><a class="markdownIt-Anchor" href="#获取数组元素">#</a> 获取数组元素</h4><h5 id="数组的索引"><a class="markdownIt-Anchor" href="#数组的索引">#</a> 数组的索引</h5><p>索引又被称为下标：用来访问数组元素的序号 (数组下标从 0 开始)<br><a href="https://imgtu.com/i/IGNAfS"><img src="https://z3.ax1x.com/2021/11/08/IGNAfS.png" alt="IGNAfS.png"></a></p><blockquote><pre><code> 数组名[索引号] console.log(arr[1])</code></pre></blockquote><p><strong>索引号从 0 开始</strong><br>如果没有该数组元素 就会输出 undefined</p><h4 id="遍历数组"><a class="markdownIt-Anchor" href="#遍历数组">#</a> 遍历数组</h4><p>遍历：就是把数组中的每个元素从头到尾访问一次</p><blockquote><pre><code>eg:var arr = [1, 2, 3, 4, 5, 'pink'];   for (i = 0; i &lt; 6; i++) {   console.log(arr[i]);   }</code></pre></blockquote><p>输出的时候计数器当索引号来用</p><h5 id="数组长度"><a class="markdownIt-Anchor" href="#数组长度">#</a> 数组长度</h5><p>数组名.length  可以访问数组中的数组元素的数量</p><blockquote><pre><code>console.log(arr.length);</code></pre></blockquote><p>同时 数组名.length 可以动态检测数组元素的个数</p><h4 id="数组中新增元素"><a class="markdownIt-Anchor" href="#数组中新增元素">#</a> 数组中新增元素</h4><h5 id="通过修改length长度新增数组长度"><a class="markdownIt-Anchor" href="#通过修改length长度新增数组长度">#</a> 通过修改 length 长度新增数组长度</h5><blockquote><pre><code>   var arr = ['pink', 'red', 'blue'];   arr.length = 5</code></pre></blockquote><p>如果扩容的数组元素中没有给值，其中的元素是 undefined</p><h5 id="修改索引号-增加数组元素"><a class="markdownIt-Anchor" href="#修改索引号-增加数组元素">#</a> 修改索引号 增加数组元素</h5><blockquote><pre><code>var arr = ['pink', 'red', 'blue'];arr[3] = 'pink'</code></pre></blockquote><p>如果这个索引号原先已经被占用，就会替换原来的数组元素<br><strong>不要直接给数组名赋值，否则会覆盖掉以前的数据，导致数据一个都没有了</strong></p><h4 id="筛选数组的方法"><a class="markdownIt-Anchor" href="#筛选数组的方法">#</a> 筛选数组的方法</h4><h5 id="方法1"><a class="markdownIt-Anchor" href="#方法1">#</a> 方法 1</h5><blockquote><pre><code>   var arr = [1, 2, 3, 4, 5, 6, 8, 11, 45, 13, 48, 46, 13];   var newArr = [];   var j = 0;   for (var i = 0; i &lt; arr.length; i++) {       if (arr[i] &gt; 10) {           newArr[j] = arr[i]           j++       }   }   console.log(newArr);</code></pre></blockquote><p>这里通过声明一个变量 j 来使新数组从 0 开始</p><h5 id="方法2"><a class="markdownIt-Anchor" href="#方法2">#</a> 方法 2</h5><blockquote><pre><code>   var arr = [1, 2, 3, 4, 5, 6, 8, 11, 45, 13, 48, 46, 13];   var newArr = [];   for (var i = 0; i &lt; arr.length; i++) {       if (arr[i] &gt; 10) {           newArr[newArr.length] = arr[i]       }   }   console.log(newArr);</code></pre></blockquote><p>将 j 替换成 newArr, 最开始当新数组里面没有元素时是 0，当有元素时 newArr.length 开始不断增多</p><h4 id="翻转数组"><a class="markdownIt-Anchor" href="#翻转数组">#</a> 翻转数组</h4><blockquote><pre><code>   var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];   var newArr = [];   for (i = arr.length - 1; i &gt;= 0; i--) {       newArr[newArr.length] = arr[i]   }   console.log(newArr);</code></pre></blockquote><p>这里需要注意的是：元素的索引号的最大值等于数组长度 - 1</p><h4 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序">#</a> 冒泡排序</h4><p>是一种算法，把一系列数组按照一定的顺序进行排列显示 (从小到大或者从大到小)<br> 算法：观察执行过程，从而找到其中的规律，并且找到代码</p><blockquote><pre><code>   var arr = [1, 5, 4, 3, 2];   for (var i = 0; i &lt; arr.length - 1; i++) { // 外层循环次数       for (var j = 0; j &lt; arr.length - i - 1; j++) { // 内层循环次数           if (arr[j] &gt; arr[j + 1]) {               var temp = arr[j]               arr[j] = arr[j + 1]               arr[j + 1] = temp           }       }   }</code></pre></blockquote><h3 id="javascript函数"><a class="markdownIt-Anchor" href="#javascript函数">#</a> javascript 函数</h3><h4 id="函数的概念"><a class="markdownIt-Anchor" href="#函数的概念">#</a> 函数的概念</h4><p>js 中经常会定义相同的代码，这些代码可能会大量使用<br>函数：就是封装了一段可被重复调用执行的代码块，通过调用代码块可以实现大量代码的重复使用.</p><h4 id="函数的使用"><a class="markdownIt-Anchor" href="#函数的使用">#</a> 函数的使用</h4><p>步骤：1. 声明函数 2. 调用函数</p><h5 id="声明函数"><a class="markdownIt-Anchor" href="#声明函数">#</a> 声明函数</h5><blockquote><pre><code>function 函数名() {函数体}</code></pre></blockquote><p>注意事项：1.function 声明函数的关键字 全部小写 2. 函数是做某件事情，函数名一般是动词 3. 函数不调用自己不会执行</p><h5 id="调用函数"><a class="markdownIt-Anchor" href="#调用函数">#</a> 调用函数</h5><blockquote><pre><code>函数名();</code></pre></blockquote><p>调用函数时，千万不要忘了加小括号.</p><h5 id="函数的参数"><a class="markdownIt-Anchor" href="#函数的参数">#</a> 函数的参数</h5><p>我们可以利用函数的参数实现函数重复不同的代码<br>参数: 1. 形参 2. 实参<br><a href="https://imgtu.com/i/IGrNod"><img src="https://z3.ax1x.com/2021/11/08/IGrNod.png" alt="IGrNod.png"></a></p><blockquote><pre><code>function (形参1,形参2,....) {  在声明函数的小括号里面是形参 }函数名(实参1,实参2...)     在函数调用的小括号里面是实参</code></pre></blockquote><p>形参类似于一个变量来接受实参的<br>函数的参数可以有也可以没有，个数不限<br>多个参数之间用逗号隔开</p><h6 id="函数形参实参个数匹配"><a class="markdownIt-Anchor" href="#函数形参实参个数匹配">#</a> 函数形参实参个数匹配</h6><p>1. 如果实参的个数和形参的个数一直，则正常输出结果<br> 2. 如果实参的个数多于形参的个数，会取到形参的个数，实参中多的自动忽略<br> 3. 如果实参的个数小于形参的个数，num2 可以看做一个变量但是没有接收值，所以最终的结果就是 undefined<br><a href="https://imgtu.com/i/IGN3fU"><img src="https://z3.ax1x.com/2021/11/08/IGN3fU.png" alt="IGN3fU.png"></a></p><h6 id="函数参数小结"><a class="markdownIt-Anchor" href="#函数参数小结">#</a> 函数参数小结</h6><p><a href="https://imgtu.com/i/IGrBSP"><img src="https://z3.ax1x.com/2021/11/08/IGrBSP.png" alt="IGrBSP.png"></a></p><h5 id="函数的返回值"><a class="markdownIt-Anchor" href="#函数的返回值">#</a> 函数的返回值</h5><h6 id="return语句"><a class="markdownIt-Anchor" href="#return语句">#</a> return 语句</h6><p>函数只是实现某种功能，最终的结果需要返回给函数的调用者函数名 () 通过 return 实现<br>只要函数遇到 return 就把后面的结果返回给函数的调用者 函数名 ()=return 后面的结果</p><blockquote><pre><code> function 函数名() {       return 需要返回的结果; } 函数名();</code></pre></blockquote><p>代码验证</p><blockquote><pre><code>   function getSum(num1, num2) {       return num1 + num2;   }   console.log(getSum(1, 3));</code></pre></blockquote><p>这样输出的结果就是 4 (来自于 1+3)</p><p>return 终止函数：函数遇到 return 就终止函数<br> return 的返回值:return 只能返回一个值，如果有多个值，return 只返回最后一个值<br>如果想要返回多个数值时，我们可以将数值放在一个数组里面，一个数组代表一个结果<br>函数如果 return 则返回的是 return 后面的值，如果函数没有 return 就返回 undefined<br>break,continue,return 的区别:<br><a href="https://imgtu.com/i/IGrDQf"><img src="https://z3.ax1x.com/2021/11/08/IGrDQf.png" alt="IGrDQf.png"></a></p><h4 id="函数的理解"><a class="markdownIt-Anchor" href="#函数的理解">#</a> 函数的理解</h4><p><a href="https://imgtu.com/i/IGNJl4"><img src="https://z3.ax1x.com/2021/11/08/IGNJl4.png" alt="IGNJl4.png"></a></p><h4 id="函数的作业"><a class="markdownIt-Anchor" href="#函数的作业">#</a> 函数的作业</h4><p><a href="https://imgtu.com/i/IGrWYn"><img src="https://z3.ax1x.com/2021/11/08/IGrWYn.png" alt="IGrWYn.png"></a></p><h4 id="arguments的作用"><a class="markdownIt-Anchor" href="#arguments的作用">#</a> arguments 的作用</h4><p>当我们不确定有多少个参数传递时，可以用 argument 在获取，他实际上是当前函数的一个内置对象，arguements 存储了传递过来的所有实参</p><p>arguments 实际上是伪数组.<br> 伪数组:<br>1. 具有数组的 length 属性.<br>2. 按照索引的方式进行存储.<br>3. 没有真正数组的一些方法:pop () 等</p><h4 id="函数可以调用另外一个函数"><a class="markdownIt-Anchor" href="#函数可以调用另外一个函数">#</a> 函数可以调用另外一个函数</h4><h4 id="函数的两种声明方式"><a class="markdownIt-Anchor" href="#函数的两种声明方式">#</a> 函数的两种声明方式</h4><p>1. 利用函数关键字自定义函数</p><blockquote><pre><code>function fn() {}fn()</code></pre></blockquote><p>也被称为命名函数</p><p>2. 函数表达式</p><blockquote><pre><code>var 变量名 = function() {}</code></pre></blockquote><p>又被叫做匿名函数<br>这是变量名不是函数名<br>函数表达式声明方式跟声明变量差不多，只不过变量里面存的是值，而函数表达式里面存的是函数。</p><h3 id="作用域"><a class="markdownIt-Anchor" href="#作用域">#</a> 作用域</h3><h4 id="作用域概述"><a class="markdownIt-Anchor" href="#作用域概述">#</a> 作用域概述</h4><p>1.js 的作用域就是代码名字在某个范围内起作用和效果 目的是为了提高程序的可靠性，重要的是减少命名冲突<br> 2.js 的作用域 (es6) 之前：全局作用域 和 局部作用域<br> 3. 全局作用域：整个 script 标签 或者是一个单独的 js 文件<br> 4. 局部作用域：在函数内部就是局部作用域，这个代码的名字只在函数内部起作用和效果 又叫做函数作用域</p><h4 id="变量的作用域"><a class="markdownIt-Anchor" href="#变量的作用域">#</a> 变量的作用域</h4><p>根据作用域的不同我们变量分为全局变量和局部变量<br> 1. 全局变量：在全局作用域下的变量 在全局下都可以使用 (当然包括函数内部)<br> 2. 局部变量：在局部作用域下的变量 在函数内部的变量就是局部变量 只能在函数内部使用<br> 3. 特殊情况：如果在函数内部没有声明直接赋值的变量也称为全局变量，函数的形参也可以看成局部变量</p><p>从执行效率来看全局变量和局部变量<br> 1. 全局变量只有浏览器关闭的时候才会销毁，比较占内存资源<br> 2. 局部变量 当我们程序执行完毕就会销毁，比较节约内存支援<br><strong>现阶段 js 没有块级作用域</strong></p><h4 id="作用域链"><a class="markdownIt-Anchor" href="#作用域链">#</a> 作用域链</h4><p>内部函数访问外部函数的电量，采取的是链式查找的方式来决定取哪种值，这种结构我们称为作用域链<br>内部函数是可以访问外部函数的变量的</p><h3 id="javascript预解析"><a class="markdownIt-Anchor" href="#javascript预解析">#</a> javascript 预解析</h3><p>1.js 解析器在运行 js 代码的时候分为两部分：先进行预解析，再进行代码执行<br> (2). 预解析:js 引擎会把 js 里面所有的 var 还有 function 提升到当前作用域的最前面<br> (3). 代码执行：按照代码书写的顺序从上往下执行.<br>2. 预解析分为变量预解析 (变量提升) 和函数预解析 (函数执行)<br>(1). 变量提升：就是把所有的变量声明提升到当前的作用域最前面 不提升赋值</p><blockquote><pre><code>console.log(num);var num= 10;在预解析的时候执行顺序是这样的var num;console.log(num);num=10</code></pre></blockquote><p>(2). 函数声明：就是先把函数声明提升到当前作用域的最前面，不执行函数.</p><h3 id="js对象"><a class="markdownIt-Anchor" href="#js对象">#</a> js 对象</h3><h4 id="对象概念"><a class="markdownIt-Anchor" href="#对象概念">#</a> 对象概念</h4><p>对象是一个具体的事物 (不是泛指)<br> 比如 明星不是对象 但刘德华是对象<br><a href="https://imgtu.com/i/IGNspD"><img src="https://z3.ax1x.com/2021/11/08/IGNspD.png" alt="IGNspD.png"></a></p><h4 id="对象的使用方向"><a class="markdownIt-Anchor" href="#对象的使用方向">#</a> 对象的使用方向</h4><p>保存一个值可以使用变量，保存多个值可以使用数组，但如果保存一个人的完整信就需要用到对象了</p><h4 id="创建对象的三种方式"><a class="markdownIt-Anchor" href="#创建对象的三种方式">#</a> 创建对象的三种方式</h4><p>1. 利用字面量创建对象<br> 2. 利用 new Object 创建对象<br> 3. 利用构造函数创建对象</p><h4 id="对象字面量"><a class="markdownIt-Anchor" href="#对象字面量">#</a> 对象字面量</h4><p>{} 是对象的字面量<br> 1. 里面的属性或者方法我们采取键值对的形式 键 属性名：值 属性值<br> 2. 多个属性或者方法中间用逗号隔开，函数后面加；而不加逗号<br> 3. 方法冒号后面跟的是一个匿名函数</p><h4 id="使用对象"><a class="markdownIt-Anchor" href="#使用对象">#</a> 使用对象</h4><p>调用对象的属性 我们采取 对象名。属性名</p><blockquote><p>console.log(obj.uname)</p></blockquote><p>其中这个。我们可以理解为的 比如说对象的属性<br>调用属性还有一种方法 对象名 [‘属性名’]</p><blockquote><p>console.log(abj[‘age’])</p></blockquote><p>需要注意的是 后面这种方法需要’' 而前面一种方法不需要<br>调用对象中的函数时，千万不要忘记添加小括号<br><a href="https://imgtu.com/i/IGN66H"><img src="https://z3.ax1x.com/2021/11/08/IGN66H.png" alt="IGN66H.png"></a></p><h4 id="变量-属性-函数-方法的区别"><a class="markdownIt-Anchor" href="#变量-属性-函数-方法的区别">#</a> 变量 属性 函数 方法的区别</h4><p>相同点：都是用来存储数据的<br>不同点：1. 变量 单独声明并赋值 使用的时候直接写变量名 单独存在<br> 2. 属性 在对象里面的不需要声明的 使用的时候必须是 对象。属性</p><p>函数和方法<br>相同点：都是实现某种功能 做某件事<br>不同点：函数时单独声明 并且调用的 是单独存在的<br>方法 在对象里面</p><h4 id="利用new-object来创建对象"><a class="markdownIt-Anchor" href="#利用new-object来创建对象">#</a> 利用 new Object 来创建对象</h4><blockquote><pre><code>var obj = new Object();   创建了一个空的对象obj.uname = '张三丰';</code></pre></blockquote><p>利用 等号 = 赋值的方法 添加对象的属性和方法<br>每个属性和方法之间用分号结束</p><h4 id="利用构造函数创建对象"><a class="markdownIt-Anchor" href="#利用构造函数创建对象">#</a> 利用构造函数创建对象</h4><p>构造函数 就是把我们对象里面一些相同的属性和方法抽象出来封装到函数里面<br>语法格式:</p><blockquote><pre><code>function 构造函数名() {    this.属性 = 值;    this.方法 = function() {} }使用: new 构造函数名();</code></pre></blockquote><p>1. 构造函数名的首字母要大写<br> 2. 构造函数 不需要 return 就可以返回结果<br> 3. 我们调用构造函数必须使用 new<br>4. 属性和方法前面必须添加 this<br><a href="https://imgtu.com/i/IGroOU"><img src="https://z3.ax1x.com/2021/11/08/IGroOU.png" alt="IGroOU.png"></a></p><h4 id="for-in遍历我们的对象"><a class="markdownIt-Anchor" href="#for-in遍历我们的对象">#</a> for in 遍历我们的对象</h4><blockquote><pre><code>for (变量 in 对象) {  }</code></pre></blockquote><h3 id="javascript内置对象"><a class="markdownIt-Anchor" href="#javascript内置对象">#</a> javascript 内置对象</h3><p>1. 自定义对象<br> 2. 内置对象<br> 3. 浏览器对象 (js 特有)</p><p>内置对象是 js 语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或者是最基本的属性和方法<br> Math Date Array String</p><h4 id="查阅文档"><a class="markdownIt-Anchor" href="#查阅文档">#</a> 查阅文档</h4><blockquote><pre><code>https://developer.mozilla.org/zh-CN</code></pre></blockquote><p><a href="https://imgtu.com/i/IGNW7t"><img src="https://z3.ax1x.com/2021/11/08/IGNW7t.png" alt="IGNW7t.png"></a></p><h4 id="math对象"><a class="markdownIt-Anchor" href="#math对象">#</a> Math 对象</h4><p>不是一个构造函数，不用 new 来调用，直接使用即可<br><a href="https://imgtu.com/i/IGr7mF"><img src="https://z3.ax1x.com/2021/11/08/IGr7mF.png" alt="IGr7mF.png"></a></p><p>Math.round 四舍五入中.5 是特殊数字 他往大了去  比如 - 1.5 的结果是 - 1</p><h5 id="math随机数法"><a class="markdownIt-Anchor" href="#math随机数法">#</a> Math 随机数法</h5><blockquote><pre><code>console.log(Math.random());</code></pre></blockquote><h4 id="date日期数法"><a class="markdownIt-Anchor" href="#date日期数法">#</a> Date 日期数法</h4><p>是一个构造函数 必须使用 new 来调用创建我们的日期对象</p><blockquote><pre><code>   var day = new Date();   console.log(day);</code></pre></blockquote><p>使用 date 如果没有参数 返回当前系统的当前时间<br>参数常用的写法 数字型 2019,10,01 或者是字符串型’2019-10-01’<br><a href="https://imgtu.com/i/IGrbTJ"><img src="https://z3.ax1x.com/2021/11/08/IGrbTJ.png" alt="IGrbTJ.png"></a></p><h5 id="日期格式化date"><a class="markdownIt-Anchor" href="#日期格式化date">#</a> 日期格式化 Date</h5><p><a href="https://imgtu.com/i/IGNo9S"><img src="https://z3.ax1x.com/2021/11/08/IGNo9S.png" alt="IGNo9S.png"></a><br> 返回的月份小一个月 记得月份 +1</p><h5 id="获取日期的总的毫秒形式"><a class="markdownIt-Anchor" href="#获取日期的总的毫秒形式">#</a> 获取日期的总的毫秒形式</h5><p>Date 对象是基于 1970 年 1 月 1 日 (世界标准时间) 起的毫秒数</p><blockquote><pre><code>1.valueOf()    getTime()2.var date1= +new Date();3.H5新增 console(Date.now());</code></pre></blockquote><h4 id="数组对象array"><a class="markdownIt-Anchor" href="#数组对象array">#</a> 数组对象 Array</h4><p>1. 数组字面量创建<br> 2. 利用 new Array () 创建</p><p>检测是非为数组<br> 1.instanceof Array<br>2.Array.isArray (参数)</p><h5 id="添加删除数组元素的方法"><a class="markdownIt-Anchor" href="#添加删除数组元素的方法">#</a> 添加删除数组元素的方法</h5><p><a href="https://imgtu.com/i/IGN7cQ"><img src="https://z3.ax1x.com/2021/11/08/IGN7cQ.png" alt="IGN7cQ.png"></a><br> 添加:arr.push ();arr.unshift ();<br> 删除:arr.pop ();arr.shift;</p><h5 id="数组排序"><a class="markdownIt-Anchor" href="#数组排序">#</a> 数组排序</h5><p><a href="https://imgtu.com/i/IGNqns"><img src="https://z3.ax1x.com/2021/11/08/IGNqns.png" alt="IGNqns.png"></a></p><blockquote><pre><code>       arr1.sort(function (a, b) {       return a - b //升序的顺序排列       //return b - a 是降序的顺序排列        });</code></pre></blockquote><h5 id="数组索引方法"><a class="markdownIt-Anchor" href="#数组索引方法">#</a> 数组索引方法</h5><p><a href="https://imgtu.com/i/IGNO7q"><img src="https://z3.ax1x.com/2021/11/08/IGNO7q.png" alt="IGNO7q.png"></a><br> 注意，如果有两个重复 只范湖第一个满足条件的索引号。如果里面没有相对元素返回的结果是 - 1;</p><h5 id="数组转化成字符串"><a class="markdownIt-Anchor" href="#数组转化成字符串">#</a> 数组转化成字符串</h5><p><a href="https://imgtu.com/i/IGUiu9"><img src="https://z3.ax1x.com/2021/11/08/IGUiu9.png" alt="IGUiu9.png"></a></p><h4 id="字符串对象"><a class="markdownIt-Anchor" href="#字符串对象">#</a> 字符串对象</h4><p>基本包装类型：就是把简单数据类型 包装称为了 复杂数据类型<br> (1) 把简单数据类型包装称为复杂数据类型<br> var temp = new String (‘Andy’)<br>(2) 把临时变量的值给 str<br>str=temp<br> (3) 销毁这个临时变量<br> temp = null<br><a href="https://imgtu.com/i/IGrOYR"><img src="https://z3.ax1x.com/2021/11/08/IGrOYR.png" alt="IGrOYR.png"></a></p><h5 id="字符串的不可变型"><a class="markdownIt-Anchor" href="#字符串的不可变型">#</a> 字符串的不可变型</h5><p><a href="https://imgtu.com/i/IGU1HI"><img src="https://z3.ax1x.com/2021/11/08/IGU1HI.png" alt="IGU1HI.png"></a></p><blockquote><pre><code>   var str = '改革吹风吹满地'   console.log(str.indexOf('吹',3));</code></pre></blockquote><h5 id="根据位置返回字符"><a class="markdownIt-Anchor" href="#根据位置返回字符">#</a> 根据位置返回字符</h5><p><a href="https://imgtu.com/i/IGUUgg"><img src="https://z3.ax1x.com/2021/11/08/IGUUgg.png" alt="IGUUgg.png"></a></p><h5 id="字符串操作方法"><a class="markdownIt-Anchor" href="#字符串操作方法">#</a> 字符串操作方法</h5><p><a href="https://imgtu.com/i/IGUavQ"><img src="https://z3.ax1x.com/2021/11/08/IGUavQ.png" alt="IGUavQ.png"></a></p><blockquote><pre><code>   var str = '改革春风吹满地'   console.log(str.substr(2, 2));  //第一个2是索引号的2  第二个2是取几个字符</code></pre></blockquote><h5 id="替换字符串"><a class="markdownIt-Anchor" href="#替换字符串">#</a> 替换字符串</h5><blockquote><pre><code>replace('被替换的字符','替换为的字符')</code></pre></blockquote><p>如果有相同的两个字符 只会替换前面一个字符</p><h5 id="把字符串转化成数组"><a class="markdownIt-Anchor" href="#把字符串转化成数组">#</a> 把字符串转化成数组</h5><p>split (‘分隔符’) 把字符转换成数组<br> join (‘分隔符’) 把数组转换成字符串</p><p>split 中的分隔符取决于原字符串中的分隔符是什么</p><h3 id="web-apis"><a class="markdownIt-Anchor" href="#web-apis">#</a> Web APIs</h3><p>浏览器提供的一套操作浏览器功能和页面元素的 API</p><h4 id="dom"><a class="markdownIt-Anchor" href="#dom">#</a> DOM</h4><p><a href="https://imgtu.com/i/IGrvSx"><img src="https://z3.ax1x.com/2021/11/08/IGrvSx.png" alt="IGrvSx.png"></a></p><h4 id="获取页面元素"><a class="markdownIt-Anchor" href="#获取页面元素">#</a> 获取页面元素</h4><h5 id="id获取"><a class="markdownIt-Anchor" href="#id获取">#</a> ID 获取</h5><p>getElementByld()<br> console.dir (); 打印我们返回的元素对象 更好地查看里面的属性和方法</p><h5 id="根据标签名来获取"><a class="markdownIt-Anchor" href="#根据标签名来获取">#</a> 根据标签名来获取</h5><p>element.getElementsByTagName (‘标签名’)<br> 1. 获取过来元素对象的集合 以伪数组的形式储存<br> 2. 如果页面中只有一个元素 返回的还是伪数组的形式<br> 3. 如果页面中没有这个元素 返回的是空的伪数组</p><blockquote><pre><code>   var lis = document.getElementsByTagName('ul')   var li = lis[0].getElementsByTagName('li')</code></pre></blockquote><h5 id="根据类型来获取新增html5属性"><a class="markdownIt-Anchor" href="#根据类型来获取新增html5属性">#</a> 根据类型来获取 (新增 Html5 属性)</h5><p>document.getElementsByClassName (‘类名’)<br> document.querySelector (‘选择器’) 根据选择器返回第一个元素对象<br> document.querySelectorAll (‘选择器’) 根据选择器返回所有的集合</p><h5 id="获取特殊元素"><a class="markdownIt-Anchor" href="#获取特殊元素">#</a> 获取特殊元素</h5><p>1. 获取 body 元素<br> document.body<br>2. 获取 html 元素<br> document.documentElement</p><h4 id="事件基础"><a class="markdownIt-Anchor" href="#事件基础">#</a> 事件基础</h4><p>js 让我们有能力创建动态页面，而时间是可以被 js 侦测到的行为<br>在网页中每个元素都可以产生某些触发 js 的事件</p><p>事件的组成部分<br> 1. 事件源：事件被触发的对象<br> 2. 事件类型：如何触发 什么事件 比如 鼠标点击 (onclick) 触发  还是鼠标经过触发<br> 3. 事件处理程序：通过函数赋值的方式完成</p><h5 id="执行事件的步骤"><a class="markdownIt-Anchor" href="#执行事件的步骤">#</a> 执行事件的步骤</h5><p>1. 获取事件源<br> 2. 绑定事件<br> 3. 添加事件处理程序 (采取函数赋值的形式)</p><h4 id="操作元素"><a class="markdownIt-Anchor" href="#操作元素">#</a> 操作元素</h4><h5 id="改变元素内容"><a class="markdownIt-Anchor" href="#改变元素内容">#</a> 改变元素内容</h5><p>element.innerText<br>element.innerHTML<br> 这两个属性是可读写的 可以获取元素里面的内容<br><a href="https://imgtu.com/i/IGUy5V"><img src="https://z3.ax1x.com/2021/11/08/IGUy5V.png" alt="IGUy5V.png"></a></p><h5 id="改变元素属性"><a class="markdownIt-Anchor" href="#改变元素属性">#</a> 改变元素属性</h5><h5 id="表单元素属性设置"><a class="markdownIt-Anchor" href="#表单元素属性设置">#</a> 表单元素属性设置</h5><p><a href="https://imgtu.com/i/IGURv4"><img src="https://z3.ax1x.com/2021/11/08/IGURv4.png" alt="IGURv4.png"></a></p><h5 id="修改样式属性"><a class="markdownIt-Anchor" href="#修改样式属性">#</a> 修改样式属性</h5><p>element.style 行内样式操作<br> element.className 类名样式操作<br><a href="https://imgtu.com/i/IGaMGT"><img src="https://z3.ax1x.com/2021/11/08/IGaMGT.png" alt="IGaMGT.png"></a></p><p>onfocus 获得焦点事件<br> onblur 失去焦点事件</p><h5 id="操作元素总结"><a class="markdownIt-Anchor" href="#操作元素总结">#</a> 操作元素总结</h5><p><a href="https://imgtu.com/i/IGaNIx"><img src="https://z3.ax1x.com/2021/11/08/IGaNIx.png" alt="IGaNIx.png"></a></p><h5 id="排他思想"><a class="markdownIt-Anchor" href="#排他思想">#</a> 排他思想</h5><p>先清除样式，再给当前元素设置样式</p><blockquote><pre><code>   var btn = document.getElementsByTagName('button')   for (i = 0; i &lt; btn.length; i++) {       btn[i].onclick = function () {           for (i = 0; i &lt; btn.length; i++) {               btn[i].style.backgroundColor = 'white'           }           this.style.backgroundColor = 'pink'       }   }</code></pre></blockquote><p>鼠标经过 onmouseover<br> 鼠标离开 onmouseout</p><h5 id="自定义属性值的操作"><a class="markdownIt-Anchor" href="#自定义属性值的操作">#</a> 自定义属性值的操作</h5><h6 id="获取属性值"><a class="markdownIt-Anchor" href="#获取属性值">#</a> 获取属性值</h6><p><a href="https://imgtu.com/i/IGa0zD"><img src="https://z3.ax1x.com/2021/11/08/IGa0zD.png" alt="IGa0zD.png"></a></p><h6 id="设置属性值"><a class="markdownIt-Anchor" href="#设置属性值">#</a> 设置属性值</h6><p>element. 属性 = ‘值’<br>element.setAttribute (‘属性’,‘值’)</p><p>setAttribute 主要用于设置自定义属性</p><p>removeAttribute 移除属性</p><h6 id="h5自定义属性值"><a class="markdownIt-Anchor" href="#h5自定义属性值">#</a> H5 自定义属性值</h6><p>H5 新规范：自定义属性都用 data- 开头<br> H5 新增的获取自定义属性的方法 <a href="http://element.dataset.XXX">element.dataset.XXX</a><br>dataset 是一个集合 里面存放了所有以 data 开头的自定义属性<br>如果自定义属性里面有多个 - 链接的单词，我们获取的时候采取驼峰命名法</p><p><a href="https://imgtu.com/i/IGrz6K"><img src="https://z3.ax1x.com/2021/11/08/IGrz6K.png" alt="IGrz6K.png"></a></p><h4 id="节点操作"><a class="markdownIt-Anchor" href="#节点操作">#</a> 节点操作</h4><p>为什么要学节点操作<br><a href="https://imgtu.com/i/IGaRFP"><img src="https://z3.ax1x.com/2021/11/08/IGaRFP.png" alt="IGaRFP.png"></a></p><h5 id="节点概述"><a class="markdownIt-Anchor" href="#节点概述">#</a> 节点概述</h5><p><a href="https://imgtu.com/i/IGa4SS"><img src="https://z3.ax1x.com/2021/11/08/IGa4SS.png" alt="IGa4SS.png"></a></p><h5 id="节点层级"><a class="markdownIt-Anchor" href="#节点层级">#</a> 节点层级</h5><p><a href="https://imgtu.com/i/IGaIyQ"><img src="https://z3.ax1x.com/2021/11/08/IGaIyQ.png" alt="IGaIyQ.png"></a></p><h5 id="父节点"><a class="markdownIt-Anchor" href="#父节点">#</a> 父节点</h5><p><a href="https://imgtu.com/i/IGaHwn"><img src="https://z3.ax1x.com/2021/11/08/IGaHwn.png" alt="IGaHwn.png"></a></p><h5 id="子节点"><a class="markdownIt-Anchor" href="#子节点">#</a> 子节点</h5><p><a href="https://imgtu.com/i/IGaLF0"><img src="https://z3.ax1x.com/2021/11/08/IGaLF0.png" alt="IGaLF0.png"></a><br><a href="https://imgtu.com/i/IGaboq"><img src="https://z3.ax1x.com/2021/11/08/IGaboq.png" alt="IGaboq.png"></a><br><a href="https://imgtu.com/i/IGdSOJ"><img src="https://z3.ax1x.com/2021/11/08/IGdSOJ.png" alt="IGdSOJ.png"></a></p><h5 id="兄弟节点"><a class="markdownIt-Anchor" href="#兄弟节点">#</a> 兄弟节点</h5><p><a href="https://imgtu.com/i/IGdCwR"><img src="https://z3.ax1x.com/2021/11/08/IGdCwR.png" alt="IGdCwR.png"></a><br> 解决兄弟节点的兼容性问题:<br><a href="https://imgtu.com/i/IGdumd"><img src="https://z3.ax1x.com/2021/11/08/IGdumd.png" alt="IGdumd.png"></a></p><h5 id="创建和删除节点"><a class="markdownIt-Anchor" href="#创建和删除节点">#</a> 创建和删除节点</h5><h6 id="创建节点"><a class="markdownIt-Anchor" href="#创建节点">#</a> 创建节点</h6><p><a href="https://imgtu.com/i/IGsC0e"><img src="https://z3.ax1x.com/2021/11/08/IGsC0e.png" alt="IGsC0e.png"></a></p><h6 id="添加节点"><a class="markdownIt-Anchor" href="#添加节点">#</a> 添加节点</h6><p><a href="https://imgtu.com/i/IGdGp8"><img src="https://z3.ax1x.com/2021/11/08/IGdGp8.png" alt="IGdGp8.png"></a><br>node.appendChild(child)<br> node.insertbefore (child, 指定元素);</p><h6 id="删除节点"><a class="markdownIt-Anchor" href="#删除节点">#</a> 删除节点</h6><p>code.removeChild (节点)<br>eg:ul.removeChild(ul.children[0])</p><h6 id="复制节点克隆节点"><a class="markdownIt-Anchor" href="#复制节点克隆节点">#</a> 复制节点 (克隆节点)</h6><p>node.cloneNode()<br> 如果括号为空，则只复制标签 不复制里面的内容<br>括号里面为 true 则里面的内容也跟着赋值</p><h6 id="三种动态创建元素区别"><a class="markdownIt-Anchor" href="#三种动态创建元素区别">#</a> 三种动态创建元素区别</h6><p>document.write () 如果页面加载完毕 再执行这个指令 会导致页面全部重绘<br> innerHTML<br>document.createElement(’’)<br> 最后两个大致上没有区别 但是如果需要创造很多个元素 最后一个的效率会大大提高，因为最后一个不是拼接字符串 而是在电脑中重新开辟一个新的空间</p><p><a href="https://imgtu.com/i/IGdDhV"><img src="https://z3.ax1x.com/2021/11/08/IGdDhV.png" alt="IGdDhV.png"></a><br> 改进方法:innerHTML 不采用拼接字符串的方式，而是采用数组形式拼接，现在数组中拼接字符串，然后将数组引入到 innerHTML 中</p><h4 id="dom重点核心"><a class="markdownIt-Anchor" href="#dom重点核心">#</a> DOM 重点核心</h4><p>(一) 创建<br> 1.document.write<br>2.innerHTML<br>3.createElement<br> (二) 增<br> 1.appendChild<br>2.innerBefore<br> (三) 删<br> 1.removeChild<br> (四) 改<br> 1. 修改元素属性:src,href,title<br>2. 修改普通元素内容:innerHTML,innerText<br>3. 修改表单元素:value,type,disabled<br>4. 修改元素样式:style,className<br> (五) 查<br> 1.DOM 提供的 API 方法:getElementById,getElementsByTagName  (<strong>古老用法不推荐</strong>)<br> 2.H5 提供的新方法:querySelector,querySelectorAll 提倡<br> 3. 利用节点获取元素：父 (parentNode), 子 (children), 兄 (previousElementSibing,nextElementSibing) 提倡<br> (六) 属性操作<br> 1.setAttribute: 设置 dom 的属性值<br> 2.getAttribute: 得到 dom 的属性值<br> 3.removeAttribute: 移除属性<br> (七) 事件操作<br> onclick: 鼠标点击左键触发<br> onmouseover: 鼠标经过触发<br> onmouseout: 鼠标离开触发<br> onfocus: 获得鼠标焦点触发<br> onblur: 失去鼠标焦点触发<br> onmousemove: 鼠标移动触发<br> onmouseup: 鼠标弹起触发<br> onmousedown: 鼠标按下触发</p><h4 id="事件高级导读"><a class="markdownIt-Anchor" href="#事件高级导读">#</a> 事件高级导读</h4><h5 id="注册事件"><a class="markdownIt-Anchor" href="#注册事件">#</a> 注册事件</h5><p>传统方式和方法监听注册方式<br><a href="https://imgtu.com/i/IGd6cF"><img src="https://z3.ax1x.com/2021/11/08/IGd6cF.png" alt="IGd6cF.png"></a></p><blockquote><pre><code>eventTarget.addEventListener(type,listener[,useCapture])</code></pre></blockquote><p><a href="https://imgtu.com/i/IGsktA"><img src="https://z3.ax1x.com/2021/11/08/IGsktA.png" alt="IGsktA.png"></a><br> 里面的事件类型是字符串 必定加引号 不带 on<br> 同一个元素 同一个事件可以添加多个侦听器 (事件处理程序)</p><p>AttachEvent 事件监听方式 (<strong>不提倡仅供了解</strong>)<br><a href="https://imgtu.com/i/IGsVpt"><img src="https://z3.ax1x.com/2021/11/08/IGsVpt.png" alt="IGsVpt.png"></a></p><p>注册事件兼容性解决方法<br><a href="https://imgtu.com/i/IGdW7R"><img src="https://z3.ax1x.com/2021/11/08/IGdW7R.png" alt="IGdW7R.png"></a></p><h5 id="删除事件解绑事件"><a class="markdownIt-Anchor" href="#删除事件解绑事件">#</a> 删除事件 (解绑事件)</h5><p>1. 传统法式:element.onclick = null<br>2. 方法监听事件: eventTarget.removeEventListener (type,listener [,useCapture])<br> 删除事件兼容性解决方案:<br><a href="https://imgtu.com/i/IGd4tx"><img src="https://z3.ax1x.com/2021/11/08/IGd4tx.png" alt="IGd4tx.png"></a></p><h5 id="dom事件流"><a class="markdownIt-Anchor" href="#dom事件流">#</a> DOM 事件流</h5><p><a href="https://imgtu.com/i/IGsunS"><img src="https://z3.ax1x.com/2021/11/08/IGsunS.png" alt="IGsunS.png"></a></p><p>注意事项<br><a href="https://imgtu.com/i/IGsGpq"><img src="https://z3.ax1x.com/2021/11/08/IGsGpq.png" alt="IGsGpq.png"></a><br> 捕获阶段<br><a href="https://imgtu.com/i/IGs3hn"><img src="https://z3.ax1x.com/2021/11/08/IGs3hn.png" alt="IGs3hn.png"></a><br> 冒泡阶段<br><a href="https://imgtu.com/i/IGs1ts"><img src="https://z3.ax1x.com/2021/11/08/IGs1ts.png" alt="IGs1ts.png"></a></p><h4 id="事件对象"><a class="markdownIt-Anchor" href="#事件对象">#</a> 事件对象</h4><p><a href="https://imgtu.com/i/IGdqnH"><img src="https://z3.ax1x.com/2021/11/08/IGdqnH.png" alt="IGdqnH.png"></a></p><h5 id="事件对象的常见属性和方法"><a class="markdownIt-Anchor" href="#事件对象的常见属性和方法">#</a> 事件对象的常见属性和方法</h5><p><a href="https://imgtu.com/i/IGdLBd"><img src="https://z3.ax1x.com/2021/11/08/IGdLBd.png" alt="IGdLBd.png"></a><br>e.target 返回的是触发事件的对象 而 this 返回的是绑定事件的对象，currentTarget 和 this 一样返回的是绑定事件的对象 ie678 不认识 currentTarget<br>e.type: 返回事件类型 例如 click,mouseover</p><p>组织默认事件 让链接不跳转 或者让提交按钮不提交 e.preventDefault ();<br><a href="https://imgtu.com/i/IGdx4P"><img src="https://z3.ax1x.com/2021/11/08/IGdx4P.png" alt="IGdx4P.png"></a></p><p>组织事件冒泡 e.stopPropagation ()<br> 兼容性解决方法<br><a href="https://imgtu.com/i/IGdvNt"><img src="https://z3.ax1x.com/2021/11/08/IGdvNt.png" alt="IGdvNt.png"></a></p><h5 id="事件委托"><a class="markdownIt-Anchor" href="#事件委托">#</a> 事件委托</h5><p>原理：给父节点添加侦听器，利用事件冒泡影响每一个子节点</p><h5 id="常用的鼠标事件"><a class="markdownIt-Anchor" href="#常用的鼠标事件">#</a> 常用的鼠标事件</h5><p><a href="https://imgtu.com/i/IGw9gS"><img src="https://z3.ax1x.com/2021/11/08/IGw9gS.png" alt="IGw9gS.png"></a><br> 禁止鼠标右键菜单:contextmenu 主要控制应该在何时显示上下文菜单，主要用于程序员取消默认的上下文菜单<br>禁止鼠标选中:selectstart</p><blockquote><pre><code>   document.addEventListener('contextmenu', function (e) {       e.preventDefault();   })   document.addEventListener('selectstart', function (e) {       e.preventDefault();   })</code></pre></blockquote><h5 id="鼠标事件对象"><a class="markdownIt-Anchor" href="#鼠标事件对象">#</a> 鼠标事件对象</h5><p>Mouseevent 鼠标事件对象<br> keyboard 键盘事件对象<br><a href="https://imgtu.com/i/IGwCjg"><img src="https://z3.ax1x.com/2021/11/08/IGwCjg.png" alt="IGwCjg.png"></a><br>client 以可视区为主 跟屏幕滚动没有关系<br> page 相对于文档页面的 X 和 Y 坐标<br> screen 鼠标相当于电脑屏幕的 X 和 Y 坐标 (当浏览器缩小或者放大时会变化)<br> mousemove 鼠标移动事件</p><h5 id="键盘事件对象"><a class="markdownIt-Anchor" href="#键盘事件对象">#</a> 键盘事件对象</h5><p><a href="https://imgtu.com/i/IGwkHs"><img src="https://z3.ax1x.com/2021/11/08/IGwkHs.png" alt="IGwkHs.png"></a><br> 三个事件的执行顺序是 keydown keypress keyup</p><p>KeyCode 返回键盘按键的 ASCII 的值<br> keyup 和 keydown 事件不区分字母大小写 a 和 A 得到的就是 65<br>keypress 区分字母大小写</p><h3 id="bom浏览器对象模型"><a class="markdownIt-Anchor" href="#bom浏览器对象模型">#</a> BOM 浏览器对象模型</h3><h4 id="bom概述"><a class="markdownIt-Anchor" href="#bom概述">#</a> BOM 概述</h4><p>BOM: 浏览器对象模型<br><img src="js_img/BOM%E6%A6%82%E8%BF%B0.png" alt="photo"><br>BOM 的构成<br><img src="js_img/BOM%E7%9A%84%E6%9E%84%E6%88%90.png" alt="photo"></p><h4 id="浏览器顶级对象window"><a class="markdownIt-Anchor" href="#浏览器顶级对象window">#</a> 浏览器顶级对象 window</h4><p><img src="js_img/window%E5%AF%B9%E8%B1%A1.png" alt="photo"></p><h5 id="窗口加载事件"><a class="markdownIt-Anchor" href="#窗口加载事件">#</a> 窗口加载事件</h5><p>window.onload 窗口加载事件，当文档内容完全加载完成后会触发该事件 (包括图像 css 脚本等等)<br> 注意:<br>1. 有了 window.onload 我们就可以将 js 写在任何位置 onload 是等页面文档加载完成后 最后加载的东西<br> 2.window,onload 传统注册事件只能写一次，如果有多个，会以最后一个 window.onload 为准<br> 3. 如果使用 AddEventListener 则没有限制<br> document.addEventListener (‘DOMContentLoaded’,function (){})<br> 仅当 DOM 加载完成就开始触发，不包括样式表，图片，flash 等等<br>后一个加载更快，如果是图片较多的网站等 会因为图片刷新过快 如果使用第一个方式 有可能无法加载出 js 文件 而使用后一个方式 则在 DOM 加载完成后 就加载 js</p><h5 id="调整窗口大小事件"><a class="markdownIt-Anchor" href="#调整窗口大小事件">#</a> 调整窗口大小事件</h5><p><a href="https://imgtu.com/i/IGwEEn"><img src="https://z3.ax1x.com/2021/11/08/IGwEEn.png" alt="IGwEEn.png"></a></p><h4 id="定时器"><a class="markdownIt-Anchor" href="#定时器">#</a> 定时器</h4><h5 id="settimeout定时器"><a class="markdownIt-Anchor" href="#settimeout定时器">#</a> setTimeout () 定时器</h5><p>window.setTimeout (调用函数，[延迟的毫秒数]);<br> 在定时器到期后执行函数<br> 1.window 在调用的时候可以省略<br> 2. 时间单位是毫秒，可以省略 如果省略默认为 0<br>3. 页面中可能有很多的定时器 我们经常给定时器起一个标识符</p><p>callback 回调函数<br><img src="js_img/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.png" alt="photo"></p><h6 id="停止settimeout定时器"><a class="markdownIt-Anchor" href="#停止settimeout定时器">#</a> 停止 setTimeout () 定时器</h6><p>window.clearaTimeout (定时器名字)</p><h5 id="setinterval定时器"><a class="markdownIt-Anchor" href="#setinterval定时器">#</a> setInterval () 定时器</h5><p><img src="js_img/setInterval()%E5%AE%9A%E6%97%B6%E5%99%A8.png" alt="photo"></p><p>区别:setTimeout 只调用一次回调函数<br> setInterval 会一直调用函数</p><h4 id="this指向问题"><a class="markdownIt-Anchor" href="#this指向问题">#</a> this 指向问题</h4><p>1. 全局作用域或者普通函数中 this 指向全局对象 window (定时器里面的 this 指向 window)<br> 2. 方法调用中谁调用 this 指向谁<br> 3. 构造函数中 this 可以指向构造函数</p><h4 id="js的执行队列"><a class="markdownIt-Anchor" href="#js的执行队列">#</a> js 的执行队列</h4><p>js 是单线程的 同一个时间只能做一件事<br>为了解决这个问题，利用多核 CPU 的计算能力，HTML5 允许 js 脚本创建多个线程，于是 js 中出现了同步和异步<br><a href="https://imgtu.com/i/IGwugU"><img src="https://z3.ax1x.com/2021/11/08/IGwugU.png" alt="IGwugU.png"></a></p><h5 id="js执行机制"><a class="markdownIt-Anchor" href="#js执行机制">#</a> js 执行机制</h5><p><a href="https://imgtu.com/i/IGw1b9"><img src="https://z3.ax1x.com/2021/11/08/IGw1b9.png" alt="IGw1b9.png"></a><br><a href="https://imgtu.com/i/IGwQu4"><img src="https://z3.ax1x.com/2021/11/08/IGwQu4.png" alt="IGwQu4.png"></a><br><img src="js_img/js%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6.png" alt="photo"><br><img src="js_img/js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.png" alt="photo"></p><h4 id="location对象"><a class="markdownIt-Anchor" href="#location对象">#</a> location 对象</h4><p><img src="js_img/location%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B1%9E%E6%80%A7.png" alt="photo"><br><img src="js_img/url.png" alt="photo"></p><h5 id="location对象方法"><a class="markdownIt-Anchor" href="#location对象方法">#</a> location 对象方法</h5><p><a href="https://imgtu.com/i/IGwJ4x"><img src="https://z3.ax1x.com/2021/11/08/IGwJ4x.png" alt="IGwJ4x.png"></a></p><h4 id="navigator对象"><a class="markdownIt-Anchor" href="#navigator对象">#</a> navigator 对象</h4><p>包含浏览器的信息 我们最常用的属性是 userAgent</p><p><img src="js_img/navigator.png" alt="photo"></p><h4 id="history对象"><a class="markdownIt-Anchor" href="#history对象">#</a> history 对象</h4><p><img src="js_img/history%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95.png" alt="photo"></p><h3 id="pc端网页特效"><a class="markdownIt-Anchor" href="#pc端网页特效">#</a> PC 端网页特效</h3><h4 id="元素偏移量offset系列"><a class="markdownIt-Anchor" href="#元素偏移量offset系列">#</a> 元素偏移量 offset 系列</h4><p>可以动态地获得元素的位移，大小<br><img src="js_img/offset%E7%B3%BB%E5%88%97.png" alt="photo"><br><a href="https://imgtu.com/i/IGw0DH"><img src="https://z3.ax1x.com/2021/11/08/IGw0DH.png" alt="IGw0DH.png"></a></p><h5 id="offset和style的区别"><a class="markdownIt-Anchor" href="#offset和style的区别">#</a> offset 和 style 的区别</h5><p><img src="js_img/offset%E5%92%8Cstyle%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="photo"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
