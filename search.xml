<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数学建模</title>
      <link href="/2021/11/20/shu-xue-jian-mo/"/>
      <url>/2021/11/20/shu-xue-jian-mo/</url>
      
        <content type="html"><![CDATA[<h1 id="数学建模"><a class="markdownIt-Anchor" href="#数学建模">#</a> 数学建模</h1><h2 id="the-article-made-bu-yogmas-also-sam"><a class="markdownIt-Anchor" href="#the-article-made-bu-yogmas-also-sam">#</a> The article made bu YogMas also sam</h2><h3 id="搜索技巧你真的会百度吗"><a class="markdownIt-Anchor" href="#搜索技巧你真的会百度吗">#</a> 搜索技巧 (你真的会百度吗)</h3><p>完全匹配搜索：查询词的外边加上双引号 ""</p><blockquote><pre><code>"线性规划"</code></pre></blockquote><p>标题必含关键词：查询词前加上 intitle:</p><blockquote><pre><code>intitle: "线性规划"</code></pre></blockquote><p>搜索文档：查询词后面空格再输入 filetype: 文件格式 (doc/pdf/xls/ 等等)</p><blockquote><pre><code>eg:   线性规划 filetype:pdf</code></pre></blockquote><p>去掉不想要的：查询词后面加空格后加减号和关键字</p><blockquote><pre><code>eg:  显示规划 filetype:pdf -百度文库</code></pre></blockquote><h3 id="查文献技巧"><a class="markdownIt-Anchor" href="#查文献技巧">#</a> 查文献技巧</h3><p>知网：硕博论文会对研究的问题有详细的背景和基础知识介绍 可以帮助我们快速理解题目<br>过多的话可以通过被引 选择被引用率最高的论文<br>高级检索:</p><ul><li><p>+ 和 - 可以自定义增加和减少检索字段</p></li><li><p>OR AND 增设关键词和主题</p></li><li><p>主题设置称为精确</p></li><li><p>关键词设置称为模糊 (精确可能得到的结果过少)</p></li><li><p>检索时间 (出版时间)</p></li></ul><p>推荐网站</p><ol><li><p>谷歌学术镜像</p></li><li><p>Open Access Library</p></li></ol><p><strong>数模国赛 没必要查外文文献</strong></p><h3 id="查数据"><a class="markdownIt-Anchor" href="#查数据">#</a> 查数据</h3><ul><li>优先在知网，谷歌学术等平台搜索</li><li>国家统计局 (比较全面的资料)  <a href="http://data.stats.gov.cn">data.stats.gov.cn</a></li><li>awesome-public-datasets  (来自 guthub 上的项目) <a href="http://github.com/awesomedata/awesome-public-datasets">github.com/awesomedata/awesome-public-datasets</a></li><li>EPSDATA 平台 (付费平台，可以申请 7 天试用 数据已经经过处理) <a href="http://www.epsnet.com.cn">www.epsnet.com.cn</a></li></ul><h3 id="数据预处理"><a class="markdownIt-Anchor" href="#数据预处理">#</a> 数据预处理</h3><h4 id="缺失值"><a class="markdownIt-Anchor" href="#缺失值">#</a> 缺失值</h4><p>比赛提供的数据有些是缺失的<br>缺失太多：直接把该项指标删除<br>最简单处理：均值 众数插补</p><ul><li>定量数据 例如一群人的身高 年龄等 用整体的均值来补缺失</li><li>定性数据 例如关于一群人的 性别 文化程度 用出现次数最多的值来补缺失</li><li>适用于对个体精度要求不大的数据</li></ul><p>Newton 插值法</p><ul><li>根据固定公式 构造近似函数 补上缺失值</li><li>缺点：区间边缘处的不稳定震荡 不适合对倒数有要求的题目</li><li>适用于只追求函数值精准二不关心变化的数据</li></ul><p>样条插值法</p><ul><li>用分段光滑的曲线去插值 光滑不仅连续 还要有连续的曲率</li><li>适用于零件加工 机器人轨迹等精度要求高 没有突变的数据</li></ul><h4 id="异常值"><a class="markdownIt-Anchor" href="#异常值">#</a> 异常值</h4><p>样本中明显和其他数值差异很大的数据</p><ol><li>正态分布原则</li></ol><ul><li>计算均值和标准差 判断数据值知否在区间范围内 如果不在就是异常值 4</li><li>试用题目 总体符合正态分布</li></ul><ol start="2"><li>画箱型图</li></ol><ul><li>把数据从小打大排序 下四分位数 Q1 是排第 25% 的数值 上四分位数 Q3 是排第 75% 的数值</li><li>四分位距 IQR = Q3 - Q1</li><li>设置合理区间 在区间外面的就是异常值</li><li>一般而言设置 [Q1-1.5<em>IQR,Q3+1.5</em>IQR] 内为正常值</li><li>普遍适用</li></ul><p>找到异常值后面 处理方法和处理缺失值相同</p><h3 id="建模全过程"><a class="markdownIt-Anchor" href="#建模全过程">#</a> 建模全过程</h3><h4 id="什么是模型"><a class="markdownIt-Anchor" href="#什么是模型">#</a> 什么是模型</h4><ol><li>什么是模型</li></ol><ul><li>理论基础</li><li>推导过程</li><li>最终结论</li><li>文字描述 数学公式 图像表格展现出来</li></ul><ol start="2"><li><p>比赛开始后先查文献 一切以现有的他人成果为基础 不需要看懂原理 把论文编写出来就行</p></li><li><p>整篇论文 思路，模型等都是从参考文献和书籍搬过来的</p></li></ol><h4 id="建模过程"><a class="markdownIt-Anchor" href="#建模过程">#</a> 建模过程</h4><h5 id="数模论文"><a class="markdownIt-Anchor" href="#数模论文">#</a> 数模论文</h5><p>一篇完整的数模论文 包括摘<strong>摘要 (最重要)</strong>, 问题重述，模型假设和符号说明，模型建立与求解 (最长), 模型的优缺点和改进方法 参考文献和附录</p><ul><li>摘要：读者看完摘要 就知道论文研究的问题 方法 结果 以及每一部分的大致步骤 (第一印象)</li><li>问题充数：简述一遍 (不重要) 不要复制粘贴 避免查重</li><li>模型假设和符号说明：好的假设会事半功倍 (比如假设忽略某个数据的影响), 符号说明将论文中定义的重要符号列出表格说明就可以</li></ul><h5 id="模型建立"><a class="markdownIt-Anchor" href="#模型建立">#</a> 模型建立</h5><p>一组公式和对公式中每个变量的解释就是一个模型<br>先查阅资料 看着资料 用自己的话复述一个简单地模型 再根据题目中的约束条件去一步步修改模型 把题目中的变量带入模型中去</p><p><a href="https://imgtu.com/i/IOtUpt"><img src="https://z3.ax1x.com/2021/11/20/IOtUpt.png" alt="IOtUpt.png"></a></p><h5 id="不同小问"><a class="markdownIt-Anchor" href="#不同小问">#</a> 不同小问</h5><p>并不是针对题目的每一问都要建立一个模型<br>如果每小问之间具有相似性 仅仅是增加了约束条件的话 完全可以全文建立一个模型 再针对每一小问进行模型改进</p><h5 id="模型的优缺点和改进方法"><a class="markdownIt-Anchor" href="#模型的优缺点和改进方法">#</a> 模型的优缺点和改进方法</h5><p>不是必须的 可以简单分析下前文模型的优缺点 若没有改进方法也可以不写<br>综合查到的文献 分析模型常用在那种问题 又和本文所求解的问题有什么区别</p><h5 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献">#</a> 参考文献</h5><p>格式一定要规范<br>知网检索结果右侧有引用按钮 打开后赋值即可</p><h5 id="附录"><a class="markdownIt-Anchor" href="#附录">#</a> 附录</h5><p>附录里要写出正文求解时用到的代码<br>一定不要把网上收到的代码直接复制粘贴<br>把查到的代码变量名缓一缓就不会被查重</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电科icoding答案</title>
      <link href="/2021/11/18/dian-ke-icoding/"/>
      <url>/2021/11/18/dian-ke-icoding/</url>
      
        <content type="html"><![CDATA[<h1 id="c语言-icoding答案"><a class="markdownIt-Anchor" href="#c语言-icoding答案">#</a> C 语言 - icoding 答案</h1><h2 id="the-article-made-by-yogmas"><a class="markdownIt-Anchor" href="#the-article-made-by-yogmas">#</a> The article made by YogMas</h2><h3 id="实验一"><a class="markdownIt-Anchor" href="#实验一">#</a> 实验一</h3><h4 id="2-4计算税金"><a class="markdownIt-Anchor" href="#2-4计算税金">#</a> 2-4：计算税金</h4><p>编写⼀个程序，要求⽤户输⼊⼀个美元数量，然后显示出增加 5% 税率后的相应⾦额。</p><p>Enter an amount: 100.00<br>with tax added: $105.00</p><p>输⼊的⾦额为⼤于 0 的两位数浮点数</p><blockquote><pre><code>#include &lt;stdio.h&gt;int main(void){    float amount,final;    printf("Enter an amount:");    scanf("%f",&amp;amount);    // 获取用户的输入的的输入输入输入    final = amount * 1.05;    printf("get the final money:$%.2f",final);    return 0;    }</code></pre></blockquote><h4 id="2-7计算账单"><a class="markdownIt-Anchor" href="#2-7计算账单">#</a> 2-7：计算账单</h4><p>编写⼀个程序，要求⽤户输出⼀个美元数量，然后显示出如何⽤最少 20 美元、10 美元、5 美元和 1 美元来付款。</p><p>Enter a dollar amount: 93<br>$20 bills: 4<br>$10 bills: 1<br>$5 bills: 0<br>$1 bills: 3</p><blockquote><pre><code>#include&lt;stdio.h&gt;int main(void){    int one,two,three,four,five;    printf("enter an amount:  \n");        scanf("%d",&amp;one);    two = one / 20;    three = (one - two*20)/10;    four = (one-two*20-three*10)/5;    five = (one-two*20-three*10-four*5);    printf("this is $20 bills:%d,$10 bills:%d,$5bills %d,$1 bills %d",two,three,four,five);    return 0;}</code></pre></blockquote><h4 id="2-8还贷计算"><a class="markdownIt-Anchor" href="#2-8还贷计算">#</a> 2-8：还贷计算</h4><p>编程计算第⼀、第⼆、第三个⽉还贷后剩余的贷款⾦额。</p><p>Enter amout of loan: 20000.00<br>Enter interest rate: 6.0<br>Enter monthly payment: 386.66</p><p>Balance remaining after first payment: $19713.34<br>Balance remaining after second payment: $19425.25<br>Balance remaining after third payment: $19135.71</p><p>提示：每个月的贷款余额减去还款金额后，还需要加上贷款余额与月利率的乘积。月利率的计算方法是把用户输入的利率转换成百分数再除以 12。</p><blockquote><pre><code>#include &lt;stdio.h&gt;int main(void){    float loan,rate1,rate2,payment,one,two,three;    printf("please enter ur loan: \n");    scanf("%f",&amp;loan);    printf("please enter ur rate: \n");    scanf("%f",&amp;rate1);    printf("please enter ur monthly payment: \n");    scanf("%f",&amp;payment);    rate2=rate1*0.01/12;    one=(loan-payment)+loan*rate2;    two=(one-payment)+one*rate2;    three=(two-payment)+two*rate2;    printf("this is ur Balance remaining after first payment:%.2f,second:%.2f,third:%.2f",one,two,three);    return 0;}</code></pre></blockquote><h4 id="3-1日期格式转化"><a class="markdownIt-Anchor" href="#3-1日期格式转化">#</a> 3-1：⽇期格式转化</h4><p>编写⼀个程序，以⽉ / ⽇ / 年（即 mm/dd/yy）的格式接受⽤户录⼊的⽇期信息，并以年⽉⽇（即 yyyymmdd）的格式将其显示出来。</p><p>Enter a date (mm/dd/yyyy): 2/17/2011<br>You entered the date 20110217</p><blockquote><pre><code>#include&lt;stdio.h&gt;int main(void){    int year,month,day;        printf("please enter the date: .\n");    scanf("%d/%d/%d",&amp;month,&amp;day,&amp;year);    printf("this is the date:%04d%02d%02d",year,month,day);    return 0;    }</code></pre></blockquote><h4 id="3-6分数加法"><a class="markdownIt-Anchor" href="#3-6分数加法">#</a> 3-6：分数加法</h4><p>修改如下程序（ 3.2 节的 addfrac.c ），使⽤户可以同时输⼊两个分数，中间⽤加号隔开：</p><p>Enter two fractions separated by a plus sign: 5/6+3/4<br>The sum is 38/24</p><blockquote><pre><code>#include &lt;stdio.h&gt;int main(void){    int fenzi1,fenzi2,fenmu1,fenmu2,sum1,sum2;    printf("please enter the  fractions: \n");    scanf("%d/%d+%d/%d",&amp;fenzi1,&amp;fenmu1,&amp;fenzi2,&amp;fenmu2);    sum1=fenzi1*fenmu2+fenzi2*fenmu1;    sum2=fenmu1*fenmu2;    printf("this is the sum:%d/%d",sum1,sum2);    return 0;    }</code></pre></blockquote><h3 id="实验二"><a class="markdownIt-Anchor" href="#实验二">#</a> 实验二</h3><h4 id="5-2-24小时制-12小时制转换"><a class="markdownIt-Anchor" href="#5-2-24小时制-12小时制转换">#</a> 5-2： 24 ⼩时制 - 12 ⼩时制转换</h4><p>编写⼀个程序，要求⽤户输⼊ 24 ⼩时制的时间，将其转换为 12 ⼩时制的格式。</p><p>Enter a 24-hour time: 21:11<br>Equivalent 12-hour time: 9:11 PM</p><p>Enter a 24-hour time: 0:01<br>Equivalent 12-hour time: 12:01 AM</p><p>注意，不要把 12:00 显示为 0:00。</p><blockquote><pre><code>#include &lt;stdio.h&gt;int main(void){    int enter1,enter2,b,c;    printf("please enter the time  \n");    scanf("%d:%d",&amp;enter1,&amp;enter2);    b=enter1-12;    c=enter1+12;    if(12&lt;enter1&amp;&amp;enter1&lt;24) printf("this is ur time:%d:%d PM\n",b,enter2);    if(0&lt;enter1&amp;&amp;enter1&lt;12) printf("this is ur time: %d:%d AM\n",enter1,enter2);    if(enter1==0) printf ("this is ur time: %d:%d AM\n",c,enter2);    if(enter1==12) printf ("this is ur timer :  %d:%d PM\n",enter1,enter2);    return 0 ;            }</code></pre></blockquote><h4 id="5-4-速等级与描述"><a class="markdownIt-Anchor" href="#5-4-速等级与描述">#</a> 5-4： ⻛速等级与描述</h4><p>下⾯是⽤于测量⻛⼒的蒲福⻛⼒等级的简化版，编写⼀个程序，要求⽤户输⼊⻛速（海⾥ / ⼩时），然后显示相应的描述。</p><p>速率（海⾥ / ⼩时）描述<br>⼩于 1Calm（⽆⻛）<br>1~3Light air（轻⻛）<br>4~27Breeze（微⻛）<br>28~47Gale（⼤⻛）<br>48~63Storm（暴⻛）<br>⼤于 63Hurricane（飓⻛）<br>输出范例：Enter a wind speed: 1</p><p>Light air</p><p>Enter a wind speed: 27</p><p>Breeze</p><blockquote><pre><code>#include &lt;stdio.h&gt;int main(void){    int speed;    printf("please enter ur wind speed \n");    scanf("%d",&amp;speed);    if(speed&lt;1) printf("Calm");    if(speed&gt;=1&amp;&amp;speed&lt;=3) printf("Light air");    if(speed&gt;=4&amp;&amp;speed&lt;=27) printf("Breeze");    if(speed&gt;=28&amp;&amp;speed&lt;=47) printf("Gale");    if(speed&gt;=48&amp;&amp;speed&lt;=63) printf("Storm");    if(speed&gt;63) printf("Hurricane");    return 0;}</code></pre></blockquote><h4 id="5-6通用产品代码"><a class="markdownIt-Anchor" href="#5-6通用产品代码">#</a> 5-6：通⽤产品代码</h4><p>修改如下（4.1 节的 upc.c）程序，使其可以检测 UPC 的有效性。在⽤户输⼊ UPC 后，程序将输出 VALID 或 NOT VALID 。</p><p>输出范例：</p><p>Enter the first (single) digit: 0<br>Enter first group of five digits: 13800<br>Enter second group of five digits: 15173<br>Enter the last (single) digit: 5<br>VALID</p><p>Enter the first (single) digit: 0<br>Enter first group of five digits: 51500<br>Enter second group of five digits: 24128<br>Enter the last (single) digit: 7<br>NOT VALID</p><blockquote><pre><code>#include &lt;stdio.h&gt;int main(void){    int d, i1, i2, i3, i4, i5, j1, j2, j3, j4, j5, first_sum, second_sum, total, total2, g;    printf("Enter the first (single) digit: \n");    scanf("%1d", &amp;d);    printf("Enter the first group of five digits: \n");    scanf("%1d%1d%1d%1d%1d", &amp;i1, &amp;i2, &amp;i3, &amp;i4, &amp;i5);    printf("Enter the second group of five digits: \n");    scanf("%1d%1d%1d%1d%1d", &amp;j1, &amp;j2, &amp;j3, &amp;j4, &amp;j5);    printf("please Enter the last (single) digit:   \n ");    scanf("%d", &amp;g);    first_sum = d + i2 + i4 + j1 + j3 + j5;    second_sum = i1 + i3 + i5 + j2 + j4;    total = 3 * first_sum + second_sum;    total2 = 9 - ((total - 1) % 10);    if (g == total2)        printf("VALID \n");    else        printf("NOT VALID  \n");    return 0;}</code></pre></blockquote><h4 id="5-10将百分制转换为等级制"><a class="markdownIt-Anchor" href="#5-10将百分制转换为等级制">#</a> 5-10：将百分制转换为等级制</h4><p>利⽤ switch 语句编写⼀个程序，把⽤数字表示的成绩转化为字⺟表示的等级。</p><p>使⽤下⾯的等级评定规则：A 为 90<sub>100，B 为 80</sub>89，C 为 70<sub>79，D 为 60</sub>69，F 为 0~59。如果成绩⾼于 100 或低于 0 显示出错信息。</p><p>输出范例：<br>Enter numerical grade: 84<br>Letter grade: B</p><p>Enter numerical grade: -1<br>Error, grade must be between 0 and 100.</p><p>提示：把成绩拆分成 2 个数字，然后使⽤ switch 语句判定⼗位上的数字。</p><blockquote><pre><code>#include &lt;stdio.h&gt;int main(void){    int grade1, grade2;    printf("please enter ur numerical grade   \n");    scanf("%d", &amp;grade1);    grade2 = grade1 / 10;    if (-10 &lt; grade1 &amp;&amp; grade1 &lt; 0)        printf("Error, grade must be between 0 and 100.\n");    else        if (100 &lt; grade1 &amp;&amp; grade1 &lt; 110)        printf("Error, grade must be between 0 and 100.\n");    else        switch (grade2)        {        case 10:        case 9:            printf("Letter grade: A \n");            break;        case 8:            printf("Letter grade: B \n");            break;        case 7:            printf("Letter grade: C \n");            break;        case 6:            printf("Letter grade: D \n");            break;        case 5:        case 4:        case 3:        case 2:        case 1:        case 0:            printf("Letter grade: F \n");            break;        default:            printf("Error, grade must be between 0 and 100.\n");        }    return 0;}</code></pre></blockquote><h4 id="6-2最大公约数"><a class="markdownIt-Anchor" href="#6-2最大公约数">#</a> 6-2：最⼤公约数</h4><p>编写程序，要求⽤户输⼊两个整数，然后计算这两个整数的最⼤公约数（GCD, Greatest Common Divisor）。</p><p>输出范例：</p><p>Enter two integers: 12 28<br>Greatest common divisor: 4</p><p>Enter two integers：1 9<br>Greatest common divisor：1</p><p>提示：求最⼤公约数的经典算法 Euclid 算法如下：<br>分别让变量 m 和 n 存储两个整数。如果 n 为 0，那么停⽌操作，m 中的值是 GCD ；否则计算 m 除以 n 的余数，把 n 保存到 m 中，并把余数保存到 n 中；重复上述操作，每次都先判断 n 是否为 0 。</p><blockquote><pre><code>#include &lt;stdio.h&gt;int main(void){    int m, n, s, l;    printf("please Enter two integers:     \n");    scanf("%d %d", &amp;m, &amp;n);    while (n != 0)    {        if (m &gt;= n)        {            s = m % n;            m = n;            n = s;        }        else        {            l = m;            m = n;            n = l;        }    }    printf("GCD=%d", m);    return 0;}</code></pre></blockquote><h4 id="6-4股经纪人的佣金"><a class="markdownIt-Anchor" href="#6-4股经纪人的佣金">#</a> 6-4：股经纪⼈的佣⾦</h4><p>在下列程序（ 5.2 节的 broker.c ）中添加循环，以便⽤户可以输⼊多笔交易并且程序可以计算每次的佣⾦。程序在⽤户输⼊的交易额为 0 时终⽌。</p><p>输出范例：</p><p>Enter value of trade: 30000<br>Commission：$166.00</p><p>Enter value of trade: 20000<br>Commission：$144.00<br>Enter value of trade: 0</p><blockquote><pre><code>#include &lt;stdio.h&gt;int main(void){    float commission, value;    printf("Enter value of trade: ");    scanf("%f", &amp;value);    while (value != 0)    {        if (value &lt; 2500.00f)            commission = 30.00f + .017f * value;        else if (value &lt; 6250.00f)            commission = 56.00f + .0066f * value;        else if (value &lt; 20000.00f)            commission = 76.00f + .0034f * value;        else if (value &lt; 50000.00f)            commission = 100.00f + .0022f * value;        else if (value &lt; 500000.00f)            commission = 155.00f + .0011f * value;        else            commission = 255.00f + .0009f * value;        if (commission &lt; 39.00f)            commission = 39.00f;        printf("Commission: $%.2f\n\n", commission);        printf("Enter value of trade: ");        scanf("%f", &amp;value);    }    return 0;}</code></pre></blockquote><h4 id="6-6偶数平方"><a class="markdownIt-Anchor" href="#6-6偶数平方">#</a> 6-6：偶数平⽅</h4><p>编写程序，提示⽤户输⼊⼀个数 n，然后显示出 1~n 的所有偶数的平⽅值。</p><p>输出范例：<br>Enter a number: 100<br>4<br>16<br>36<br>64<br>100</p><p>Enter a number: 50<br>4<br>16<br>36</p><blockquote><pre><code>#include &lt;stdio.h&gt;int main(void){    int i, a, b;    printf("please enter a number:  \n");    scanf("%d", &amp;i);    for (a = 2; a * a &lt;= i; a = a + 2)    {        b = a * a;        printf("%d \n", b);    }    return 0;}</code></pre></blockquote><h4 id="6-8日历"><a class="markdownIt-Anchor" href="#6-8日历">#</a> 6-8：日历</h4><p>编写程序显示单⽉的⽇历。⽤户指定这个⽉的天数和该⽉起始⽇是星期⼏。</p><p>输出范例：</p><p>Enter number of days in month: 31</p><p>Enter starting day of the week(1=Sun, 7=Sat): 3</p><p>日一二三四五六<br> 12 3 4 5<br>6 7 8 9101112<br>13141516171819<br>20212223242526<br>2728293031</p><blockquote><pre><code>#include &lt;stdio.h&gt;int main(void){    int a, b, c, i, d;    printf("Enter number of days in month: \n");    scanf("%d", &amp;a);    printf("Enter starting day of the week(1=Sun, 7=Sat) \n");    scanf("%d", &amp;b);    printf("Su Mo Tu We Th Fr Sa \n");    for (c = 1; c &lt; b; c++)    {        printf("   ");    }    for (i = 1; i &lt;= a; i++)    {        printf("%2d ", i);        d = (i + b - 1) % 7;        if (d == 0)        {            printf(" \n");        }    }}</code></pre></blockquote><h3 id="实验三"><a class="markdownIt-Anchor" href="#实验三">#</a> 实验三</h3><h4 id="7-4翻译"><a class="markdownIt-Anchor" href="#7-4翻译">#</a> 7-4：翻译</h4><p>编写程序可以把字⺟格式的电话号码翻译成数值格式：</p><p>Enter phone number: CALLATT</p><p>2255288</p><p>如果没有电话在身边，参考这⾥给出的字⺟在键盘上的对应关系：（2=ABC，3=DEF，4=GHI，5=JKL，6=MNO，7=PQRS，8=TUV，9=WXYZ）原始电话号码中的⾮字⺟字符（例如数字或标点符号）保持不变：</p><p>Enter phone number: 1-800-COL-LECT1-800-265-5328</p><p>可以假设任何⽤户输⼊的字⺟都是⼤写字⺟。</p><p>输出范例：</p><p>Enter phone number: 1-DCKS-A2D-OLED</p><p>1-3257-223-6533</p><blockquote><pre><code>#include &lt;stdio.h&gt;int main(void){    char ch;    printf("Enter phone number: \n");    while ((ch = getchar()) != '\n')    {        if (ch == 'A' || ch == 'B' || ch == 'C')        {            printf("2");        }        else if (ch == 'D' || ch == 'E' || ch == 'F')        {            printf("3");        }        else if (ch == 'G' || ch == 'H' || ch == 'I')        {            printf("4");        }        else if (ch == 'J' || ch == 'K' || ch == 'L')        {            printf("5");        }        else if (ch == 'M' || ch == 'N' || ch == 'O')        {            printf("6");        }        else if (ch == 'P' || ch == 'Q' || ch == 'R' || ch == 'S')        {            printf("7");        }        else if (ch == 'T' || ch == 'U' || ch == 'V')        {            printf("8");        }        else if (ch == 'W' || ch == 'X' || ch == 'Y' || ch == 'Z')        {            printf("9");        }        else        {            printf("%c", ch);        }    }    return 0;}</code></pre></blockquote><h4 id="7-12表达式求值"><a class="markdownIt-Anchor" href="#7-12表达式求值">#</a> 7-12：表达式求值</h4><p>编写程序对表达式求值。</p><p>Enter an expression: 1+2.5*3<br>Value of expression: 10.5</p><p>表达式中的操作数是浮点数，运算符是 +、-、* 和 /。表达式从左向右求值（所有运算符的优先级都⼀样）。</p><p>输出范例：</p><p>Enter an expression: 2+3*4-5/2<br>Value of expression: 7.5</p><blockquote><pre><code>#include &lt;stdio.h&gt;int main(void){    float a, b;    char ch;    printf("Enter an expressio: \n");    scanf("%f", &amp;a);    while ((ch = getchar()) != '\n')    {        scanf("%f", &amp;b);        switch (ch)        {        case '+':            a = a + b;            break;        case '-':            a = a - b;            break;        case '*':            a = a * b;            break;        case '/':            a = a / b;            break;        default:            break;        }    }    printf("Value of expression: %f", a);    return 0;}</code></pre></blockquote><h4 id="8-2出现次数"><a class="markdownIt-Anchor" href="#8-2出现次数">#</a> 8-2：出现次数</h4><p>修改如下程序 (8.1 节的 repdigit.c)，使其打印⼀份列表，显示出每个数字在数中出现的次数。</p><p>输出范例：</p><p>Enter a number: 41271092</p><p>Digit:0123456789<br>Occurrences:1220100101</p><blockquote><pre><code>#include &lt;stdio.h&gt;int main(void){    char ch;    int appear[10] = {0};    int a ;    printf("Enter a number: \n");    while ((ch = getchar()) != '\n')    {     a = ch - 48;        appear[a]++;    }    printf("Digit:    0 1 2 3 4 5 6 7 8 9 \n");    printf("Occurrences:%d %d %d %d %d %d %d %d %d %d", appear[0], appear[1], appear[2], appear[3], appear[4], &gt;     appear[5], appear[6], appear[7], appear[8], appear[9]);    return 0;}</code></pre></blockquote><h4 id="8-9随机步法"><a class="markdownIt-Anchor" href="#8-9随机步法">#</a> 8-9 随机步法</h4><p>8-9：随机步法（Random Walk）</p><p>编写程序，⽣成⼀种贯穿 10×10 字符数组（初始时全为字符’.’）的 “随机步法”。程序必须随机地从⼀个元素 “⾛到” 另⼀个元素，每次都向上、向下、向左或向右移动⼀个元素位置。已访问过的元素按访问顺序⽤字⺟ A 到 Z 进⾏标记。</p><p>下⾯是⼀个输出示例：</p><p>A.........<br>BCD.......<br>.FE.......<br>HG........<br>I.........<br>J.......Z.<br>K..RSTUVY.<br>LMPQ...WX.<br>.NO.......<br> 利⽤ srand 函数和 rand 函数（⻅程序 deal.c）产⽣随机数，然后查看次数除以 4 的余数。余数⼀共有 4 种可能的值（0、1、2 和 3），指示下⼀次移动的 4 种可能⽅向。在执⾏移动之前，需要检查两项内容：⼀是不能⾛到数组外⾯，⼆是不能⾛到已有字⺟标记的位置。只要⼀个条件不满⾜，就得尝试换⼀个⽅向移动。如果 4 个⽅向都堵住了，程序就必须终⽌了。下⾯是提前结束的⼀个示例:</p><p>ABGHI.....<br>.CFOJK....<br>.DENML....<br>..........<br>..........<br>..........<br>..........<br>..........<br>..........<br> 因为 Y 的 4 个⽅向都堵住了，所以没有地⽅可以放置下⼀步的 Z 了。</p><blockquote><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;int main(void){    char arr[10][10] = {        //声明数组        {'.', '.', '.', '.', '.', '.', '.', '.', '.', '.'},        {'.', '.', '.', '.', '.', '.', '.', '.', '.', '.'},        {'.', '.', '.', '.', '.', '.', '.', '.', '.', '.'},        {'.', '.', '.', '.', '.', '.', '.', '.', '.', '.'},        {'.', '.', '.', '.', '.', '.', '.', '.', '.', '.'},        {'.', '.', '.', '.', '.', '.', '.', '.', '.', '.'},        {'.', '.', '.', '.', '.', '.', '.', '.', '.', '.'},        {'.', '.', '.', '.', '.', '.', '.', '.', '.', '.'},        {'.', '.', '.', '.', '.', '.', '.', '.', '.', '.'},        {'.', '.', '.', '.', '.', '.', '.', '.', '.', '.'},    };    int row = 0;    int line = 0;    int j = 0; //测试用防止死循环    char ch = 'A';    srand((unsigned)time(NULL));    arr[0][0] = ch;    do    {        j++; //测试用防止死循环 因为之前出现了死循环        int fate = rand() % 4; //获得0到4的随机数        ch++;                  //先增如果不符合后面再减        switch (fate)          //根据随机数的大小来确定往哪个方向走        {        case 1: //向右            row++;            if (0 &lt;= row &amp;&amp; row &lt;= 9 &amp;&amp; arr[row][line] == '.') //判别向右右边不是边界并且右边不是已经走过的地点了            {                arr[row][line] = ch; //判定成功 走向右边 终止switch循环                break;            }            else            {                row--; //判别失败 ch返回原值 row返回原值 退出swtich 等待进行下一次while循环                ch--;                break;            }        case 2: //向下            line++;            if (0 &lt;= line &amp;&amp; line &lt;= 9 &amp;&amp; arr[row][line] == '.') //判别向下不是边界并且下边不是已经走过的地方            {                arr[row][line] = ch; //判定成功 走向下边 终止switch循环                break;            }            else            {                line--; //判别失败 ch返回原值 line返回原值 退出swtich 等待进行下一次while循环                ch--;                break;            }        case 3: //向左            row--;            if (0 &lt;= row &amp;&amp; row &lt;= 9 &amp;&amp; arr[row][line] == '.') //判别向左不是边界并且下边不是已经走过的地方            {                arr[row][line] = ch; //判定成功 走向左边 终止switch循环                break;            }            else            {                row++; //判别失败 ch返回原值 row返回原值 退出swtich 等待进行下一次while循环                ch--;                break;            }        default:            line--;                                              //向上            if (0 &lt;= line &amp;&amp; line &lt;= 9 &amp;&amp; arr[row][line] == '.') //判别向上不是边界并且下边不是已经走过的地方            {                arr[row][line] = ch; //判定成功 走向上边 终止switch循环                break;            }            else            {                line++; //判别失败 ch返回原值 line返回原值 退出swtich 等待进行下一次while循环                ch--;                break;            }        }    } while (65 &lt;= ch &amp;&amp; ch &lt; 90 &amp;&amp; (arr[row + 1][line] == '.' || arr[row - 1][line] == '.' || arr[row][line + 1] &gt;     == '.' || arr[row][line - 1] == '.') &amp;&amp; j &lt; 100); //while循环判定 CH在A到Z之内 并且上下左右没有都被堵住    for (int k = 0; k &lt; 10; k+&gt;     +)                                                                                                              &gt;                           //嵌套for循环打印二维数组    {        printf("\n");        for (int i = 0; i &lt; 10; i++)        {            printf("%c", arr[i][k]);        }    }    return 0;}</code></pre></blockquote><h4 id="8-15加密"><a class="markdownIt-Anchor" href="#8-15加密">#</a> 8-15 加密</h4><p>8-15：加密（Encryption）</p><p>已知的最古⽼的⼀种加密技术是凯撒加密（得名于 Julius caesar）。该⽅法把⼀条消息中的每个字⺟⽤字⺟表中固定距离之后的那个字⺟来替代。（如果越过了字⺟ Z，会绕回到字⺟表的起始位置。例如，如果每个字⺟都⽤字⺟表中两个位置之后的字⺟代替，那么 Y 就被替换为 A，Z 就被替换为 B。）</p><p>编写程序⽤凯撒加密⽅法对消息进⾏加密。⽤户输⼊待加密的消息和移位计数（字⺟移动的位置数⽬）：<br>Enter message to be encrypted: Go ahead, make my day.<br>Enter shift amount (1-25): 3<br>Encrypted message: Jr dkhdg, pdnh pb gdb.</p><p>注意，当⽤户输⼊ 26 与移位计数的差值时，程序可以对消息进⾏解密:</p><p>Enter message to be encrypted: Jr dkhdg, pdnh pb gdb.<br>Enter shift amount (1-25): 23<br>Encrypted message: Go ahead, make my day</p><p>不是字⺟的那些字符不要改动。此外，加密时不要改变字⺟的⼤⼩写。</p><p>输出范例：</p><p>Enter message to be encrypted: Hello, world!<br>Enter shift amount (1-25): 3<br>Encrypted message: Khoor, zruog!</p><p>Enter message to be encrypted: Khoor, zruog!<br>Enter shift amount (1-25): 23<br>Encrypted message: Hello, world!</p><blockquote><pre><code>#include &lt;stdio.h&gt;int main(void){    int a = 0;    int x;    char ch;    char basic[100] = {0};    printf("Enter message to be encrypted: \n");    while ((ch = getchar()) != '\n')    {        basic[a] = ch;        a++;    }    printf("Enter shift amount (1-25)");    scanf("%d", &amp;x);    printf("Encrypted message: ");    for (int i = 0; i &lt; (sizeof(basic) / sizeof(basic[0])); i++)    {        if ((64 &lt; basic[i]) &amp;&amp; (basic[i] &lt; 91))        {            basic[i] = basic[i] + x - 26;            if (basic[i] &lt;= 64)            {                basic[i] = basic[i] + 26;            }            printf("%c", basic[i]);        }        else if ((96 &lt; basic[i]) &amp;&amp; (basic[i] &lt; 123))        {            basic[i] = basic[i] + x - 26;            if (basic[i] &lt;= 96)            {                basic[i] = basic[i] + 26;            }            printf("%c", basic[i]);        }        else if (basic[i] == 48)            ;        else            printf("%c", basic[i]);    }    return 0;}</code></pre></blockquote><p>12-01：逆序（Reversal）</p><p>编写程序读一条消息，然后逆序打印出这条消息。</p><p>输出范例：</p><p>Enter a message: Don’t get mad, get even.<br>Reversal is: .neve teg ,dam teg t’noD</p><p>Enter a message: Hello, world!<br>Reversal is: !dlrow ,olleH</p><p>提示：⼀次读取消息中的⼀个字符（⽤ getchar 函数），并且把这些字符存储在数组中，当数组写满或者读到字符 ‘\n’ 时停⽌读⼊。</p><blockquote><pre><code>#include &lt;stdio.h&gt;int main(void){    char ch;    int i = 0;    char Reversal[100] = {'%'};    for (int j = 0; j &lt; 100; j++)    {        Reversal[j] = '%';    }    printf("Enter a message: \n");    while ((ch = getchar()) != '\n')    {        Reversal[i] = ch;        i++;    }    for (int k = 99; k &gt;= 0; k--)    {        if (Reversal[k] != '%')        {            printf("%c", Reversal[k]);        }        else            ;    }    return 0;}</code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> 答案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> icoding答案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言</title>
      <link href="/2021/11/06/c-yu-yan/"/>
      <url>/2021/11/06/c-yu-yan/</url>
      
        <content type="html"><![CDATA[<h1 id="c语言"><a class="markdownIt-Anchor" href="#c语言">#</a> C 语言</h1><!-- The Article Made by YogMas --><h2 id="the-article-made-by-yogmas"><a class="markdownIt-Anchor" href="#the-article-made-by-yogmas">#</a> The Article Made by YogMas</h2><p>推荐用书: C Primer Plus (本文章绝大部分内容来自于关于此书的学习过程中记录 还有部分来自于 C 语言程序设计第二版 以及 UESTC MOOC)</p><h3 id="c语言的执行过程"><a class="markdownIt-Anchor" href="#c语言的执行过程">#</a> C 语言的执行过程</h3><p>1. 预处理：可以给程序添加内容也可以修改程序 (例如: #include&lt;stdio.h&gt; 就会在预处理中运用 stdio.h 中的内容对源代码进行处理)<br> 2. 编译：将预处理过的语言转变为机器指令.<br>3. 链接：把编译器产生的目标代码和所需的其他附加代码整合到一起，产生最终完全可执行的程序.<br>(这三个过程是自动实现的)</p><h3 id="c语言开始"><a class="markdownIt-Anchor" href="#c语言开始">#</a> C 语言开始</h3><h4 id="基本结构"><a class="markdownIt-Anchor" href="#基本结构">#</a> 基本结构</h4><blockquote><p>指令<br> int main (void)<br>{<br>语句<br>}</p></blockquote><h4 id="指令"><a class="markdownIt-Anchor" href="#指令">#</a> 指令</h4><p>例如 #include &lt;stdio.h&gt; 这条指令说明在编译前将 &lt; stdio.h &gt; 中的信息包含到程序中</p><h4 id="函数"><a class="markdownIt-Anchor" href="#函数">#</a> 函数</h4><p>函数分为两类，一类是程序员写的函数，一类是作为 C 语言实现的一部分提供的函数，我们把后者称为库函数。</p><h4 id="语句"><a class="markdownIt-Anchor" href="#语句">#</a> 语句</h4><p>一种是调用语句 例如 printf (""); 就是调用打印函数，将内容打印在屏幕上</p><p>一种是返回语句<br><strong> C 语言的每条语句都要以；结尾</strong></p><h4 id="注释"><a class="markdownIt-Anchor" href="#注释">#</a> 注释</h4><blockquote><pre><code>/*     */ </code></pre></blockquote><p>注释中的内容不会计入到程序中，只是方便程序员观看理解内容</p><p>“盒子形状” 注释</p><blockquote><pre><code>    /*************************    *                        *    *                        *    *************************/</code></pre></blockquote><p>如此可以方便程序员更好地观察到注释</p><p>C99 提供了另一种注释的方法</p><blockquote><pre><code>// XXXXXXXXX  双斜杠注释   这种风格的注释会在行末自动终止，注释第二行还应该添加双斜杠</code></pre></blockquote><p>优点：多行 // 可以让注释更加醒目，由于每一行都必须添加 // 可以有效防止注释吞没程序的事情发生</p><h4 id="变量和赋值"><a class="markdownIt-Anchor" href="#变量和赋值">#</a> 变量和赋值</h4><p>程序进行一系列的运算，会有一种临时存储数据的方法，这种储存单元被称为变量</p><h4 id="类型"><a class="markdownIt-Anchor" href="#类型">#</a> 类型</h4><p>每个变量都有一个类型，来说明所储存的数据的种类<br>列入 int (整数) 类型和 float (小数) 类型</p><p>同时 float 类型可以储存的数可以比 int 大很多，但是坏处就是 float 的计算可能更加缓慢，而且会造成一定量的误差</p><h4 id="声明"><a class="markdownIt-Anchor" href="#声明">#</a> 声明</h4><p>声明变量首先确定变量的类型，然后说明变量的名字<br> eg int height<br>int 就是变量的类型，而 height 就是变量的名字<br><strong> main 的声明要放在语句之前</strong></p><h4 id="赋值"><a class="markdownIt-Anchor" href="#赋值">#</a> 赋值</h4><p>变量通过赋值语句获得值</p><blockquote><pre><code>eg: height=8</code></pre></blockquote><p>这种确定的数值称为常量<br>赋值右侧可以是一个含有常量，变量和运算符的公式，在 C 语言中称为<strong>表达式</strong></p><h4 id="显示变量的值"><a class="markdownIt-Anchor" href="#显示变量的值">#</a> 显示变量的值</h4><blockquote><p>eg:pritnf("%d \n",height)</p></blockquote><p>这里 % d 是一个占位符，用来指明在显示过程中变量 height 的显示位置</p><p>% d 只用于 int     % f 用于 float 类型变量 f 显示小数点后六位，没有的用 0 补齐<br><strong>注意声明和赋值可以同时进行</strong></p><blockquote><p>eg: int weight=8</p></blockquote><p>需要注意的是，以下这种情况只有 width 拥有初始化器 10</p><blockquote><p>int height,length,width=10</p></blockquote><h4 id="宏定义给常量命名"><a class="markdownIt-Anchor" href="#宏定义给常量命名">#</a> 宏定义给常量命名</h4><blockquote><p>eg:#define INCHES 166</p></blockquote><p>在后面的程序中所有的 INCHES 都会被替换成 166，这里需要注意的，一般宏定义的名称都用大写字母表示，这里没有硬性规定，但这是程序员遵循了几十年的基本准则，可以方便程序更方便的阅读<br>同样后面的 166 也可以为一个表达式，表达式建议用括号括上<br><strong>注意 C 语言四舍五入时向下取整</strong></p><h4 id="标识符"><a class="markdownIt-Anchor" href="#标识符">#</a> 标识符</h4><p>在编写程序时，需要进行大量的命名，这些名字被称为<strong>标识符</strong>，在 C 语言中标识符可以有字母，数字，和下划线，但是必须<strong>以字母或者下划线开头</strong></p><p>同时标识符是区分大小写的也就是说 JOB 和 job 是两个完全不同的标识符</p><h4 id="关键字"><a class="markdownIt-Anchor" href="#关键字">#</a> 关键字</h4><p>关键字对 C 编译器有着特殊的意义，因此这些关键字不能作为标识符来使用</p><p><a href="https://imgtu.com/i/IQ9uZQ"><img src="https://z3.ax1x.com/2021/11/06/IQ9uZQ.md.jpg" alt="IQ9uZQ.md.jpg"></a></p><h4 id="书写规范"><a class="markdownIt-Anchor" href="#书写规范">#</a> 书写规范</h4><p>语句可以分开放在任意多行内。<br>记号间的宫格可以让我们更容易区分记号，基于这个原因，我通常会在每个运算符的前后都放上一个空格</p><blockquote><pre><code> eg volume = height * width * length</code></pre></blockquote><p>缩进有助于轻松识别程序嵌套</p><p>空行可以把程序分为逻辑单元，从而使读者更容易辨别程序的结构，没有空行的程序很难阅读，就像不分章节的书一样.</p><h3 id="格式化输入输出"><a class="markdownIt-Anchor" href="#格式化输入输出">#</a> 格式化输入 / 输出</h3><h4 id="printf函数"><a class="markdownIt-Anchor" href="#printf函数">#</a> printf 函数</h4><blockquote><pre><code>   printf(" i = %d , j = %d",i,j);   printf(格式化字符串,表达式1，表达式2,...;)</code></pre></blockquote><p>格式化字母串包含<strong>普通字符</strong>和<strong>转换说明</strong><br>转换说明以 % 开头，% 后面的信息指定了把数值从内部形式转换为打印字母的方法<br> eg:% d 表示把 int 型数值从二进制转换成十进制的字符串</p><p>注意编译器不会检测格式串中转换说明的数量是否和输出项的数量相匹配，但是如果多于或者少于会让程序简单地无意义地输出<br>如果转换说明的个数小于变量数，多的变量就无法显示出来<br>变量和占位符不匹配时，就是显示出一个无意义的数值.<br><a href="https://imgtu.com/i/IQ9FPI"><img src="https://z3.ax1x.com/2021/11/06/IQ9FPI.png" alt="IQ9FPI.png"></a></p><h5 id="转换说明"><a class="markdownIt-Anchor" href="#转换说明">#</a> 转换说明</h5><h5 id="标志"><a class="markdownIt-Anchor" href="#标志">#</a> 标志</h5><p>-: 左对齐，也就是加空格或 0 时加在后面<br>不加 - 默认为右对齐，也就是加空格或 0 时加在前面</p><p>0: 加 0 表示用空格代替 0，不加 0 时输出的值多的用空格代替</p><h6 id="最小栏宽m"><a class="markdownIt-Anchor" href="#最小栏宽m">#</a> 最小栏宽 m</h6><p>最小栏宽 m 指定了要显示的最少字符数量 (<strong>m 表示了输出的数最少占几列</strong>)，如果要系那是的字符数少于 m，那么值在字段内是右对齐的 (换句话说，在值得前面显示空格)<br> 例如 %4d 将以<strong>空格 123</strong> 的形式显示数 123，如果要显示的值所需字符多于 m，那么栏宽会自动拓展为所需的尺寸。因此，转换说明 %4d 将以 12345 的形式显示数 12345，而不会丢失数字。在 m 前放上一个负号，会导致左对齐；转换说明 %-4d 将以<strong> 123 空格</strong>的形式显示 123</p><h6 id="精度p"><a class="markdownIt-Anchor" href="#精度p">#</a> 精度 p</h6><p>精度的含义很难 6+<br>+ 描述，因为他依赖于转换指定符号<br> d:p 指明了待限制数字的最少个数 (包括空格)<br>, 如果省略 p，则默认它的值为 1<br>e: 表示科学计数法形式的浮点数。p 指明了小数点后应该出现的数字个数 (默认值为 6) 如果 p 为 0 则不显示小数点<br> g: 自动选 f 格式或 e 格式中较短的一种输出，且不输出无意义的 0<br>o：无符号数转化为八进制数<br> x：无符号数转化为十六进制数<br><a href="https://imgtu.com/i/IQ9ARP"><img src="https://z3.ax1x.com/2021/11/06/IQ9ARP.png" alt="IQ9ARP.png"></a><br><a href="https://imgtu.com/i/IQ9Exf"><img src="https://z3.ax1x.com/2021/11/06/IQ9Exf.png" alt="IQ9Exf.png"></a></p><h5 id="转义序列"><a class="markdownIt-Anchor" href="#转义序列">#</a> 转义序列</h5><p>警报响铃符:    \a<br> 回退符:     \b<br> 换行符:     \n<br> 水平制表符：   \t<br>“:”( \  + 特殊字符 = 特殊字符 )</p><h4 id="scanf函数"><a class="markdownIt-Anchor" href="#scanf函数">#</a> scanf 函数</h4><blockquote><p>scanf ("&amp;d", 变量名)</p></blockquote><p>scanf 函数起到读取用户输入到屏幕的数据<br> pritnf 函数起到将程序中的数据显示到屏幕上的作用<br> scanf 与 prinf 函数是相对的<br> scanf 函数的工作原理 这里不一一叙述<br>可见程序与设计第 32 页 3.2.1</p><p>另外 % i 也可以充当整数的占位符，在 printf 中与 % d 没有区别，但是在 scanf 中 % i 可以储存 10 进制，8 进制，16 进制的数字，而 % d 只能储存 10 进制的数字，如果输入的数前面有 0 那么 % i 会当成 8 进制处理，如果前面有 0x 那么输入的数会当成 16 进制处理，所以一般情况下我们坚持使用 % d，防止因为在数字前面加入 0 而导致数据识别错误</p><h4 id="表达式"><a class="markdownIt-Anchor" href="#表达式">#</a> 表达式</h4><h5 id="算术运算符"><a class="markdownIt-Anchor" href="#算术运算符">#</a> 算术运算符</h5><blockquote><p>一元运算符: + 正号  - 负号<br>二元运算符: + 加法 - 减法  * 乘法  / 除法 % 求余</p></blockquote><p>可能产生的意外结果</p><blockquote><p>两个操作数都是整数时，结果会进行四舍五入，例如 1/2 的结果是 0 而不是 0.5<br>% 要求操作数是整数 如果两个操作数中有一个不是整数，程序将无法编译通过<br>根据 C89 标准，如果两个运算符中有一个为负数，那么结果不确定，可能向上取整，也可能向下取整<br>在 C99 标准中 除法的结果总是趋向 0 截取    i% j 的结果的值得负号与 i 相同 例如 - 9%7 的结果为 - 2</p></blockquote><h5 id="优先级和结合性"><a class="markdownIt-Anchor" href="#优先级和结合性">#</a> 优先级和结合性</h5><blockquote><p>最高优先级: + - (一元运算符)  *  /  %<br> 最低优先级:    +  -  (二元运算符)</p></blockquote><p>当有多个相同优先级的符号时，从左到右依次结合.<br><a href="https://imgtu.com/i/IQ99VH"><img src="https://z3.ax1x.com/2021/11/06/IQ99VH.png" alt="IQ99VH.png"></a></p><h5 id="赋值运算符"><a class="markdownIt-Anchor" href="#赋值运算符">#</a> 赋值运算符</h5><p>求出表达式的值后，将值储存在变量中，就需要对变量进行赋值</p><p>如果变量表示的含义和所输入的数字不同，将会把数字改成变量所对应的数字<br>例如: int i=72.999   这个时候 i 对应的值就是 72 而不是 72.999</p><p>多个运算符可以串联在一起<br> i = j = k = 0;<br> 需要注意的是，赋值表达式是从右开始赋值的<br> i = (j = (k = 0))</p><h5 id="左值"><a class="markdownIt-Anchor" href="#左值">#</a> 左值</h5><p>大多数 C 语言运算符允许他们的操作数是变量，常量，或者是其他运算符表达式，但是他们的<strong>左值</strong>必须是对象</p><p>目前为止<strong>变量</strong>是唯一的左值</p><h5 id="复合赋值"><a class="markdownIt-Anchor" href="#复合赋值">#</a> 复合赋值</h5><blockquote><p>复合运算符 -=,*=,/=,%=,+=<br> 另外 5 种赋值运算符将在后面的章节中介绍</p></blockquote><p>v += e 表示 v 加上 e 再把结果储存在 v 中<br>这并不等价于 v = v+e 例如变量 i*=j+k 就不等于 i= i*j + k</p><p>复合赋值运算符同样也是右结合的<br>语句 i += j += k 表示 i += (j += k)</p><p>最常使用的两种运算是 自增和自减<br>例如 i = i + 1 而复合运算符可以缩短这串代码 可以改写为 i += 1</p><h5 id="自增运算符和自减运算符"><a class="markdownIt-Anchor" href="#自增运算符和自减运算符">#</a> 自增运算符和自减运算符</h5><p>C 语言还允许使用 ++ (自增) 和 – (自减) 运算符将这些语句缩得更短<br>实际上自增和自减运算符的使用非常复杂，原因是 ++ 和 -- 既可以作为前缀，也可以作为后缀，根据实际使用情况而定</p><p>而这种情况实际上是有副作用的，副作用的效果就是自增 i</p><p>前缀自增和后缀自增的区别：前缀自增表示先自增 i 再将变量 i 代入表达式中，后缀自增表示先把变量 i 代入表达式中，再自增 i</p><p>并且在同一个句子中多次使用 ++ 和 -- 往往难以理解，例如<br> i = 1; j = 2 ; k = <ins>i + j</ins>;</p><p>后缀<ins>和 -- 优先级 比正号和负号高，并且都是左结合<br>前缀</ins>和 -- 优先级和正号负号相同，并且都是右结合</p><h4 id="选择语句"><a class="markdownIt-Anchor" href="#选择语句">#</a> 选择语句</h4><h5 id="逻辑表达式"><a class="markdownIt-Anchor" href="#逻辑表达式">#</a> 逻辑表达式</h5><p>测试表达式的结果是 "真" 还是 "假"，这类表达式只有这两个效果，翻译为电脑语言就是这个表示只会输出两个值 0 或者 1<br><a href="https://imgtu.com/i/IQ9ZM8"><img src="https://z3.ax1x.com/2021/11/06/IQ9ZM8.png" alt="IQ9ZM8.png"></a><br> 逻辑运算符对操作数进行短路计算，这些运算符首先计算出左操作数的值，然后计算出右操作数的值，如果做操作数的值可以直接推导表达式的值，那么将不计算右操作数的值</p><p>运算符！的优先级等于一元正负号的优先级，而运算符 &amp;&amp; 和 || 的优先级低于关系运算符和判等运算符，运算符！是右结合的，而运算符 &amp;&amp; 和运算符 || 是左结合的.</p><h5 id="关系运算符"><a class="markdownIt-Anchor" href="#关系运算符">#</a> 关系运算符</h5><p><a href="https://imgtu.com/i/IQ9PIA"><img src="https://z3.ax1x.com/2021/11/06/IQ9PIA.png" alt="IQ9PIA.png"></a></p><p>需要注意的是 i &lt; j &lt; k 并不是所想象的 j 处在 i 和 k 的中间值得意思，表达式是左结合的<br>所以原式式 (i &lt; j) &lt; k  先对 i &lt; j 进行判定，输出 0 或者 1 来和 k 进行比较</p><h5 id="判等运算符"><a class="markdownIt-Anchor" href="#判等运算符">#</a> 判等运算符</h5><p><a href="https://imgtu.com/i/IQ9esS"><img src="https://z3.ax1x.com/2021/11/06/IQ9esS.png" alt="IQ9esS.png"></a></p><p>i &lt;j == j &lt; k 等价于 (i &lt; j) == (j &lt; k)<br> 只有当 两边同为真或者同为假的时候 输出结果为真</p><h5 id="运算顺序"><a class="markdownIt-Anchor" href="#运算顺序">#</a> 运算顺序</h5><p>C 语言对括号的运算顺序没有进行规定，所以因为编译器的不同可能出现不同的结果<br>例如 a = 5 ;<br>c = (b = a + 2 ) - ( a = 1 )<br> 先算 b = a + 2 还是先算 a = 1 不同的编译器有着不一样的算法，所以如果编译器不同，可能产生不一样的结果</p><p>注意不要依赖特定的运算顺序</p><p>例如: i = 2 ;  j = i * i++;<br> 大部分人可能会认为输出的结果是 4，其实也可能为 6，不同的编译器有时候会出现不同的结果<br>最好的方法就是将长的运算表达式转化为短的运算表达式，如此就可以适应不同的编译器.</p><h4 id="if语句"><a class="markdownIt-Anchor" href="#if语句">#</a> if 语句</h4><blockquote><p>if (表达式) 语句</p></blockquote><p>注意表达式两边的括号是必须的<br>计算时先计算括号内表达式的值，如果表达式的值非零也就是真值，那么接着执行括号后面的语句.<br> 一定要注意区分 ==(判等) 和 =(赋值)<br> 前面我们说了例如 i &lt; j &lt; k 这样的写法是不行的，为了判定变量是否落在某个数值范围内，例如为了判定 0≤ i &lt; n 我们可以写成</p><blockquote><p>if (0 &lt;= i &amp;&amp; i&lt; n) …</p></blockquote><p>|| 运算符也是相同的道理</p><h5 id="复合语句"><a class="markdownIt-Anchor" href="#复合语句">#</a> 复合语句</h5><p>在 if 语句模板中，语句是一条语句而不是多条语句，如果想用 if 语句处理多条语句，我们引入了复合语句.<br> 复合语句由一对花括号和语句混合而成，可以有多个声明和多个语句，也可以什么都没有<br>为了表示清楚，通常将一条语句放在多行内，每行有一条语句，如下所示:<br>{<br>line_num = 0;<br>page_num++;<br>}<br> 注意，每条内部语句依然以<strong>分号</strong>结尾</p><h5 id="else子句"><a class="markdownIt-Anchor" href="#else子句">#</a> else 子句</h5><p>if 语句可以有 else 子句</p><blockquote><p>if (表达式) 语句 else 语句</p></blockquote><p>注意，出现的语句末尾都要以<strong>分号</strong>结尾</p><p>通常来说为了布局美观，和清楚显示代码，我们将 if 和 else 放在同一列，其内的内部语句同样进行缩进<br>可以为复合语句增加花括号，这不是必需的但是能够使复合语句更加清楚.</p><h4 id="条件表达式"><a class="markdownIt-Anchor" href="#条件表达式">#</a> 条件表达式</h4><blockquote><p>表达式 1 ? 表达式 2 : 表达式 3</p></blockquote><p>表达式 1,2,3 可以是任何类型的表达式，同时条件表达式被经常称为三元运算符.</p><p>条件表达式读作 如果表达式 1 成立，那么表达式 2，否则表达式 3<br> 求值步骤为：首先计算出表达式 1 的值，如果此值不为 0，那么计算表达式 2 的值，并且计算出来的值就是整个表达式的值，如果表达式 1 的值为 0，那么表达式 3 的值是整个条件表达式的值</p><p>条件表达式通常运用于 printf 中进行简化代码</p><p>例如 if (i&gt; j ) printf ("% d \n",i); else printf ("% d \n",j);<br> 可以简化为  printf ("% d \n",i&gt;j?i:j);<br> 同时在 return 中也经常使用，使用场景类似</p><h4 id="switch语句"><a class="markdownIt-Anchor" href="#switch语句">#</a> switch 语句</h4><p>通常来说可以用 switch 语句来代替级联式 if 语句</p><blockquote><p>switch (表达式) {<br>case 常量表达式：语句<br>…<br>case 常量表达式：语句<br> default : 语句<br>}</p></blockquote><p>同样这里的语句也要以<strong>分号</strong>结尾<br><a href="https://imgtu.com/i/IQ9mqg"><img src="https://z3.ax1x.com/2021/11/06/IQ9mqg.jpg" alt="IQ9mqg.jpg"></a></p><p>switch 语句实际上是一种给予计算的跳转。对控制表达式求值时， 控制会跳转到与 switch 表达式的值相匹配的分支标号处。在执行完一个分支后，程序控制向下跳转到下一个分支的第一条语句上，如果没有 break 语句，控制将从一个分支继续流向下一个分支。例如<br> switch (grade) {<br>case 4 :printf (“Excellent”);<br>case 3 :printf (“Good”);<br>case 2 :printf (“Average”);<br>case 1 :printf (“poor”);<br>case 0 :printf (“Falling”);<br>default : printf (“Illegal grade”)<br>}<br> 当你输入 3 时，显示的消息是：GoodAveragePoorFailingIllegal grade</p><h3 id="循环"><a class="markdownIt-Anchor" href="#循环">#</a> 循环</h3><h4 id="while语句"><a class="markdownIt-Anchor" href="#while语句">#</a> while 语句</h4><blockquote><pre><code>[while语句]:    while (表达式) 语句例如: while(i&lt;n) i=i*2;</code></pre></blockquote><p>因为 while 语句中有循环，为了让循环更简单，我们可以将 i++ 或者 i–直接加到 printf 中来使代码更加简洁</p><blockquote><pre><code>例如: while(i&gt;0) printf("%d \n",i--)这串代码可以一直输出0~i的数字，是不是这样更加简洁</code></pre></blockquote><h4 id="do语句"><a class="markdownIt-Anchor" href="#do语句">#</a> do 语句</h4><p>do 语句在本质上其实就是 while 语句只不过其控制表达式是在每次执行完循环体之后进行判定.</p><blockquote><pre><code>[do语句]: do 语句  while(表达式):</code></pre></blockquote><p>do 语句的循环体必须是一条语句和 while 一样，当然如果想用多条语句可以用复合语句.</p><p>执行 do 语句时，先执行循环体，再计算控制表达式的值</p><h4 id="for语句"><a class="markdownIt-Anchor" href="#for语句">#</a> for 语句</h4><blockquote><pre><code>[for语句]    for(表达式1或者声明;表达式2;表达式3)</code></pre></blockquote><p><a href="https://imgtu.com/i/IQpd8P"><img src="https://z3.ax1x.com/2021/11/06/IQpd8P.png" alt="IQpd8P.png"></a></p><p>对于向上增或向下减的循环来说，for 语句通常是最好的选择</p><p>从 0 向上加到 n-1</p><blockquote><pre><code>for (i=0;i&lt;n;i++)</code></pre></blockquote><p>从 1 向上加到 n</p><blockquote><pre><code>for(i=1;i&lt;=n,i++)</code></pre></blockquote><p>等等同理</p><p>如果所需要的语句没有那么多，for 语句允许省略语句，注意，即使省略了表达式，括号中也许有两个<strong>分号</strong><br>当 for 语句同时省略第一个和第三个表达式时，那么他和 while 语句没有任何区别<br>省略第一个语句时，程序会默认为真值，会一直循环下去</p><p>在 C99 中第一个表达式可以替换成一个声明，但在 for 语言中的声明，仅可以在 for 语句内部使用，在 for 循环的外部不可用</p><p>同时 for 语言中可以声明多个变量，但是他们的类型需要相同</p><h4 id="逗号运算符"><a class="markdownIt-Anchor" href="#逗号运算符">#</a> 逗号运算符</h4><blockquote><pre><code>[逗号表达式] 表达式1,表达式2</code></pre></blockquote><p>第一步计算出表达式 1 的值，抛弃。第二部计算出表达式 2 的值，并将表达式 2 的值作为整个表达式的值，需要注意的是这里并不是说表达式 1 的值并没有用，表达式 1 中例如 i++，i–等仍然会对表达式 2 中的 i 和 j 造成一定的影响</p><p>逗号运算符是左结合的，并且逗号运算符的优先级比其他所有运算符的优先级都更低</p><p>for 语句是唯一可以发现逗号运算符的地方.<br>for 语句可以利用逗号表达式来声明更多的变量</p><h3 id="跳出循环"><a class="markdownIt-Anchor" href="#跳出循环">#</a> 跳出循环</h3><h4 id="break语句"><a class="markdownIt-Anchor" href="#break语句">#</a> break 语句</h4><p>前面讨论过 break 语句跳出 switch 语句，同时 break 语句还可以用于跳出 while,do,for 循环</p><p>需要注意的时，如果有嵌套的情况存在，break 语句只能跳出一层循环</p><h4 id="continue语句"><a class="markdownIt-Anchor" href="#continue语句">#</a> continue 语句</h4><p>continue 语句与 break 语句的区别在于，break 语句把程序控制转移到循环体末尾之后，而 continue 语句刚好把程序控制转移到循环体末尾之前.<br>continue 语句会把程序控制留在循环内，而 break 语句会使程序控制跳出循环<br> continue 语句只能用于循环，而 break 语句可以用于 switch 语句和循环</p><p>continue 语句不会跳出循环，但会直接跳过 continue 之后的一系列语句，重新开始循环</p><h4 id="goto语句"><a class="markdownIt-Anchor" href="#goto语句">#</a> goto 语句</h4><p>goto 语句可以跳转到函数中任何有<strong>标号</strong>的语句处</p><blockquote><pre><code>[标号语句]  标识符:语句[goto语句]  goto 标识符;</code></pre></blockquote><p>两个语句必须在同一个函数中<br> goto 语句对于嵌套循环的退出是很有用的</p><h4 id="空语句"><a class="markdownIt-Anchor" href="#空语句">#</a> 空语句</h4><blockquote><pre><code>eg:for(XX;XX;XX);</code></pre></blockquote><p>空语句的一个好处：编写空循环体的循环.<br>C 程序员习惯性地把空语句单独放置在一行</p><h3 id="基本类型"><a class="markdownIt-Anchor" href="#基本类型">#</a> 基本类型</h3><p>C 语言支持两种根本的数据类型 分别是 整数类型 和浮点数类型  简单来说 整数和其他数 (包括小数等等) 的区别</p><h4 id="整数类型"><a class="markdownIt-Anchor" href="#整数类型">#</a> 整数类型</h4><p>正说类型 分为 有符号整数和无符号整数</p><p>有符号整数：如果整数为正数或者 0 那么最左边的符号位为 0; 如果为负数 那么最左边的符号位为 1 储存的时候都是按有符号整数来储存 如果要当成无符号整数来储存 需要声明整数类型为 unsigned<br> 无符号整数：最左边的位是数值的一部分</p><p>C 语言的整数类型 有着不同的大小 int 类型通常为 32 位   有些数字很大 所以 C 语言还提供了 长整型 和 需要很小空间来储存的数 这样的数称为短整型</p><p>整型分为 4 种 long short signed unsigned 他们之间可以互相组合</p><blockquote><pre><code>short intunsigned short intintunsigned intlong intunsigned long int</code></pre></blockquote><p>其他组合都是上述组合的同义词<br> C 语言允许通过省略单词 int 来缩写整数类型的名字<br>但很多基于 c 语言的程序 甚至不允许程序员写 short int 这样的名字 而必须写成 short 或者 long<br> 不同类型的取值范围也可能一样<br> eg: long int 可能和 int 有相同的取值范围  但是 long int 永远不可能比 int 的取值范围短<br><a href="https://imgtu.com/i/IQpcUs"><img src="https://z3.ax1x.com/2021/11/06/IQpcUs.png" alt="IQpcUs.png"></a><br><a href="https://imgtu.com/i/IQpsbQ"><img src="https://z3.ax1x.com/2021/11/06/IQpsbQ.png" alt="IQpsbQ.png"></a><br><a href="https://imgtu.com/i/IQp0v8"><img src="https://z3.ax1x.com/2021/11/06/IQp0v8.png" alt="IQp0v8.png"></a><br> 但是这种范围会随着编译器的不同而不同 好的解决方法是检查 &lt;limis.h&gt; 头文件定义了每种整数类型的最大值和最小值的宏<br> C99 新增了 2 个 long long int 和 unsigned long long int</p><h5 id="整数常量"><a class="markdownIt-Anchor" href="#整数常量">#</a> 整数常量</h5><p>常量：在程序中以文本形式出现的数，而不是读，写，计算出来的数.C 语言允许用十进制，八进制，十六进制来表示常量</p><p>十进制不能以 0 开头 八进制必须以 0 开头 十六进制总是以 0x 开头<br>这里需要注意的是  这些只是书写数的方式 并不会对数的储存方式产生英雄 数都是以二进制储存的 所以我们进行计算的时候甚至可以将他们三个混合使用 程序仍然能够识别 并且计算出值<br>十进制整数常量的类型同城为 nit 但如果常量的值大得无法储存在 int 型中 那就用 long int 类型。如果出现 long int 还不够用的罕见情况 编译器会用 unsigned long int 做最后的尝试<br>八进制和十六进制 会从范围最小的整数型开始尝试 直至找到能表示该常量的类型</p><p>要强制编译器把常量作为长整数来处理，只需要在后边加上一个字母 L/l  <strong>大小写无所谓</strong><br>同样 要指明是无符号变量 可以在常量后边加上字母 U/u<br><strong>L 和 U 可以混合使用 顺序和大小都无所谓</strong></p><h5 id="c99中的整型变量"><a class="markdownIt-Anchor" href="#c99中的整型变量">#</a> C99 中的整型变量</h5><p>在 C99 中 出现了 LL (long long) 在 ll 前面 U 的通常是 unsigned long long  需要注意的是 <strong>这里两个 l 的大小写需要一致</strong><br>十进制储存 按照 int      long int   long long int 中的最小的能适合的方式储存<br>而八进制和十六进制 按照 int        unsigned int          long int           unsigned long int   ……</p><h5 id="整数溢出"><a class="markdownIt-Anchor" href="#整数溢出">#</a> 整数溢出</h5><p>对整数执行算数运算时，其结果有可能因为太大而无法显示，这时候就会发生整数溢出<br>有符号整数溢出时 会出现没有定义的情况 无法预估最后会发生的情况<br>无符号整数溢出时 结果会有定义的：正确答案对 2 的 n 次方取模 例如 65535+1 的结果 (能够被 2 除尽) 其结果可以保证为 0</p><h5 id="读写整数"><a class="markdownIt-Anchor" href="#读写整数">#</a> 读 / 写整数</h5><p>通常我们发生整数溢出时，会马上去更换整数类型 但单单这样做是不够的 我们还必须检查数据类型的改变对程序其他部分的影响</p><p>读写无符号整数时 使用 u,o,x 代替转换说明中的 d<br>u 表示十进制 o 表示八进制 x 表示十六进制</p><p>读写短整数时 在 d,o,x 或者 u 前面加上字母 h</p><p>读写长整数时，在 d,o,x 或者 u 前面加上字母 l</p><p>读写尝尝整数时，在 d,o,x 或者 u 前面加上字母 ll</p><h4 id="浮点类型"><a class="markdownIt-Anchor" href="#浮点类型">#</a> 浮点类型</h4><p>float: 单精度浮点数<br> double: 双精度浮点数<br> long double: 扩展精度浮点数</p><p>C 语言没有明确的说明精度到底是多少 不同的计算机可以以不同的方法储存浮点数</p><p>数值是由三部分组成：符号，指数和小数 指数部分的位数说明了数值可能大小程度 而小数部分的位数说明了精度<br><a href="https://imgtu.com/i/IQpwgf"><img src="https://z3.ax1x.com/2021/11/06/IQpwgf.png" alt="IQpwgf.png"></a><br>long double 类型没有出现在表中 因为它的长度随着机器的不同而变化 最常见的大小是 80 位和 128 位</p><p>C99 中 浮点类型分为两种 一种是实浮点类型 包括 float,double,long double 类型<br>另一种是 C99 新增的复数类型  包括 float ,_Complex ,double ,_Complex ,long double _Complex</p><h5 id="浮点常量"><a class="markdownIt-Anchor" href="#浮点常量">#</a> 浮点常量</h5><p>浮点常量必须包括小数点或者指数 其中指数指明了对前面的数进行缩放所需的 10 的幂次 如果有指数 则需要在指数数值前放置字母 E 或者 e 可选符号 + 或者 - 可以出现在字母 E 或者 e 的后边 为了表明只需要单精度 可以在常量的末尾处加上字母 F/f; 而为了说明常量必须以 long double 的形式储存可以在常量的末尾处 加上字母 L 或者 l</p><h5 id="读写浮点数"><a class="markdownIt-Anchor" href="#读写浮点数">#</a> 读写浮点数</h5><p>前面已讨论过，转换说明 % e,% f 和 % g 用于读写单精度浮点数 读写 double 和 long double 类型的值所需的转换说明略有不同<br>读写 double 类型的值时，在 e,f,g 前面放置字母 l   <strong>注意只能在字符串 scanf 中使用 在 printf 函数调用中使用额 e,f,g 可以用来写 float 类型或者 double 类型的值</strong><br>读写 long double 类型时，在 e,f,g 前面放置字母 L<br><strong> 注意 double 和 long double 这里有字母大小写的区别</strong></p><h4 id="字符类型char"><a class="markdownIt-Anchor" href="#字符类型char">#</a> 字符类型 char</h4><p>当前最常用的字符集是 ASCII 字符集，用 7 位代码表示 128 个字符<br> char 类型的变量可以用任意单字符赋值</p><h5 id="字符操作"><a class="markdownIt-Anchor" href="#字符操作">#</a> 字符操作</h5><p>C 语言将字符当做整数进行处理 毕竟所有的字符都是以二进制的形式进行编码的</p><blockquote><pre><code>char ch;ch = 65      此时ch是Ach = ch+1    此时ch是B</code></pre></blockquote><h5 id="有符号字符和无符号字符"><a class="markdownIt-Anchor" href="#有符号字符和无符号字符">#</a> 有符号字符和无符号字符</h5><p>char 类型像整数类型一样存在符号性和无符号性两种 通常有符号型的取值是 - 128~127 而无符号字符的取值是 0~255<br> 所有 C 语言允许单词 signed 和 unsigned 来修饰 char 类型</p><h4 id="算数类型"><a class="markdownIt-Anchor" href="#算数类型">#</a> 算数类型</h4><p><a href="https://imgtu.com/i/IQp6Ej"><img src="https://z3.ax1x.com/2021/11/06/IQp6Ej.png" alt="IQp6Ej.png"></a></p><h4 id="转义序列-2"><a class="markdownIt-Anchor" href="#转义序列-2">#</a> 转义序列</h4><p>转义序列分为字符转义序列和数字转义序列</p><h5 id="字符转义序列"><a class="markdownIt-Anchor" href="#字符转义序列">#</a> 字符转义序列</h5><p><a href="https://imgtu.com/i/IQprDg"><img src="https://z3.ax1x.com/2021/11/06/IQprDg.png" alt="IQprDg.png"></a></p><h5 id="数字转义序列"><a class="markdownIt-Anchor" href="#数字转义序列">#</a> 数字转义序列</h5><p>字符转义序列没有包含所有无法打印的 ASCII 字符 字符转义序列也无法包含 128 个 ASICC 字符以外的字符 而数字转义字符可以表示任何字符 所有它可以解决上述问题</p><p>作为字符常量来使用时，<strong> 转义序列必须用一堆单引号括起来</strong></p><h4 id="字符处理函数"><a class="markdownIt-Anchor" href="#字符处理函数">#</a> 字符处理函数</h4><p>例如 toupper 函数可以将小写字母转化为大写字母 但要调用这类使用的字符处理函数 需要在顶部放置 #include &lt;ctype.h&gt; 这一条指令</p><h5 id="用scanf-和printf读写字符"><a class="markdownIt-Anchor" href="#用scanf-和printf读写字符">#</a> 用 scanf 和 printf 读写字符</h5><p>scanf 读写字符时 并不会跳过空白字符 为了强制 scanf 在读入字符前跳过空白字符，需要在格式串中的转换说明 % C 前面加上一个空格</p><h5 id="用getchar和putchar用于读写字符"><a class="markdownIt-Anchor" href="#用getchar和putchar用于读写字符">#</a> 用 getchar 和 putchar 用于读写字符</h5><p>getchar 函数和 putchar 函数可以用来取代 scanf 和 printf 函数 putchar 函数用于写单个字符<br>每次调用时他会读写一个字符并将其返回 为了保存这个字符 必须使用赋值操作将其储存在变量中<br>当混用 getchar 函数和 scanf 函数要小心 scanf 函数仅消耗掉匹配的输入数据 其余部分仍然留在缓冲区 (包括换行符)</p><h4 id="类型转换"><a class="markdownIt-Anchor" href="#类型转换">#</a> 类型转换</h4><h5 id="隐式类型转换规则"><a class="markdownIt-Anchor" href="#隐式类型转换规则">#</a> 隐式类型转换规则</h5><p>较低级向较高级转换 (按存储长度)<br> 其中有一个操作数是浮点型时 把整型操作数往浮点型转换 而浮点型往精度更高的浮点型转换<br>两个操作数都不是浮点数时，如果有 char 或者 short int 类型 首先对两个操作数进行整型提升<br><strong>特例</strong>:long int 和 unsigned int 数据类型长度相同时 则两个操作数均转换为 unsigned long<br><a href="https://imgtu.com/i/IQ9FPI"><img src="https://z3.ax1x.com/2021/11/06/IQ9FPI.png" alt="IQ9FPI.png"></a><br> 赋值中的类型转换：把赋值运算符右侧表达式的值转换为左侧变量的类型.</p><h5 id="强制类型转换"><a class="markdownIt-Anchor" href="#强制类型转换">#</a> 强制类型转换</h5><blockquote><pre><code>(类型)变量   eg(char)i  表示把i的类型强制转换为char的类型(类型)(表达式)</code></pre></blockquote><p>这些转换类型只是一次有效的 不会改变变量定义时的数据类型<br> C 语言把类型名视为一元运算符</p><h4 id="类型定义"><a class="markdownIt-Anchor" href="#类型定义">#</a> 类型定义</h4><blockquote><pre><code>typedef 数据类型 别名</code></pre></blockquote><p>用于对另一个数据类型创建一个别名<br>注意并没有创建一个新的类型 仅仅是对某个已有的类型增加一个别名<br>可以让程序更加易于理解 可读性更高</p><h4 id="sizeof-运算符"><a class="markdownIt-Anchor" href="#sizeof-运算符">#</a> sizeof 运算符</h4><p>取数据类型 常量 变量或者表达式值得存储长度的运算符 (以字节为单位)</p><blockquote><pre><code>sizeof(数据类型说明符/表达式)用于类型名 sizeof(类型名)用于表达式 sizeof 表达式</code></pre></blockquote><h3 id="第八章-字符输入输出和输入验证"><a class="markdownIt-Anchor" href="#第八章-字符输入输出和输入验证">#</a> 第八章 字符输入 / 输出和输入验证</h3><h4 id="单字符io-getchar和putchar"><a class="markdownIt-Anchor" href="#单字符io-getchar和putchar">#</a> 单字符 I/O getchar () 和 putchar ()</h4><h4 id="缓冲区"><a class="markdownIt-Anchor" href="#缓冲区">#</a> 缓冲区</h4><p>用户输入的字符被收集并存储在一个被称为缓冲区的临时存储区 按下 enter 键后 程序才可以使用用户输入的字符<br>某些交互式系统无缓冲区 比如游戏中按下一个键需要立即执行按下的操作<br>缓冲区分为完全缓冲和行缓冲</p><blockquote><pre><code>完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区行缓冲指的是在出现换行时刷新缓冲区(键盘输入)</code></pre></blockquote><p>是否能进行无缓冲输入取决于计算机系统 大部分直接规定输入都会缓冲输入</p><h4 id="结束键盘输入"><a class="markdownIt-Anchor" href="#结束键盘输入">#</a> 结束键盘输入</h4><h5 id="文件流和键盘输入"><a class="markdownIt-Anchor" href="#文件流和键盘输入">#</a> 文件，流和键盘输入</h5><h5 id="文件结尾"><a class="markdownIt-Anchor" href="#文件结尾">#</a> 文件结尾</h5><p>方法 1 文件末尾放置一个特殊字符 来标记末尾<br>方法 2 存储文件大小的信息。如果程序有 3000 字节 那么程序在读到 3000 字节的时候便达到文件末尾</p><p>在 C 语言中 用 getchar 或者 scanf 检测文件末尾时都将放回一个特殊值 即 EOF</p><h3 id="第九章函数"><a class="markdownIt-Anchor" href="#第九章函数">#</a> 第九章函数</h3><h4 id="复习函数"><a class="markdownIt-Anchor" href="#复习函数">#</a> 复习函数</h4><h5 id="创建并使用简单函数"><a class="markdownIt-Anchor" href="#创建并使用简单函数">#</a> 创建并使用简单函数</h5><blockquote><pre><code>#include &lt;stdio.h&gt;#define NAME "GIGATHINK,INC"#define ADDRESS "101 Megabuck plaza"#define PLACE "MEGAPOLIS,CA 94904"#define WIDTH 40void starbar(void);int main(void){    starbar();    printf("%s \n", NAME);    printf("%s \n", ADDRESS);    printf("%s \n", PLACE);    starbar(); //使用函数    return 0;}void starbar(void) //定义函数{    int count;    for (count = 1; count &lt;= WIDTH; count++)    {        putchar('*');    }    putchar('\n');}</code></pre></blockquote><h5 id="分析程序"><a class="markdownIt-Anchor" href="#分析程序">#</a> 分析程序</h5><p>函数原型：告诉编译器函数的类型<br>函数调用：表明在此处执行函数<br>函数定义：明确地指出函数要做什么</p><p>函数和变量有一样有多种类型 任何程序在使用函数之前都要声明该函数的类型</p><blockquote><pre><code>void starbar(void);圆括号表示starbar是一个函数名 第一个void是函数类型 void类型表明函数没有返回值 第二个void(圆括号中)表明该函数不带参数。分号表示这是在申明函数不是在定义函数 这行表明了程序将使用一个名为starbar(),没有返回值,没有参数的函数,并告诉编译器在别处查找该函数的定义</code></pre></blockquote><p>一般而言 函数原型指明了函数的返回值类型和函数接受的参数类型 这些信息称为函数的<strong>签名</strong><br>这里对于 starbar () 函数而言 其签名是该函数没有返回值，没有参数<br> starbar () 原型放在任何位置都可以<br>执行顺序:<br> 在 main () 中 当计算机执行到 starbar () 函数时，会找到该函数的定义并执行其中的内容，执行完 starbar () 中的代码后，计算机返回主调函数继续执行下一行<br>函数头包括函数类型，函数名和圆括号，接着是左花括号，变量声明，函数表达式语句，最后以又花括号结束<br> ** 注意函数头中的 starbar () 没有分号 这是在告诉编译器这是定义 starbar ()，而不是调用函数或者声明函数类型<br> starbar () 函数中的 count 变量是局部变量，意思是该变量只属于 starbar () 函数，可以在程序中的其他地方使用 count 这并不会引起名称冲突 他们是同名的不同函数</p><h5 id="函数参数"><a class="markdownIt-Anchor" href="#函数参数">#</a> 函数参数</h5><blockquote><pre><code>void show_n_char(char ch,int num);   shou_n_char('*',12)</code></pre></blockquote><h5 id="定义带形式参数的函数"><a class="markdownIt-Anchor" href="#定义带形式参数的函数">#</a> 定义带形式参数的函数</h5><p>第一行告知编译器 show_n_char 使用两个参数 ch 和 num,ch 是 char 类型 num 是 int 类型。这两个变量被称为形式参数，简称形参。和定义在函数中变量一样 形参也是局部变量属于该函数私有。这以为着在其他函数中使用同名变量不会引起名称冲突 每次调用函数 就会给这些变量赋值<br>值得一提的是 虽然 show_n_char () 接受来自 main () 的值 但是它没有返回值。因此，show_n_char () 的类型是 void</p><h5 id="声明带形式参数函数的原型"><a class="markdownIt-Anchor" href="#声明带形式参数函数的原型">#</a> 声明带形式参数函数的原型</h5><p>使用函数之前要声明函数原型: void shou_n_char (char ch,int num) 当然根据个人喜好 你也可以省略变量名<br>在原型中使用变量名并没有实际创建变量，char 仅代表了一个 char 类型的变量</p><h5 id="调用带实际参数的函数"><a class="markdownIt-Anchor" href="#调用带实际参数的函数">#</a> 调用带实际参数的函数</h5><p>在函数的调用中 实际参数 (简称实参) 提供了 ch 和 num 的值 比如 show_n_char (’*’,12); 这两个值被赋值给函数中的形式参数<br>简而言之形式参数是被调函数中的变量 实际参数是主调函数赋值给被调函数的具体值 实际参数可以是常量变量甚至是更复杂的表达式 无论实际参数是何种形式都要被求值 然后该值被拷贝给被调函数相应的形式参数.</p><h5 id="使用return从函数中返回值"><a class="markdownIt-Anchor" href="#使用return从函数中返回值">#</a> 使用 return 从函数中返回值</h5><blockquote><pre><code>int imin(int n , int m)int imin(int n , int m){int min ;if (n&lt;m) min=n;else min = m;return min;}int a = imin(1,2)</code></pre></blockquote><p>关键字 return 后面的表达式的值就是函数的返回值 在该例中，函数的返回值就是变量 min 的值<br>变量 min 属于 imin () 函数私有 但是 return 语句把 min 的值传回了主调函数<br> return; return 语句还可以这样使用 这样使用 retrun 语句将会终止函数并把控制返回给主调函数</p><h5 id="函数类型"><a class="markdownIt-Anchor" href="#函数类型">#</a> 函数类型</h5><p>声明函数必须声明函数的类型 带返回值的函数类型应该与其返回值得类型相同 没有返回值的函数声明为 void 类型<br><strong>值得注意的是 函数类型指的是函数返回值的类型 而不是参数的类型</strong><br>函数的前置声明可以放在主调函数外面也可以放在主调函数里面<br> ANSIC 标准库中，函数被封城了多个系列，每一个系列都有各自的头文件，这些头文件中包含了本系列所有函数的声明。例如 stdio.h 头文件中包括了标准的 I/O 库函数 (如 printf he scanf 函数) 的声明</p><h4 id="ansi-c-函数类型"><a class="markdownIt-Anchor" href="#ansi-c-函数类型">#</a> ANSI C 函数类型</h4><p>旨在说明老式声明函数的问题所在和解决方案 这里不做过多描述 可自行搜索</p><p>ANSI C 使用了逗号分割的类型列表 eg imax (int a , int b) 如此 编译器可以检查函数调用是否和函数原型匹配 参数的数量是否匹配 参数的类型是否匹配</p><h5 id="无参数和未指定参数"><a class="markdownIt-Anchor" href="#无参数和未指定参数">#</a> 无参数和未指定参数</h5><blockquote><pre><code>void print_name()</code></pre></blockquote><p>接受 ANSI C 的编译器截石位 print_name () 不接受任何参数，然后在调用该函数时，编译器会检查来确保没有使用参数</p><h5 id="函数原型的优点"><a class="markdownIt-Anchor" href="#函数原型的优点">#</a> 函数原型的优点</h5><p>使用函数原型会让编译器捕获在使用函数时可能出现的许多错误或疏漏，如果编译器没有发现这些问题，就很难觉察出来.<br> 有一种方法可以省略函数原型却保留函数原型的优点<br>把整个函数定义放在第一次调用该函数之前，也有相同的效果 此时函数定义也相当于函数原型。对于代码量较少的函数 这种用法很普遍</p><blockquote><pre><code>int imax(int a , int b ) {return a&gt;b?a:b}</code></pre></blockquote><h4 id="递归"><a class="markdownIt-Anchor" href="#递归">#</a> 递归</h4><p>C 允许函数调用他自己 这种调用过程称为<strong>递归</strong><br>难点：结束递归 (如果递归代码中没有终止递归的条件测试部分，一个调用自己的函数就会无限递归)<br> 注：可以使用循环的地方<strong>通常</strong>都可以使用递归</p><h5 id="演示递归"><a class="markdownIt-Anchor" href="#演示递归">#</a> 演示递归</h5><p><a href="https://imgtu.com/i/IlPHk4"><img src="https://z3.ax1x.com/2021/11/06/IlPHk4.jpg" alt="IlPHk4.jpg"></a><br><a href="https://imgtu.com/i/IlPbtJ"><img src="https://z3.ax1x.com/2021/11/06/IlPbtJ.jpg" alt="IlPbtJ.jpg"></a></p><h5 id="递归的基本原理"><a class="markdownIt-Anchor" href="#递归的基本原理">#</a> 递归的基本原理</h5><p>1. 每级函数调用都有自己的变量 也就是说第一级的 n 和第二的 n 不一样 当程序最终返回第一级的时候 最初的 n 仍然是它的初值 1 (局部变量)<br> 2. 每次幻术调用都会返回一次 当函数执行完毕后 控制权将被传回上一级递归。程序必须按照顺序逐级返回递归 不能跳级<br> 3. 递归函数中位于递归调用之前的语句 均按被调函数的顺序执行<br> 4. 递归函数中位于递归调用之后的语句 均按被调函数的<strong>相反</strong>顺序执行<br> 5. 虽然每级递归都有自己的变量 但是并没有拷贝函数的代码，所以程序按顺序执行函数中的代码 而递归调用就相当于又从头开始执行函数的代码 除了为每次递归调用创建变量外 递归调用非常类似于一个循环语句<br> 6. 递归函数必须包含能让递归调用停止的语句。通常递归函数都使用 if 或者其他等价的测试条件在函数形参等于某个特定值时终止递归。为此 每次递归调用的形参都要使用不同的值</p><h5 id="尾递归"><a class="markdownIt-Anchor" href="#尾递归">#</a> 尾递归</h5><p>将递归放置在函数的末尾 即正好在 return 语句之前 这种形式的递归被称为尾递归 相当于循环</p><h5 id="递归和倒序计算"><a class="markdownIt-Anchor" href="#递归和倒序计算">#</a> 递归和倒序计算</h5><p>在处理这类倒序问题时  递归比循环简单</p><h5 id="递归的优缺点"><a class="markdownIt-Anchor" href="#递归的优缺点">#</a> 递归的优缺点</h5><p>优点：为某些编程问题提供了最简单的解决方案，缺点是一些递归算法会快速消耗计算机的内存资源 另外递归不方便阅读和维护<br><strong>在程序中使用递归要格外注意 尤其是效率优先的程序</strong></p><h4 id="编译多源代码文件的程序"><a class="markdownIt-Anchor" href="#编译多源代码文件的程序">#</a> 编译多源代码文件的程序</h4><p>使用多个函数最简单的方法是把他们都放在同一个文件中 然后像编译只有一个函数的文件那样编译该文件即可。其他方法因操作系统而异，下面将举例说明.</p><h5 id="unix"><a class="markdownIt-Anchor" href="#unix">#</a> UNIX</h5><p>假设 filel.c 和 file2.c 是两个内涵 C 函数的文件 下面的命令将编译两个文件并生成一个名为 a.out 的可执行文件:<br>cc filel.c file2.c<br> 另外还生成两个名为 file1.o 和 file2.o 的目标文件。如果后来改动了 filel.c 而 file2.c 不变 可以使用以下命令编译第一个文件 并与第二个文件的目标代码合并<br> cc filel.c file2.o</p><h5 id="linux"><a class="markdownIt-Anchor" href="#linux">#</a> Linux</h5><p>假定 linux 系统安装了 GNU C 编译器 GCC 假设 filel.c 和 file2.c 是两个内含 C 函数的文件 下面的命令将编译两个文件并生成名为 a.out 的可执行文件<br> gcc filel.c file2.c<br> 另外还生成两个名为 file1.o 和 file2.o 的目标文件。如果后来改动了 filel.c 而 file2.c 不变 可以使用以下命令编译第一个文件 并与第二个文件的目标代码合并<br> gcc filel.c file2.o</p><h5 id="dos命令行编译器"><a class="markdownIt-Anchor" href="#dos命令行编译器">#</a> DOS 命令行编译器</h5><p>绝大多数 DIS 命令行编译器的工作员刘和 UNIX 的 CC 命令类似 只不过使用不同的名称而已 其中一个区别是 对象文件的扩展名是.obj 而不是.o 一些编译器生成的不是目标代码文件 而是汇编语言或其他特殊代码的中间文件</p><h5 id="windows和苹果的ide编译器"><a class="markdownIt-Anchor" href="#windows和苹果的ide编译器">#</a> windows 和苹果的 IDE 编译器</h5><p>windows 和 Macintosh 系统使用的集成开发环境中的编译器是面向项目的<br>项目 描述的是特定程序使用的资源 (资源包括源代码文件)<br> 这种 IDE 中的编译器要创建项目来运行单文件程序 对于多文件程序 要使用相应的菜单命令 把源代码文件加入到一个项目中 要确保所有的源代码文件都在项目列表中列出 许多 IDE 都不用在项目列表中列出头文件 (扩展名为.h 的文件) 因为项目只管理使用的源代码文件源代码文件中的 #include 指令管理该文件中使用的头文件 但是 Xcode 要在项目中添加头文件</p><h5 id="使用头文件"><a class="markdownIt-Anchor" href="#使用头文件">#</a> 使用头文件</h5><p>如果把 main () 放在第一个文件中 把函数定义放在第二个文件中 那么第一个文件仍然要使用函数原型<br>把函数原型放在头文件中 就不用再每次使用函数文件时都要写出函数的原型</p><h4 id="查找地址-运算符"><a class="markdownIt-Anchor" href="#查找地址-运算符">#</a> 查找地址: &amp; 运算符</h4><p>指针是 C 语言中最重要的概念之一 用于存储变量的地址。前面使用的 scanf () 函数中就是用地址最为参数<br>一元运算符 &amp; 给出变量的存储地址，如果 posh 是变量名那么 &amp; posh 就是变量的地址 可以把地址看做是变量在内存中的位置<br>不同的变量所处的位置是不同的</p><h4 id="更改主调函数中的变量"><a class="markdownIt-Anchor" href="#更改主调函数中的变量">#</a> 更改主调函数中的变量</h4><p>例如要更改两个数 x,y 的位置 简单地 x = y, y = x 并没有作用<br>下面实现简单地交换值得功能</p><blockquote><pre><code>void interchange(int u ,int v ) {int temp;temp = uu = vv = temp}</code></pre></blockquote><p>虽然这个函数表面上实现了交换的功能 但事实上 调用函数输出结果的时候 并不会交换这两个数值<br>因为在 interchange () 传回的变量并不是 main () 中的变量 (局部变量问题：在函数中的变量虽然表面上和 main 中的变量一样 但是实际上这两个变量是完全不同的 存储地址也不一样的两个变量). 因此交换 u 和 v 的值 对 x 和 y 的值没有影响<br>可以使用 return 语句把值传回 main () 比如 在函数末尾加上 return (u), 然后修改 main 中而定调用 x = interchange (x,y) 但是这只能改变 x 的值 return 语句只能把被调函数中的一个值传回主调函数 但是现在要传回两个值 这就需要指针了 下面开始概述指针</p><h4 id="指针简介"><a class="markdownIt-Anchor" href="#指针简介">#</a> 指针简介</h4><p>指针：一个值为内存地址的变量 (或数据对象)<br><strong> 例如:int 类型变量的值为整数 char 类型变量的值为字符 而指针变量的值为地址</strong></p><blockquote><pre><code>ptr = &amp;pooh</code></pre></blockquote><p>其中 表示 ptr"指向"pooh ptr 和 &amp; pooh 的区别是 ptr 是变量 而 &amp;pooh 是常量<br>这样 ptr 的值 就是 pooh 的地址<br>创建指针变量 要先声明指针变量的类型</p><h5 id="间接运算符解引用运算符"><a class="markdownIt-Anchor" href="#间接运算符解引用运算符">#</a> 间接运算符 (解引用运算符) *</h5><p>间接运算符可以找出存储在内存地址下的值<br>注意分清楚 间接运算符 和 二元乘号运算符 虽然他们长得一样</p><blockquote><pre><code>val = *ptrptr = &amp;bhb上面这串代码就相当于是 val = bhb&amp;后跟一个变量名 表示该变量名的地址*后跟一个地址 或者指针名 表示存储在指针指向地址上的值</code></pre></blockquote><h5 id="声明指针"><a class="markdownIt-Anchor" href="#声明指针">#</a> 声明指针</h5><blockquote><pre><code>int * pi         pi是指向int类型变量的指针char * p         p是指向char类型变量的指针float * pf,*pg   pf,pg是指向float类型变量的指针</code></pre></blockquote><p>其中 * 表明声明的变量是一个指针 前面表示指针指向的类型<br> pi 指向的值是 int 类型 pi 本身叫做 指向 int 类型的指针 pi 的值是一个地址</p><h5 id="使用指针在函数间通信"><a class="markdownIt-Anchor" href="#使用指针在函数间通信">#</a> 使用指针在函数间通信</h5><blockquote><pre><code>void interchange(int * u, int * v){int temp;temp = *u;*u = *v;*v = temp;}interchange(&amp;x,&amp;y)</code></pre></blockquote><p>该函数传递的就不是 x 和 y 的值 而是存储 x 和 y 的值的地址<br>函数中的第二个语句表示 把 u 地址中的值给 temp 第三个语句表示把 V 地址中存储的值赋值给 U 这样 U 地址存储的值变成了 V 地址存储的值第四个语句同样</p><h5 id="小结来自c-primer-plus"><a class="markdownIt-Anchor" href="#小结来自c-primer-plus">#</a> 小结 (来自 C primer Plus)</h5><p><a href="https://imgtu.com/i/IlXp9K"><img src="https://z3.ax1x.com/2021/11/07/IlXp9K.jpg" alt="IlXp9K.jpg"></a><br><a href="https://imgtu.com/i/IlOxtx"><img src="https://z3.ax1x.com/2021/11/07/IlOxtx.jpg" alt="IlOxtx.jpg"></a></p><h4 id="关键概念"><a class="markdownIt-Anchor" href="#关键概念">#</a> 关键概念</h4><p>想用 C 编出高效灵活的程序，必须理解函数.<br> 函数是如何把信息从一个函数传递到另一函数 理解函数参数和返回值之间的工作原理<br>明白函数形参和其他局部变量属于函数私有因此 声明在不同函数中的同名变量是完全不同的变量<br>函数无法直接访问在其他函数中的变量 这样限制访问保护了数据的完整性<br>但是 当确实需要在函数中访问另一个函数的数据时 可以把指针作为函数的参数</p><h4 id="本章小结"><a class="markdownIt-Anchor" href="#本章小结">#</a> 本章小结</h4><p>函数使用参数把值传给函数 使用关键字 return 把值返回函数 必须在函数定义和函数原型中指定函数的原型，如果需要在被调函数中修改主调函数的变量，使用地址或指针作为参数<br> ANSI C 提供了函数原型 允许编译器验证函数调用中使用的参数个数和类型是否正确<br> C 函数可以调用本身 即递归 一些编程问题要用递归来解决 但是递归消耗内存多 效率不高 而且费时</p><h3 id="第十章数组和指针"><a class="markdownIt-Anchor" href="#第十章数组和指针">#</a> 第十章数组和指针</h3><h4 id="数组"><a class="markdownIt-Anchor" href="#数组">#</a> 数组</h4><p>数组：数据类型相同的一系列元素组成 通过声明告诉编译器数组中含有多少元素和这些元素的类型</p><blockquote><pre><code>float candy[365];char code[12];int states[50];</code></pre></blockquote><p>方括号中的数组是数组中的元素个数.<br> 访问数组中的元素通过数组索引表示数组中的各元素。数组元素的标号从 0 开始 'candy [0]' 表示 candy 数组的第一个元素</p><h5 id="初始化数组"><a class="markdownIt-Anchor" href="#初始化数组">#</a> 初始化数组</h5><p>标量变量：只存储单个值的变量</p><blockquote><pre><code>int fix = 1 ;</code></pre></blockquote><p>C 语言用新的语法来初始化数组</p><blockquote><pre><code>int power[8] = {1,2,4,6,8,6,4,2}</code></pre></blockquote><p>用以逗号分隔的值列表 (用花括号括起来) 来初始化数组，各值之间用逗号分割.<br> 使用 const 声明数组:<br> 有时需要把数组设置为只读，如此 程序只能从数组中检索值，不能把新值写入数组，此时就应该用 const 声明和初始化数组</p><blockquote><pre><code>const int days[12] = {31,28,31,30,31,30,31,31,30,31,30,31}</code></pre></blockquote><p><strong>使用数组之前必须初始化</strong><br>当初始化列表中的值少于数组元素个数时，编译器会把剩余的元素都初始化为 0, 但是如果不初始化数组，数组中存储的将会是不确定的垃圾值.<br> 但是如果初始化列表中的值多于数组元素个数时候编译器会进行报错<br>如果省略方括号中的数组编译器会根据初始化列表中的项数来确定数组的大小<br>通常使用 sizeof 运算符给出他的运算对象的大小 (单位为字节)</p><blockquote><pre><code>int days[] = {1,2,3};sizeof days[0] 表示数组中第一个元素的字节大小 //这里是4字节 因为一个int类型占据4字节sizeof days 表示数组中所有元素所占的字节大小我们通常使用数组中所有元素所占的字节大小来除以每一个元素的字节大小 得到数组中的元素数目sizeof days / sizeof days[0]</code></pre></blockquote><h5 id="指定初始化器c99"><a class="markdownIt-Anchor" href="#指定初始化器c99">#</a> 指定初始化器 (C99)</h5><p>C99 增加的新特性：指定初始化器 利用该特性可以初始化指定的数组元素</p><blockquote><pre><code>int arr[6] = {[5]=212}; 把arr[5]初始化为212</code></pre></blockquote><p>在初始化一个元素后 未初始化的元素都会被设置为 0<br> 如果初始化器后面有更多的值</p><blockquote><pre><code>[4] = 31,32,33   在days[4]被转化成31后 后面的数组会根据顺序转化 也就是说days[5]=32 以此类推</code></pre></blockquote><p>如果再次初始化元素 最后的初始化将会取代前面的初始化<br>数组中除了指定的初始化元素，其他的将会按照顺序排序</p><blockquote><p>int days [12] = {31,28,[4]=31} 此时 days [0] 就是 31 days [1] 就是 28<br> 如果没有指定元素大小 例如  int days [] = {[1]=2}<br> 此时园一期会把数组的大小设置为足够装得下初始化的值</p></blockquote><h5 id="给数组元素赋值"><a class="markdownIt-Anchor" href="#给数组元素赋值">#</a> 给数组元素赋值</h5><p>AA<br> 声明数组后，可以借助数组下标 (或索引) 给数组元素赋值<br> C 语言中只能使用循环给数组的元素依次赋值 不允许把数组作为一个单元赋给另一个数组<br>只有初始化允许使用花括号列表的形式赋值</p><blockquote><pre><code>int yaks[5];yaks[5] = {1,2,3,4,5};这样赋值是不起作用的</code></pre></blockquote><h5 id="数组边界"><a class="markdownIt-Anchor" href="#数组边界">#</a> 数组边界</h5><p>使用数组时，必须确保下标是有效的值 不能超出边界<br>编译器不会检查数组下标是否使用得当，结果是未定义的</p><h5 id="指定数组的大小"><a class="markdownIt-Anchor" href="#指定数组的大小">#</a> 指定数组的大小</h5><p>声明数组只能在在方括号中使用整型常量表达式 另外表达式的值必须大于 0<br><a href="https://imgtu.com/i/IBGPoQ"><img src="https://z3.ax1x.com/2021/11/12/IBGPoQ.jpg" alt="IBGPoQ.jpg"></a></p><h4 id="多维数组"><a class="markdownIt-Anchor" href="#多维数组">#</a> 多维数组</h4><p>声明:flaot rain [5][12]; //rain 是一个内涵 5 个元素的数组 每个元素的类型都是 float [12]<br> rain 的每个元素本身都是一个内涵 12 个 float 类型值的数组<br>例如:rain [0][0] 表示 rain 中的首个元素数组的首个元素</p><blockquote><pre><code>#include &lt;stdio.h&gt;#define MONTHS 12    // number of months in a year#define YEARS   5    // number of years of dataint main(void){    // initializing rainfall data for 2010 - 2014    const float rain[YEARS][MONTHS] =    {        {4.3,4.3,4.3,3.0,2.0,1.2,0.2,0.2,0.4,2.4,3.5,6.6},        {8.5,8.2,1.2,1.6,2.4,0.0,5.2,0.9,0.3,0.9,1.4,7.3},        {9.1,8.5,6.7,4.3,2.1,0.8,0.2,0.2,1.1,2.3,6.1,8.4},        {7.2,9.9,8.4,3.3,1.2,0.8,0.4,0.0,0.6,1.7,4.3,6.2},        {7.6,5.6,3.8,2.8,3.8,0.2,0.0,0.0,0.0,1.3,2.6,5.2}    };    int year, month;    float subtot, total;        printf(" YEAR    RAINFALL  (inches)\n");    for (year = 0, total = 0; year &lt; YEARS; year++)    {             // for each year, sum rainfall for each month        for (month = 0, subtot = 0; month &lt; MONTHS; month++)            subtot += rain[year][month];        printf("%5d %15.1f\n", 2010 + year, subtot);        total += subtot; // total for all years    }    printf("\nThe yearly average is %.1f inches.\n\n",           total/YEARS);    printf("MONTHLY AVERAGES:\n\n");    printf(" Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct ");    printf(" Nov  Dec\n");        for (month = 0; month &lt; MONTHS; month++)    {             // for each month, sum rainfall over years        for (year = 0, subtot =0; year &lt; YEARS; year++)            subtot += rain[year][month];        printf("%4.1f ", subtot/YEARS);    }    printf("\n");        return 0;}</code></pre></blockquote><p>重点学习数组初始化和计算方案</p><h5 id="初始化二维数组"><a class="markdownIt-Anchor" href="#初始化二维数组">#</a> 初始化二维数组</h5><blockquote><pre><code>sometype arl[5] = {val1,val2,val3,val4,val5}</code></pre></blockquote><p>val1 等是 sometype 类型的值</p><blockquote><pre><code>    const float rain[YEARS][MONTHS] =    {        {4.3,4.3,4.3,3.0,2.0,1.2,0.2,0.2,0.4,2.4,3.5,6.6},        {8.5,8.2,1.2,1.6,2.4,0.0,5.2,0.9,0.3,0.9,1.4,7.3},        {9.1,8.5,6.7,4.3,2.1,0.8,0.2,0.2,1.1,2.3,6.1,8.4},        {7.2,9.9,8.4,3.3,1.2,0.8,0.4,0.0,0.6,1.7,4.3,6.2},        {7.6,5.6,3.8,2.8,3.8,0.2,0.0,0.0,0.0,1.3,2.6,5.2}    };</code></pre></blockquote><p>初始化时候可以省略内部的花括号只需要保存最外部的花括号就行了，前提是每个元素都必须写上 并且数目不足，像这样内外花括号 可以使 元素书小于定义数时 编译器自动以 0 填充<br>如果省略内部花括号 编译器会按照先后顺序逐行初始化 直到用完所有的值，后面没有初始化元素被统一初始化为 0</p><h5 id="其他多维数组"><a class="markdownIt-Anchor" href="#其他多维数组">#</a> 其他多维数组</h5><p>三维数组: int box [10][20][30];<br> 一维数组是一行数据 二维数组是数据表 三维数组是一叠数据表<br>处理几维数组就需要使用到几维嵌套循环</p><h4 id="指针和数组"><a class="markdownIt-Anchor" href="#指针和数组">#</a> 指针和数组</h4><p>系统中 地址按字节编扯，short 类型占用 2 字节等；在 C 中 指针加 1 指的是增加一个存储单元。对数组而言 这意味着 + 1 后的地址是下一个元素的地址；而不是下一个字节的地址 这卆为什么必须声明指针所指对象类型的原因之一 自算计要知道存储对象需要多少字节</p><blockquote><pre><code>dates+2 == &amp;dates[2];*(dates+2) ==dates[2];</code></pre></blockquote><p>** 注意间接运算符 * 的优先级要大于 +** 所以这里必须打括号</p><p>例如数组名是 days   那么 days 也表示数组首元素的地址</p><h4 id="函数数组和指针"><a class="markdownIt-Anchor" href="#函数数组和指针">#</a> 函数，数组和指针</h4><blockquote><pre><code>int sum(int * ar,int n){int i;int total 0;for(i=0;i&lt;n;i++)total +=ar[i] 或者 *( ar + i );return total;}</code></pre></blockquote><p>第一个形参告诉该函数数组的地址和数据类型 第二个形参告诉函数该数组中的元素个数<br>关于函数的形参 还有一点要注意 只有在函数原型或函数定义头中才可以用 int ar [] 来代替 int * ar;<br>int * ar 和 int ar [] 都表示 ar 是一个指向 int 的指针 但是 int ar [] 只能用于声明形式函数但是他可以提醒读者 ar 指向的不仅仅是一个 int 类型值还是一个 int 类型数组的元素<br>函数原型可以省略参数名<br>但是在函数定义中不能省略参数名<br>我们的系统中用 8 字节存储地址 所以指针变量的大小是 8 字节 (其他系统中地址的大小可能不是 8 字节)</p><h5 id="使用指针形参"><a class="markdownIt-Anchor" href="#使用指针形参">#</a> 使用指针形参</h5><p>函数要处理数组必须知道何时开始，何时结束<br>上面 sum 函数用一个整数形参表示待处理元素的元素个数和数据类型 但是这并不是给函数传递必备信息的唯一方法<br>还有一种方法是传递两个指针 第 1 个指针指明数组的开始处 (与前面用法相同), 第 2 个指针指明数组的结束处.</p><blockquote><pre><code>#include &lt;stdio.h&gt;#define SIZE 10int sump(int * start, int * end);int main(void){    int marbles[SIZE] = {20,10,5,39,4,16,19,26,31,20};    long answer;        answer = sump(marbles, marbles + SIZE);    printf("The total number of marbles is %ld.\n", answer);        return 0;}/* use pointer arithmetic   */int sump(int * start, int * end){    int total = 0;        while (start &lt; end)    {        total += *start; // add value to total        start++;         // advance pointer to next element    }        return total;}</code></pre></blockquote><p>指针 start 指向 marbles 数组的首元素 所以赋值表达式 total += *start 把首元素 (20) 加给 total 然后表达式 start++ 递增指针变量 start 使其指向数组的下一个元素 因为 start 是指向 int 的指针 start 递增 1 相当于其值递增 int 类型的大小<br>注意这里 sump () 函数用另一种方法结束加法循环 sump () 函数使用第二个指针 start &lt; end 来结束循环<br> whild 循环的测试条件是一个不相等的关系 所以循环最后处理的一个元素是 end 所指向位置的前一个元素 这意味着 end 指向的位置实际上在数组最后一个元素后面 C 保证在给数组分配空间时 之下宁数组后面第一个位置的指针仍然是有效的指针 这使得 while 循环的测试条件是有效的，因为 start 在循环最后的值是 end<br>answer = sump(marbles, marbles + SIZE);<br> 下标从 0 开始 marbles+SIZE 指向数组末尾的下一个位置 如果 end 指向数组的最后一个元素而不是数组末尾的下个位置 则必须 - 1<br> 这种写法不简洁也不好记 很容易导致标称错误<br> **C 语言虽然保证了 marbles+SIZE 有效 但是对 marbles [SIZE](即存储在该位置上的值) 未作任何保证 所以程序不能访问该位置<br>循环体可以压缩成一行代码 total += *start++;<br>* 和 ++ 的优先级相同 结合律是从右往左 所以 start++ 先求值 然后才是 * start 也就是说 start 先递增后指向 使用后缀形式 start++ 而不是 ++start 意味着先把指针指向位置上的值加到 total 上然后再递增指针切记 (*start)++ 是完全错误的这表示先使用 start 指向的指 然后再递增该值 而不是递增指针 这样指针将一直指向同一个位置 但是在该位置上的值发生了变化 虽然 * start++ 的写法比较常用 但是 *(start++) 这样写更清楚</p><h5 id="指针表示法和数组表示法"><a class="markdownIt-Anchor" href="#指针表示法和数组表示法">#</a> 指针表示法和数组表示法</h5><p>对于 C 语言而言 ar [i\ 和 *(ar + i) 这两个表达式都是等价的无论 ar 是数组名还是指针变量 这两个表达式都没问题 但是只要有当 ar 是指针变量的时候才能使用 arr++ 这样的表达式<br>指针表示法更接近机器语言 因此一些编译器在编译时能生成效率更高的代码</p><h4 id="指针操作"><a class="markdownIt-Anchor" href="#指针操作">#</a> 指针操作</h4><p><strong>赋值</strong>：可以把地址赋给指针 注意地址应该和指针类型兼容 也就是说不能把 double 类型的地址赋给指向 int 的指针至少要避免不明智的类型转换 C99/C11 已经不云讯这样做<br><strong>解引用</strong>:* 运算符给出指针指向地址上存储的值<br><strong>取址</strong>：和所有变量一样指针变量也有自己的地址和值 同样使用 &amp; 给出指针本身的地址<br><strong>指针和整数相加</strong>：可以使用 + 运算符把指针和整数相加 或整数和指针相加 无论哪种情况 整数都会和指针指向类型的大小 (以字节为单位) 相乘然后把结果和初始位置相加 如果相加的结果超出了初始指针指向的数组范围 计算结果则是未定义的 除非正好超过数组末尾第一个位置<br><strong>递增指针</strong>：递增指向数组元素的指针可以让该指针移动至数组的下一个元素，但是指针自己的地址是不会发生变化的毕竟变量不会因为值发生变化就移动位置<br><strong>指针减去一个整数</strong>：大概和加法相同 但是这里和加法不同 <strong>指针必须是第 1 个运算对象 整数是第 2 个运算对象</strong><br><strong>递减指针</strong>：类比递增指针<br><strong>指针求差</strong>：通常求差的两个指针分别指向同一个数组的不同元素，通过计算求出两元素之间的距离 差值的单位和数组类型的单位相同 只要两个指针都指向相同的数组 (或者其中一个指针指向数组后面的第 1 个地址) C 都能保证相减运算有效<br><strong>比较</strong>使用关系运算符可以比较两个指针的值 前提是两个指针都指向相同类型的对象<br><strong> FBI WARNING 注意注意注意注意注意注意注意注意注意注意 FBI WARNING</strong><br> 这里的减法有两种 一个指针减去另一个指针得到一个整数 或者用一个指针减去一个整数得到另一个指针<br>递增递减指针时还要注意一些问题 编译器不会检查指针是否指向数组元素 C 只能保证指向数组任意元素的指针和指向数组后面第一个位置的指针有效。但是如果递增或者递减一个指针后超出了这个范围则是未定义的 另外 可以解引用指向数组任意元素的指针但是即使指针指向数组后面一个位置是有效的也不能保证可以解引用这样的越界指针<br>创建一个指针时 系统只分配了存储指针本身的内存 并未分配存储数据的内存在使用指针之前必须先用已分配的地址初始化它</p><h4 id="处理数组中的数据"><a class="markdownIt-Anchor" href="#处理数组中的数据">#</a> 处理数组中的数据</h4><p>C 通常都按值传递数据 因为这样做可以保证数据的完整性 如果函数使用的是原始数据的副本 就不会意外修改原始数据 但是处理数组的函数通常都需要使用原始数据因此这样的函数可以修改原数组 有时这正是我们需要的<br>然而其他函数并不需要修改数据 这样变成错误就可能会破坏原始数据</p><h5 id="对形式参数使用const"><a class="markdownIt-Anchor" href="#对形式参数使用const">#</a> 对形式参数使用 const</h5><p>ANSI C 提供了一种预防手段 如果函数的意图不是修改数组中的数据内容 那么在函数原型和函数定义中声明形式参数时使用关键字 const<br> 这样如果在函数中不小心使用了错误的表达式使原数组发生了改变，编译器会捕获这个错误并且生成一条错误信息.<br> 使用 const 并不是要求原数组是常量而是该函数在处理数组时将其视为常量不可更改<br>一般而言如果编写的函数不用修改数组 那么在声明数组形参时最好使用 const</p><h5 id="const的其他内容"><a class="markdownIt-Anchor" href="#const的其他内容">#</a> const 的其他内容</h5><p>虽然用 #define 指令可以创建类似功能的符号常量 但是 const 的用法更加灵活 可以创建 const 数组 const 指针和指向 const 的指针<br>指向 const 的指针通常用语函数形参中 表明该函数不会使用指针改变数据<br>把 const 数据或非 const 数据的地址初始化为指向 const 的指针或为其赋值是合法的<br>然后只能把非 const 数据的地址赋给普通指针<br>因此对函数的形参使用 const 不仅能保护数据 还能让函数处理 const 数组<br> C 标准规定使用非 const 标识符改修 const 数据导致的结果是未定义的<br> const 还可以声明并初始化一个<strong>不能指向别处</strong>的指针</p><blockquote><pre><code>double rates[5] = {};double * const pc = rates;pc = &amp;rates[2]; 不逊于 因为该指针不能指向别处</code></pre></blockquote><p>可以用这种指针修改它所指向的值 但是它只能指向初始化时设置的地址</p><blockquote><pre><code>const double * const pc = rates;</code></pre></blockquote><p>在创建指针时使用两次 const 该指针既不能更改他所指向的地址 也不能更改它所指向地址上的值</p><h4 id="指针和多维数组"><a class="markdownIt-Anchor" href="#指针和多维数组">#</a> 指针和多维数组</h4><blockquote><pre><code>int zippo[4][2];  /内涵int数组的数组/</code></pre></blockquote><ol><li>数组名 zippo 是该数组首元素的地址 zippo 的首元素一个内含 2 个 int 值得数组 所以 zippo 是这个内涵两个 int 值的数组的地址</li><li>zippo 是数组首元素的地址 zippo [0] 那么就是数组首元素数组的首元素的值 zippo [0] 是一个占用一个 int 大小对象的地址 而 zippo 是一个占用两个 int 大小对象的地址 由于这个整数和内涵两个整数的数组都开始与同一个地址所以 zippo 和 zippo [0] 的值相同</li><li>给指针或地址加 1 其值会增加对应类型的大小 <strong>在这方面 zippo 和 zippo [0] 不同</strong> 因为 zippo 指向的对象占用了两个 int 大小 而 zippo [0] 指向的的对象只占用一个 int 大小</li><li>在解引用一个指针或在数组名后使用带下标的 [] 运算符，得到解引用对象代表的值 *zippo 代表的是 zippo 首元素的值 而 zippo 首元素的值是一个数组那么这个数组的值就是 zippo 首元素数组的首元素的地址 这样来说 **zippo 和 *&amp;zippo [0][0] 等价简而言之 zippo 是地址的地址，必须解引用两次才能获得原始值 地址的地址 或者指针的指针就是双重间接</li></ol><blockquote><pre><code>#include &lt;stdio.h&gt;int main(void){     int zippo[4][2] = { { 2, 4 }, { 6, 8 }, { 1, 3 }, { 5, 7 } };     printf("   zippo = %p,    zippo + 1 = %p\n",zippo, zippo + 1);     printf("zippo[0] = %p, zippo[0] + 1 = %p\n",zippo[0], zippo[0] + 1);     printf("  *zippo = %p,   *zippo + 1 = %p\n",*zippo, *zippo + 1);     printf("zippo[0][0] = %d\n", zippo[0][0]);     printf("  *zippo[0] = %d\n", *zippo[0]);     printf("    **zippo = %d\n", **zippo);     printf("      zippo[2][1] = %d\n", zippo[2][1]);     printf("*(*(zippo+2) + 1) = %d\n", *(*(zippo + 2) + 1));     return 0;}</code></pre></blockquote><p><strong>完整理解整个程序的输出结果</strong><br>特别注意与 zippo [2][1] 等价的指针表示法是 *(*(zippo+2)+1)<br> 这张视图演示了数组地址 数组内容和指针之间的关系<br><a href="https://imgtu.com/i/Ic4B0s"><img src="https://z3.ax1x.com/2021/11/14/Ic4B0s.png" alt="Ic4B0s.png"></a></p><h5 id="指向多维数组的指针"><a class="markdownIt-Anchor" href="#指向多维数组的指针">#</a> 指向多维数组的指针</h5><blockquote><pre><code>int (*pz) [2]  //表示pz指向一个内含两个int类型值得数组</code></pre></blockquote><p>以上代码把 pz 声明为指向一个数组的指针 该数组含有两个 int 类型值<br><strong>括号的原因是 [] 的优先级高于 *</strong></p><blockquote><pre><code>int * pax[2]   此时pax是一个内涵两个指针元素的数组 每个元素都指向int的指针</code></pre></blockquote><hr><blockquote><pre><code>#include &lt;stdio.h&gt;int main(void){     int zippo[4][2] = { { 2, 4 }, { 6, 8 }, { 1,   &gt;     3 }, { 5, 7 } };     int(*pz)[2];     pz = zippo;     printf("   pz = %p,    pz + 1 = %p\n",    pz,   &gt;     pz + 1);     printf("pz[0] = %p, pz[0] + 1 = %p\n",    pz  &gt;     [0], pz[0] + 1);     printf("  *pz = %p,   *pz + 1 = %p\n",      &gt;     *pz, *pz + 1);     printf("pz[0][0] = %d\n", pz[0][0]);     printf("  *pz[0] = %d\n", *pz[0]);     printf("    **pz = %d\n", **pz);     printf("      pz[2][1] = %d\n", pz[2][1]);     printf("*(*(pz+2) + 1) = %d\n", *(*(pz + 2) +   &gt;     1));     return 0;}</code></pre></blockquote><p>虽然 pz 是一个指针 不是数组名但是也可以用 pz [2][1] 这样的写法 可以用数组表示法或指针表示法来表示一个数组元素 既可以用数组名 也可以用指针名</p><h5 id="指针的兼容性"><a class="markdownIt-Anchor" href="#指针的兼容性">#</a> 指针的兼容性</h5><p>指针之间的赋值比数值类型之间的赋值要严格<br>不用类型转换就可以吧 int 类型的值赋给 double 类型的变量但是两个类型的指针不能这样做</p><blockquote><pre><code>int x = 20;const int y = 23;int * p1 = &amp;x;const int * p2 = &amp;y;const int ** pp2;p1 = p2;        // 不安全 -- 把const指针赋给非const指针p2 = p1;        // 有效 -- 把非const指针赋给const指针pp2 = &amp;p1;      // 不安全 –- 嵌套指针类型赋值</code></pre></blockquote><hr><blockquote><pre><code>int * pt;int (*pa)[3];int ar1[2][3];int ar2[3][2];int **p2;    // 一个指向指针的指针</code></pre></blockquote><hr><blockquote><pre><code>pt = &amp;ar1[0][0];     // 都是指向int的指针pt = ar1[0];         // 都是指向int的指针pt = ar1;            // 无效pa = ar1;            // 都是指向内含3个int类型元素数组的指针pa = ar2;            // 无效p2 = &amp;pt;            // 都是指向int *的指针*p2 = ar2[0];        // 都是指向int的指针p2 = ar2;            // 无效</code></pre></blockquote><p>理解以上的代码</p><h5 id="函数和多维数组"><a class="markdownIt-Anchor" href="#函数和多维数组">#</a> 函数和多维数组</h5><p>编写一个处理二维数组的函数 一种方法是 利用 for 循环把处理一维数组的函数应用到二维数组的每一行</p><blockquote><pre><code>int junk[3][4] = {{2,4,5,8},{3,5,6,9},{12,10,8,6}};int i ,j;int total = 0;for(i=0;i&lt;3;i++) total +=sum(junk[i],4);</code></pre></blockquote><p>junk 是二维数组 那么 junk [i] 就是一堆数组 可将其视为二维数组的一行 sum () 函数计算二维数组的每行的综合 然后 for 循环再把每行的总和加起来<br>这种方法无法记录行和列的信息 用这种方法计算总和  行和列的信息并不重要 但如果每行代表一年 每列代表一个月 就还需要一个函数计算某列的综合 可以通过声明正确的形参变量来完成 以便函数能正确地传递数组</p><blockquote><pre><code>void somefunction(int (*pt)[4]);void somefunction(int pt[][4]);  //当且仅当pt是一个函数的形式参数时可以这样声明</code></pre></blockquote><p>第一个方括号是空的  表示 pt 是一个指针</p><blockquote><pre><code>// array2d.c -- 处理二维数组的函数#include &lt;stdio.h&gt;#define ROWS 3#define COLS 4void sum_rows(int ar[][COLS], int rows);void sum_cols(int [][COLS], int);        // 省略形参名，没问题int sum2d(int(*ar)[COLS], int rows);     // 另一种语法int main(void){     int junk[ROWS][COLS] = {               { 2, 4, 6, 8 },               { 3, 5, 7, 9 },               { 12, 10, 8, 6 }     };     sum_rows(junk, ROWS);     sum_cols(junk, ROWS);     printf("Sum of all elements = %d\n", sum2d(junk, ROWS));     return 0;}void sum_rows(int ar[][COLS], int rows){     int r;     int c;     int tot;     for (r = 0; r &lt; rows; r++)     {          tot = 0;          for (c = 0; c &lt; COLS; c++)               tot += ar[r][c];          printf("row %d: sum = %d\n", r, tot);     }}void sum_cols(int ar[][COLS], int rows){     int r;     int c;     int tot;     for (c = 0; c &lt; COLS; c++)     {          tot = 0;          for (r = 0; r &lt; rows; r++)               tot += ar[r][c];          printf("col %d: sum = %d\n", c, tot);     }}int sum2d(int ar[][COLS], int rows){     int r;     int c;     int tot = 0;     for (r = 0; r &lt; rows; r++)          for (c = 0; c &lt; COLS; c++)               tot += ar[r][c];     return tot;}</code></pre></blockquote><hr><p>输出结果</p><blockquote><pre><code>row 0: sum = 20row 1: sum = 24row 2: sum = 36col 0: sum = 17col 1: sum = 19col 2: sum = 21col 3: sum = 23Sum of all elements = 80</code></pre></blockquote><p>一般而言 声明一个指向 N 维数组的指针时只能省略最左边方括号中的值<br>第一个方括号只用于表示这是一个指针 而其他方括号则用于描述指针所指向数据对象的类型</p><h4 id="变长数组vla"><a class="markdownIt-Anchor" href="#变长数组vla">#</a> 变长数组 (VLA)</h4><p>是否发现上面在处理二维数组的函数中 只把数组的行数作为函数的形参 而列数却内置在函数体内<br>因为 C 规定 数组的位数必须是常量 不能用变量来代替常量<br> C99 新增了变长数组 允许使用变量表示数组的维度</p><blockquote><pre><code>int a = 4;int b = 5;double sales[a][b];  //一个变长数组</code></pre></blockquote><p>变长数组有一些限制 变长数组必须是自动存储类别 这意味着无论在函数中声明还是作为函数形参声明 都不能使用 static 和 extern 存储类别说明符 并且不能在声明中初始化他们<br>变长数组中的变 不是指可以修改已经创建数组的大小 而是 在创建数组时，可以使用变量指定数组的维度<br>声明一个带二维变长数组参数的函数</p><blockquote><pre><code>int sum2d(int row,int cols, int ar [rows][cols])   //有效int sum2d(int ar [rows][cols],int cols, int row)   //无效</code></pre></blockquote><p>因为 row 和 cols 用做第三个形参二维数组 ar 的两个维度 ar 的声明要使用 rows 和 cols 所以在形参列表中必须在声明 ar 之前先声明这两个形参<br> C99/C11 标准规定 可以省略原型中的形参名 但是在这种情况下必须用型号来代替省略的维度</p><blockquote><pre><code>int sum2d(int,int,int ar[*][*]);</code></pre></blockquote><p>函数定义的形参列表中表明的变长数组并未实际创建数组<br>变长数组实际上是一个指针 这说明变长数组形参的函数实际上实在原始数组中处理数组 因此可以修改传入的数组</p><h5 id="const和数组大小"><a class="markdownIt-Anchor" href="#const和数组大小">#</a> const 和数组大小</h5><p>是否可以在声明数组时使用 const 变量？</p><blockquote><pre><code>const int SZ = 80;double ar[SZ];</code></pre></blockquote><p>C99/C11 标准允许在声明变长数组时使用 const 常量 所以该数组的定义必须是声明在块中的自动存储类别数组.</p><h4 id="复合字面量"><a class="markdownIt-Anchor" href="#复合字面量">#</a> 复合字面量</h4><p>字面量是除符号常量外的常量 例如 5 是 int 类型字面量 81.3 是 double 类型字面量 'Y’是 char 类型的字面量 "elephant" 是字符串类型的字面量<br>对于数组 复合字面量类似数组初始化列表 前面是用括号括起来的类型名</p><blockquote><pre><code>int diva[2] = {10,20};   (int [2]){10,20}   //复合自变量</code></pre></blockquote><p>int [2] 就是复合字面量的类型名<br>初始化复合字面量可以省略大小 编译器会自动计算数组当前的元素个数</p><blockquote><pre><code>(int []){50,20,90}</code></pre></blockquote><p>复合字面量是匿名的 所以不能先创建然后再使用他 必须在创建的同意使用他 使用指针记录地址就是一种用法</p><blockquote><pre><code>int * pt1;pt1 = (int [2]){10,20}</code></pre></blockquote><p>该复合字面量的字面常量和上面创建的 diva 数组的字面常量完全相同 复合字面量的类型名也代表首元素的地址<br>还可以把复合字面量作为实际参数传递给带有匹配形式参数的函数</p><blockquote><pre><code>total = sum((int[]){4,4,4,5,5,5},6)</code></pre></blockquote><p>这种用法的好处是 把信息传入函数前不必先创建数组 这是复合字面量的典型用法<br>该用法应用于二维数组或者多维数组</p><blockquote><pre><code>int (*pt2)[4];ptr2 = (int [2][4]) {{1,2,3,-9},{4,5,6,-8}};</code></pre></blockquote><p>演示了如何创建二维 int 数组并存储其地址<br>复合字面量是提供至临时需要的值得一种手段 复合字面量具有块作用域，这意味着一旦离开定义复合字面量的块 程序将无法保证该字面量是否存在 也就是说 复合字面量的定义在最内层的花括号中</p><h4 id="数组关键概念"><a class="markdownIt-Anchor" href="#数组关键概念">#</a> 数组关键概念</h4><p>数组用于存储相同类型的数据。C 把数组看作是派生类型，因为数组是建立在其他类型的基础上。也就是说，无法简单地声明一个数组。在声明数组时必须说明其元素的类型，如 int 类型的数组、float 类型的数组，或其他类型的数组。所谓的其他类型也可以是数组类型，这种情况下，创建的是数组的数组（或称为二维数组）。</p><p>通常编写一个函数来处理数组，这样在特定的函数中解决特定的问题，有助于实现程序的模块化。在把数组名作为实际参数时，传递给函数的不是整个数组，而是数组的地址（因此，函数对应的形式参数是指针）。为了处理数组，函数必须知道从何处开始读取数据和要处理多少个数组元素。数组地址提供了 “地址”，“元素个数” 可以内置在函数中或作为单独的参数传递。第 2 种方法更普遍，因为这样做可以让同一个函数处理不同大小的数组。</p><p>数组和指针的关系密切，同一个操作可以用数组表示法或指针表示法。它们之间的关系允许你在处理数组的函数中使用数组表示法，即使函数的形式参数是一个指针，而不是数组。</p><p>对于传统的 C 数组，必须用常量表达式指明数组的大小，所以数组大小在编译时就已确定。C99/C11 新增了变长数组，可以用变量表示数组大小。这意味着变长数组的大小延迟到程序运行时才确定。</p><h4 id="数组小结"><a class="markdownIt-Anchor" href="#数组小结">#</a> 数组小结</h4><p>数组是一组数据类型相同的元素。数组元素按顺序存储在内存中，通过整数下标（或索引）可以访问各元素。在 C 中，数组首元素的下标是 0，所以对于内含 n 个元素的数组，其最后一个元素的下标是 n-1。作为程序员，要确保使用有效的数组下标，因为编译器和运行的程序都不会检查下标的有效性。<br>声明一个简单的一维数组形式如下：</p><blockquote><pre><code>type name [ size ];</code></pre></blockquote><p>这里，type 是数组中每个元素的数据类型，name 是数组名，size 是数组元素的个数。对于传统的 C 数组，要求 size 是整型常量表达式。但是 C99/C11 允许使用整型非常量表达式。这种情况下的数组被称为变长数组。</p><p>C 把数组名解释为该数组首元素的地址。换言之，数组名与指向该数组首元素的指针等价。概括地说，数组和指针的关系十分密切。如果 ar 是一个数组，那么表达式 ar [i] 和 *(ar+i) 等价。</p><p>对于 C 语言而言，不能把整个数组作为参数传递给函数，但是可以传递数组的地址。然后函数可以使用传入的地址操控原始数组。如果函数没有修改原始数组的意图，应在声明函数的形式参数时使用关键字 const。在被调函数中可以使用数组表示法或指针表示法，无论用哪种表示法，实际上使用的都是指针变量。</p><p>指针加上一个整数或递增指针，指针的值以所指向对象的大小为单位改变。也就是说，如果 pd 指向一个数组的 8 字节 double 类型值，那么 pd 加 1 意味着其值加 8，以便它指向该数组的下一个元素。</p><p>二维数组即是数组的数组。例如，下面声明了一个二维数组：</p><blockquote><pre><code>double sales[5][12];</code></pre></blockquote><p>该数组名为 sales，有 5 个元素（一维数组），每个元素都是一个内含 12 个 double 类型值的数组。第 1 个一维数组是 sales [0]，第 2 个一维数组是 sales [1]，以此类推，每个元素都是内含 12 个 double 类型值的数组。使用第 2 个下标可以访问这些一维数组中的特定元素。例如，sales [2][5] 是 slaes [2] 的第 6 个元素，而 sales [2] 是 sales 的第 3 个元素。</p><p>C 语言传递多维数组的传统方法是把数组名（即数组的地址）传递给类型匹配的指针形参。声明这样的指针形参要指定所有的数组维度，除了第 1 个维度。传递的第 1 个维度通常作为第 2 个参数。例如，为了处理前面声明的 sales 数组，函数原型和函数调用如下：</p><blockquote><pre><code>void display(double ar[][12], int rows);...display(sales, 5);</code></pre></blockquote><p>变长数组提供第 2 种语法，把数组维度作为参数传递。在这种情况下，对应函数原型和函数调用如下：</p><blockquote><pre><code>void display(int rows, int cols, double ar[rows][cols]);...display(5, 12, sales);</code></pre></blockquote><p>虽然上述讨论中使用的是 int 类型的数组和 double 类型的数组，其他类型的数组也是如此。然而，字符串有一些特殊的规则，这是由于其末尾的空字符所致。有了这个空字符，不用传递数组的大小，函数通过检测字符串的末尾也知道在何处停止。我们将在第 11 章中详细介绍。</p><h3 id="第十一章字符串和字符串函数"><a class="markdownIt-Anchor" href="#第十一章字符串和字符串函数">#</a> 第十一章字符串和字符串函数</h3><h4 id="表示字符串和字符串io"><a class="markdownIt-Anchor" href="#表示字符串和字符串io">#</a> 表示字符串和字符串 I/O</h4><p>字符串是以空字符 (\o) 结尾的 char 类型数组</p><blockquote><pre><code>#include &lt;stdio.h&gt;#define MSG "I am a symbolic string constant."#define MAXLENGTH 81int main(void){     char words[MAXLENGTH] = "I am a string in an array.";     const char * pt1 = "Something is pointing at me.";     puts("Here are some strings:");     puts(MSG);     puts(words);     puts(pt1);     words[8] = 'p';     puts(words);     return 0;}</code></pre></blockquote><p>和 printf () 函数相同 puts () 函数也属于 stdio.h 系列的输出 / 输出函数 但是和 printf () 不同的是 puts () 函数只显示字符串 而且自动在显示的字符串末尾加上换行符</p><h5 id="在程序中定义字符串"><a class="markdownIt-Anchor" href="#在程序中定义字符串">#</a> 在程序中定义字符串</h5><h6 id="1字符串字面量字符串常量"><a class="markdownIt-Anchor" href="#1字符串字面量字符串常量">#</a> 1. 字符串字面量 (字符串常量)</h6><p>字符串字面量 (字符串常量): 用双引号括起来的内容 双引号中的字符和编译器自动加入末尾的 \O 字符 都作为字符串存储在内存中<br>从 ANSI C 标准起 如果字符串字面量之间没有间隔 或者用空白字符分隔 C 会将其视为串联起来的字符串常量</p><blockquote><pre><code>char greeting[50] = "Hello,and""how are"  " you"                     "" today!" ;char greeting [50] = "Hello,and how are you today!"</code></pre><blockquote><p>这两行代码是等价的</p></blockquote></blockquote><p>如果要在字符串内部使用双引号 必须要在双引号前面加上一个反斜杠 (\)<br> 字符串常量属于<strong>静态存储类别</strong>，这说明 如果在函数中使用字符串常量 该字符串只会被存储一次 在整个程序的生命周期内存在 即使函数被调用多次 用双引号括起来的内容被视为指向该字符串存储位置的指针。类似于把数组名作为指向该数组位置的指针</p><blockquote><pre><code>#include &lt;stdio.h&gt;int main(void){     printf("%s, %p, %c\n", "We", "are", *"space farers");     return 0;}</code></pre></blockquote><p>% s 打印 We 根据 % p 转换说明打印一个地址 *"space farers" 表示该字符串所指向地址所存储的值 应该是字符串 "space farers" 的首字符</p><h6 id="2字符串数组和初始化"><a class="markdownIt-Anchor" href="#2字符串数组和初始化">#</a> 2. 字符串数组和初始化</h6><p>定义字符串数组时 必须让编译器知道需要多少空间 一种方法是用足够空间的数组 存储字符串</p><blockquote><pre><code>const char m1[40] = "Limit yourself to one line's worth.";</code></pre></blockquote><p>这种形式的初始化比标准的数组初始化形式简单得多</p><blockquote><pre><code>const char m1[40] = { 'L','i', 'm', 'i', 't', ' ', 'y', 'o', 'u', 'r', 's', 'e', 'l',                      'f', ' ', 't', 'o', ' ', 'o', 'n', 'e', ' ','l', 'i', 'n', 'e',                         '\', 's', ' ', 'w', 'o', 'r','t', 'h', '.', '\0'};</code></pre></blockquote><p>注意最后的空字符 没有这个空字符 这就不是一个字符串 而是一个字符数组<br>在指定数组大小时候要确保数组的元素个数至少比字符串长度多 1 (为了容纳空字符) 所有违背使用的元素都被自动化初始为 \0 空字符<br>省略数组初始化声明中的大小编译器会自动计算数组的大小<br>处理字符串的函数通常都不知道数组的大小 这些函数通过查找字符串末尾的空字符确定字符串在何处结束<br>让编译器计算输的的大小只能用在初始化数组时。如果创建一个稍后再填充的数组 就必须在声明时指定大小。声明数组时数组大小 IXUS 是可求值得整数 在 CC 新增变长数组迁 数组的大小必须是整型变量 包括由整型变量组成的表达式</p><p>字符数组名和其他数组名一样 是该数组首元素的地址</p><p>同时还可以使用指针表示法创建字符串</p><blockquote><pre><code>const char * pt1 ="yogmas best";const char ar1[] = "yogmas best";</code></pre></blockquote><p>这两个声明几乎相同<br>以上两个声明表示 pt1 和 ar1 都是该字符串的地址 在这两种情况下 带双引号的字符串本身决定了鱼类给字符串的存储空间 尽管如此 这两种形式并不完全相同</p><h6 id="3数组和指针"><a class="markdownIt-Anchor" href="#3数组和指针">#</a> 3. 数组和指针</h6><p>数组形式和指针形式有一些不同点<br>数组形式：数组形式在计算机的内存中分配一个数组 (每个元素对应一个字符 再加上一个末尾的空字符), 每个元素被初始化为字符串字面量对应的字符.<br> 字符串都作为可执行文件的一部分存储在数据段中 当把程序载入内存时 也载入了了程序中的字符串 字符串存储在静态存储区中<br>程序在开始运行时 才为该数组分配内存 此时 才将字符串拷贝到数组中<br>此时字符串有两个副本 一个是在静态内存中的字符串字面量 另一个是存储在数组中的字符串<br>编译器把数组名识别为该数组首元素地址的别名 这以为着在数组形式中数组名是字符常量 不能更改 如果改变了就意味着改变了数组的存储位置 可以进行类似 ar1+1 这样的操作 表示数组的下一个元素 但是不允许进行 ++ar1 这样的操作 递增运算符只能用于变量名前</p><p>指针形式：指针形式是的编译器为字符串在静态存储区预留 29 个元素的空间 另外一旦开始执行程序 他会为<strong>指针变量</strong>留出一个存储位置 并把字符串的地址存储在指针变量中 该变量最初指向该字符串的首字符但是它的值可以改变 因此可以使用递增运算符<br><strong>字符串字面量被视为 const 数据</strong></p><h5 id="指针和字符串"><a class="markdownIt-Anchor" href="#指针和字符串">#</a> 指针和字符串</h5><p>字符串的绝大多数操作都是通过指针完成的</p><blockquote><pre><code>#include &lt;stdio.h&gt;int main(void){     const char * mesg = "Don't be a fool!";     const char * copy;     copy = mesg;     printf("%s\n", copy);     printf("mesg = %s; &amp;mesg = %p; value = %p\n", mesg, &amp;mesg, mesg);     printf("copy = %s; &amp;copy = %p; value = %p\n", copy, &amp;copy, copy);     return 0;}</code></pre><p>如果编译器不识别 % p 用 % u 或者 % lu 来代替<br>字符串形式输出用 % s 转换说明<br>因为最后 mesg 和 copy 指针输出的值是一样的 即两个指针指向地址是一样的 这说明程序并未拷贝字符串 copy=mesg 仅仅把 mesg 的值即 mesg 存储的地址赋值给 copy 让 copy 也指向这一个地址<br>不拷贝整个字符串的原因是因为这样做更具有效率 如果一定要拷贝字符串可以使用 **strcpy () 和 strncpy ()** 函数，后续会介绍这两个函数</p></blockquote><h4 id="字符串输入"><a class="markdownIt-Anchor" href="#字符串输入">#</a> 字符串输入</h4><p>如果想把一个字符串读入程序 首先必须预留存储该字符串的空间 然后用输入函数获取该字符串</p><h5 id="分配空间"><a class="markdownIt-Anchor" href="#分配空间">#</a> 分配空间</h5><p>分配空间的时候必须为字符串分配足够的空间 <strong>不要指望计算机在读取字符串的时候顺便计算它的长度然后再分配空间</strong> (计算机不会这样做 除非你编写一个处理这些任务的函数)</p><blockquote><pre><code>char * name;scanf("%s",name);</code></pre></blockquote><p>可能会通过编译 但是在读入 name 时 name 可能会擦写掉程序中的数据或代码 而导致程序异常终止<br>因为 scanf () 要把信息拷贝到参数指定的地址上 此时 该参数是个未初始化的指针 name 可能会指向任何地方</p><ul><li>最简单的方法是 在声明时指明数组的大小</li></ul><blockquote><pre><code>char name[81];</code></pre></blockquote><ul><li>还有一种方法：使用 C 库函数来分配内存 (第 12 章)</li></ul><p>为字符串分配玩内存后 开始讨论读取字符串的函数</p><h5 id="gets函数不幸"><a class="markdownIt-Anchor" href="#gets函数不幸">#</a> gets () 函数–不幸</h5><p>在读取字符串时，scanf () 和转换说明 % s 只能读取一个单词<br>程序中经常要读取一整行输入 gets () 函数就用于处理这种情况</p><ul><li>get () 函数读取整行输入 直到遇到换行符 然后丢弃换行符 存储其余字符 并在这些字符的末尾添加一个空字符使其称为一个 C 字符串 其经常和 puts () 函数配对使用</li><li>puts () 函数用于显示字符串 并且在末尾添加换行符</li></ul><blockquote><pre><code>#include &lt;stdio.h&gt;#define STLEN 81int main(void){     char words[STLEN];     puts("Enter a string, please.");     gets(words);  // 典型用法     printf("Your string twice:\n");     printf("%s\n", words);     puts(words);     puts("Done.");     return 0;}</code></pre></blockquote><p>整行输入都被存储在 words 中 put () 和 printf () 的效果相同<br>但是在有些编译器中并不会输出正确的结果，并且会给出警告<br> gets () 的唯一参数是 words, 他无法检查数组是否装得下输入行.<br> 数组名仅仅是数组首元素的地址。因此，gets () 函数只知道数组的开始处 并不知道数组中有多少个元素</p><p>如果输入的字符过长 会导致<strong>缓冲区溢出</strong>即多余的字符超出了指定的目标空间 如果这些多于的字符只是占用了<strong>尚未使用</strong>的内存就不会立即出现问题 如果他们擦写掉程序中的其他数据就会导致程序异常中止<br><em>在过去有些人通过系统编程 利用 gets () 插入和运行一些破坏系统安全的代码</em><br> C99 中承认了 gets () 的问题并且建议不要使用它 尽管如此 现有程序中因为含有大量使用该函数的代码 所以在标准中保留了 gets ()<br> C11 直接从标准中废除了 gets () 函数<br>所以这就导致了有些编译器支持 gets () 函数而有些编译器不支持 gets () 函数<br>部分编译器为了兼容以前的代码 就继续支持 gets () 函数</p><h5 id="gets的替代品"><a class="markdownIt-Anchor" href="#gets的替代品">#</a> gets () 的替代品</h5><p>过去尝尝用 fgets () 来代替 gets (),fgets () 函数稍微复杂些 在处理输入方面与 gets () 略有不同 C11 标准新增的 gets_s () 也可以代替 gets () 该函数与 gets () 函数更为接近 但是 它是 stdio.h 输入 / 输出函数系列中的可选拓展 所以编译器不一定支持它</p><h6 id="fgets函数和fputs"><a class="markdownIt-Anchor" href="#fgets函数和fputs">#</a> fgets () 函数和 (fputs)</h6><p>fgets () 函数通过第 2 个参数限制读入的字符数来解决溢出的问题<br><strong>该函数专门设计处理文件输入</strong>一般情况下可能不太好用<br> fgets () 与 gets () 的区别如下</p><ul><li>fgets () 函数的第 2 个参数指明了读入字符的最大数量，如果该参数是 n 那么 fgets () 函数将读入 n-1 个字符 或者读到遇到的第一个换行符为止</li><li>如果 fgets () 读到一个换行符，会把它存储在字符串中 这点和 gets () 不同，gets () 会丢地换行符</li><li>fgets () 函数的第三个参数执行要读入的文件 如果读入从键盘输入的数据 则以 **stdin (标准输入)<strong> 作为参数 该标识符定义在 stdio.h 中<br>因为 fgets () 函数把换行符放在字符串的末尾 (假设输入行不溢出) 通常要与 fputs () 配对使用，除非该函数不在字符串末尾添加换行符 fputs () 的第 2 个参数指明它要写入的文件 如果要显示在计算机显示器上，应使用</strong> stdout (标准输出)** 作为参数</li></ul><blockquote><pre><code>#include &lt;stdio.h&gt;#define STLEN 14int main(void){     char words[STLEN];     puts("Enter a string, please.");     fgets(words, STLEN, stdin);     printf("Your string twice (puts(), then fputs()):\n");     puts(words);     fputs(words, stdout);     puts("Enter another string, please.");     fgets(words, STLEN, stdin);     printf("Your string twice (puts(), then fputs()):\n");     puts(words);     fputs(words, stdout);     puts("Done.");     return 0;}</code></pre></blockquote><p>输入案例</p><blockquote><pre><code>Enter a string, please.apple pieYour string twice (puts(), then fputs()):apple pieapple pieEnter another string, please.strawberry shortcakeYour string twice (puts(), then fputs()):strawberry shstrawberry shDone.</code></pre></blockquote><ul><li>第一行输入 apple pie 比 fgets () 读入的整行输入短 因此 apple pie 被存储在数组中 所以当 puts () 显示该字符串时又在末尾添加了换行符 因此 apple pie 后面有一行空行 因为 fputs () 不在字符串末尾添加换行符 所以并未打印出空行</li><li>第二行输入 的字符超过了大小的限制 所以只会读入相应的字符 然后把前几个范围内的存储在数组中<br><strong> puts () 函数会在待输入字符串末尾添加一个换行符 而 fputs () 不会这样做</strong><br><strong>同样 fgets () 存储时会在末尾自动存储一个换行符 而 gets () 不会这样</strong></li></ul><p>fgets () 函数返回 char 的指针 该函数返回的地址与传入的一个参数相同 如果读到文件末尾将返回<strong>空指针</strong>该指针保证不会指向有效的数据 所以可用于表述特殊情况 在 C 语言中用宏 NULL 来代替 (如果读入数据错误 该函数也返回 NULL).</p><p>下列函数演示了一个简单的循环 读入并显示用户输入的内容 直到 fgets () 读到文件末尾或空行 (首字符是换行符)</p><blockquote><pre><code>#include &lt;stdio.h&gt;#define STLEN 10int main(void){     char words[STLEN];     puts("Enter strings (empty line to quit):");     while (fgets(words, STLEN, stdin) != NULL &amp;&amp; words[0] != '\n')          fputs(words, stdout);     puts("Done.");     return 0;}</code></pre></blockquote><p>输出结果如下</p><blockquote><pre><code>Enter strings (empty line to quit):By the way, the gets() functionBy the way, the gets() functionalso returns a null pointer if italso returns a null pointer if itencounters end-of-file.encounters end-of-file.Done.</code></pre></blockquote><p>神奇的是 这个程序在处理过长的输入时完全没有问题<br>通过 while 循环每次读入 9 个字符 (虽然 STLEN 为 10 但是最后一个位置需要留给 \0) 并且没有换行由此不断叠加<br><strong> important</strong> 系统使用缓冲的 I/O 用户按 enter 键之前 输入都被存储在缓冲区中 按下 enter 键就在输入中增加了一个换行符 并且把整行输入发送给 fgets () 对出输出 fputs () 把字符发送给另一个缓冲区 当发送换行符时 缓冲区的内容被发送到屏幕上<br> fgets () 存储换行符有好有坏</p><ul><li>好处：对于存储的字符串而言 检查末尾是否有换行符可以判断是否读取了一整行</li><li>坏处：可能编者本身并不想把换行符存储在字符串中 这样的换行符会带来一些麻烦</li></ul><p>存储的字符串 如果不是一整行 要妥善处理一行中剩下的字符</p><p>如何处理掉换行符呢</p><ul><li>在已存储的字符串中查找换行符 并将其替换成空字符</li></ul><blockquote><pre><code>while (words[i] != '\n') // 假设\n在words中     i++;words[i] = '\0';</code></pre></blockquote><ul><li>如果仍然有字符串留在输入行怎么办，如果目标数组装不下一整行输入就丢弃多出的字符</li></ul><blockquote><pre><code>while (getchar() != '\n')    // 读取但不存储输入，包括\ncontinue;</code></pre></blockquote><p>以下程序读取输入航 删除存储在字符串中的换行符  如果没有换行符 就丢弃数组装不下的字符</p><blockquote><pre><code>#include &lt;stdio.h&gt;#define STLEN 10int main(void){     char words[STLEN];     int i;     puts("Enter strings (empty line to quit):");     while (fgets(words, STLEN, stdin) != NULL &amp;&amp; words[0] != '\n')     {          i = 0;          while (words[i] != '\n' &amp;&amp; words[i] != '\0')               i++;          if (words[i] == '\n')               words[i] = '\0';          else    // 如果word[i] == '\0'则执行这部分代码               while (getchar() != '\n')                     continue;          puts(words);     }     puts("done");     return 0;}</code></pre></blockquote><p>遍历字符串 直到遇到换行符或者空字符 如果先遇到换行符 就替换成空字符 如果先遇到空字符 else 部分就丢弃输入行的剩余字符</p><h6 id="gets_s函数"><a class="markdownIt-Anchor" href="#gets_s函数">#</a> gets_s () 函数</h6><p>和 fgets () 函数类似 用一个参数限制读入的字符数目</p><p>区别如下:</p><ul><li>gets_s () 只从标准输入中读取数据 不需要第三个参数</li><li>gets_s 读到换行符会丢弃换行符而不是存储</li><li>如果 gets_s 读到最大字符数都没有读到换行符 他会先把数组中的首字符设置成空字符 读取然后丢弃随后的输入 知道读到换行符 然后返回空指针 接着调用 "处理函数" (可能会终止或者退出程序)</li></ul><p>如果输入行未超过最大字符数目 gets_s () 和 gets () 相同</p><p>如果目标存储区装得下输入行 以上函数效果都一样</p><p>如果输入行太长会怎样</p><ul><li>使用 gets () 会擦写现有数据 具有安全隐患</li><li>gets_s () 很安全 但是如果不希望程序终止或者退出 就要知道如何编写 "处理函数" 如果让程序继续运行 gets_s 会丢弃该输入行的其余字符</li><li>fgets () 综合了以上两个 可以自由选择 是截取丢弃 还是继续使用输入行中超出的字符 可以参考以上 fgets () 中两个程序的处理方法</li></ul><h6 id="s_gets函数"><a class="markdownIt-Anchor" href="#s_gets函数">#</a> s_gets () 函数</h6><p>fgets () 函数的一种语法 读取郑航输入并用空字符代替换行符 或者读取一部分输入 并丢弃其余部分 然而并没有处理这种情况的标准 C 库函数<br>所以我们就创建一个 或许在后面的程序中会用得上</p><blockquote><pre><code>char * s_gets(char * st, int n){     char * ret_val;     int i = 0;     ret_val = fgets(st, n, stdin);     if (ret_val)    // 即，ret_val != NULL     {          while (st[i] != '\n' &amp;&amp; st[i] != '\0')               i++;          if (st[i] == '\n')               st[i] = '\0';          else&lt;ins&gt;&lt;/ins&gt;               while (getchar() != '\n')                     continue;     }     return ret_val;}</code></pre></blockquote><p>如果 fgets () 返回 NULL，说明读到文件结尾或出现读取错误，s_gets () 函数跳过了这个过程。它模仿上面处理 fgets () 函数的的处理方法，如果字符串中出现换行符，就用空字符替换它；如果字符串中出现空字符，就丢弃该输入行的其余字符，然后返回与 fgets () 相同的值。我们在后面的示例中将讨论 fgets () 函数。</p><p>为什么要丢弃过长输入行中的余下字符。<br>这是因为，输入行中多出来的字符会被留在缓冲区中，成为下一次读取语句的输入。<br>例如，如果下一条读取语句要读取的是 double 类型的值，就可能导致程序崩溃。丢弃输入行余下的字符保证了读取语句与键盘输入同步。</p><p>s_gets () 函数并不完美，它最严重的缺陷是遇到不合适的输入时毫无反应。它丢弃多余的字符时，既不通知程序也不告知用户。但是，用来替换前面程序示例中的 gets () 足够了。</p><h6 id="空字符和空指针"><a class="markdownIt-Anchor" href="#空字符和空指针">#</a> 空字符和空指针</h6><ul><li><p>空字符 (\0) 用于标记 C 字符串末尾的字符 对应字符编码为 0 由于其他字符的编码不可能为 0 所以空字符不可能是字符串的一部分</p></li><li><p>空指针 (NULL) 有一个值 该值不会与任何数据的有效地址对应.</p></li><li><p>空指针是整数类型 空指针是指针类型 空字符是一个字符占 1 字节 空指针是一个地址 占 4 字节</p></li></ul><h5 id="scanf函数-2"><a class="markdownIt-Anchor" href="#scanf函数-2">#</a> scanf () 函数</h5><p>前面用 scanf () 和 % s 来读取字符串<br> scanf () 和 gets () 以及 fgets () 的区别在于他们如何确定字符串的末尾</p><ul><li><p>scanf () 更像是在 "获取单词" 而不是在 "获取字符串"</p></li><li><p>如果预留区装得下输入航 gets () 和 fgets () 会读取第一个换行符之前所有的字符</p></li></ul><p>scanf () 有两种方法确定输入结束，但是都是从第一个非空白字符作为字符的开始</p><ul><li>使用 % s 转换说明 以下一个空白字符 (空行 空格 制表符 换行符) 作为字符串的结束 (<strong>空白字符不存储在字符串中</strong>)</li><li>如果指定了字符串的长度 如 %8s 那么 scanf () 将读取 8 个字符 或者读到空白符位置</li></ul><p><a href="https://imgtu.com/i/oFcCd0"><img src="https://z3.ax1x.com/2021/11/25/oFcCd0.png" alt="oFcCd0.png"></a></p><p>scanf () 函数返回一个整数值 该值等于 scanf () 成功读取的项数 或者 EOF (读到文件末尾)</p><blockquote><pre><code>#include &lt;stdio.h&gt;int main(void){     char name1[11], name2[11];     int count;     printf("Please enter 2 names.\n");     count = scanf("%5s %10s", name1, name2);     printf("I read the %d names %s and %s.\n", count, name1, name2);     return 0}</code></pre></blockquote><p>输入示例</p><blockquote><p>Please enter 2 names.<br>Jesse Jukes<br>I read the 2 names Jesse and Jukes.  // 都未超出字段宽度<br> Please enter 2 names.<br>Liza Applebottham<br>I read the 2 names Liza and Applebotth.  // 第二个超出了字段宽度 自动截取了<br> Please enter 2 names.<br>Portensia Callowit<br>I read the 2 names Porte and nsia.   先读取了 5 个字符 (第一次调用 scanf ()) 然后又读取了 4 字符 (第二次调用 scanf () 从上一次调用结束的地方继续读取数据)</p></blockquote><p>根据输入数据的性质 用 scanf () 读取键盘输入的数据 有时并不合适<br> scanf () 无法完整地读入书名或者歌曲名 除非这些名称是一个单词<br> scanf () 的典型用法：读取并转换混合数据类型为某种标准形式<br> scanf () 缺点：输入行过长也会导致数据溢出<br>解决方法：在 % s 转换说明中限制字段宽度</p><h4 id="字符串输出"><a class="markdownIt-Anchor" href="#字符串输出">#</a> 字符串输出</h4><p>C 中 3 个用于打印字符串的标准库函数</p><ol><li>puts()</li><li>fputs()</li><li>printf()</li></ol><h5 id="puts函数"><a class="markdownIt-Anchor" href="#puts函数">#</a> puts () 函数</h5><p>puts () 函数会在末尾自动添加一个换行符</p><blockquote><pre><code>#include &lt;stdio.h&gt;#define DEF "I am a #defined string."int main(void){     char str1[80] = "An array was initialized to me.";     const char * str2 = "A pointer was initialized to me.";     puts("I'm an argument to puts().");     puts(DEF);     puts(str1);     puts(str2);     puts(&amp;str1[5]);  //puts后面需要跟的是一个地址 字符串的起始地址     puts(str2 + 4);     return 0;}</code></pre></blockquote><p>输出如下</p><blockquote><p>I’m an argument to puts().<br>I am a #defined string.<br>An array was initialized to me.<br>A pointer was initialized to me.<br>ray was initialized to me.<br>inter was initialized to me.</p></blockquote><p>puts 遇到空字符就停止输入 所以必须却要有空字符<br>如果缺少空字符他会一直打印内存后面中的内容 直到读到空字符的位置为止</p><h5 id="fputs函数"><a class="markdownIt-Anchor" href="#fputs函数">#</a> fputs () 函数</h5><p>与 puts () 函数的区别如下</p><ul><li>fputs () 的第二个参数指明要写入数据的文件 如果要打印在显示器上 用定义在 stdio.h 中的 stdout (标准输出) 作为该参数</li><li>fputs () 不会在输出的末尾添加换行符 而 puts () 会</li></ul><p>与前面的输入函数关联起来 也就是前面提过的<br><strong> puts () 函数会在待输入字符串末尾添加一个换行符 而 fputs () 不会这样做</strong><br><strong>同样 fgets () 存储时会在末尾自动存储一个换行符 而 gets () 不会这样</strong></p><p>不推荐使用 gets () 因为已经废弃了  学习 gets () 只是以防以后看到 gets () 代码看不懂</p><h5 id="printf函数-2"><a class="markdownIt-Anchor" href="#printf函数-2">#</a> printf () 函数</h5><p>printf () 把字符串的地址作为参数<br> printf () 不是那么方便 但是它可以格式化不同的数据类型</p><blockquote><pre><code>printf("%s \n",string)puts(string); 这两个语句的效果是相同的</code></pre></blockquote><h4 id="自定义输入输出函数"><a class="markdownIt-Anchor" href="#自定义输入输出函数">#</a> 自定义输入 / 输出函数</h4><p>以下是一个 类似 puts 但是不会就自动添加换行符的函数</p><blockquote><pre><code>#include &lt;stdio.h&gt;void put1(const char * string)/* 不会改变字符串 */{     while (*string != '\0')          putchar(*string++);}</code></pre></blockquote><p>因为从右向左运算 *string++ 中递增是 string 本身而不是递增它所指向的字符</p><p>很多 C 程序员在 whild 中会使用下面的测试条件</p><blockquote><pre><code>while (*string) 若*string是空字符 则为0 循环结束 这种方法风场渐变</code></pre></blockquote><p>以下将打印一串字符串 并且 统计打印的字符个数</p><blockquote><pre><code> int put2(const char * string) {      int count = 0;      while (*string)    /* 常规用法 */      {           putchar(*string++);           count++;      }      putchar('\n');    /* 不统计换行符 */       return(count); }</code></pre></blockquote><p>具体的程序使用</p><blockquote><pre><code>#include &lt;stdio.h&gt;void put1(const char *);int put2(const char *);int main(void){     put1("If I'd as much money");     put1(" as I could spend,\n");     printf("I count %d characters.\n",          put2("I never would cry old chairs to mend."));     return 0;}void put1(const char * string){     while (*string)  /* 与 *string != '\0' 相同 */          putchar(*string++);}int put2(const char * string){     int count = 0;     while (*string)     {          putchar(*string++);          count++;     }     putchar('\n');     return(count);}</code></pre></blockquote><h4 id="字符串函数"><a class="markdownIt-Anchor" href="#字符串函数">#</a> 字符串函数</h4><p>C 库中有多个处理字符串的函数 ANSI C 放在了 string.h 头文件中</p><h5 id="strlen-函数"><a class="markdownIt-Anchor" href="#strlen-函数">#</a> strlen () 函数</h5><p>strlen () 函数用于统计字符串的长度<br>以下函数用于缩短字符串的长度</p><blockquote><pre><code>void fit(char *string, unsigned int size){     if (strlen(string) &gt; size)         string[size] = '\0';}</code></pre></blockquote><h5 id="strcat函数"><a class="markdownIt-Anchor" href="#strcat函数">#</a> strcat () 函数</h5><p>strcat () 用于拼接字符串<br>函数接受两个字符串作为参数 该函数是把第二个字符串的备份附加在第一个字符串末尾 然后把拼接后形成的新字符串作为第一个字符串 第二个字符串不发生改变<br> strcat () 的类型是指向 char 的指针 返回的值是第一个字符串的地址</p><h5 id="strncat函数"><a class="markdownIt-Anchor" href="#strncat函数">#</a> strncat () 函数</h5><p>strcat () 无法检查第一个数组 是否能够容纳第 2 个字符串 如果第一个数组的空间不够大 拼接的时候就会出现问题<br> strncat () 的第三个参数制定了最大添加字符数</p><blockquote><pre><code>strncat(bugs,addon,13)</code></pre></blockquote><p>在加到第 13 个字符或者空字符的时候就停止<br> strncat () 和 gets () 一样也会导致缓冲区溢出 但是并没有废弃</p><h5 id="strcmp函数"><a class="markdownIt-Anchor" href="#strcmp函数">#</a> strcmp () 函数</h5><p>strcmp 用于字符串的比较<br>如果两个字符串参数相同 函数就返回 0 否则返回非 0 数<br><strong>注意</strong><br> strcmp () 比较的是字符串不是整个数组 即使数组很大 strcmp () 也只会比较数组中存储的字符串 也就是第一个空字符前面的字符串</p><h6 id="1strcmp的返回值"><a class="markdownIt-Anchor" href="#1strcmp的返回值">#</a> 1.strcmp () 的返回值</h6><ul><li>如果第一个字符串在第二个字符串前面 strcmp () 返回一个负数</li><li>如果两个字符串相同 则返回 0</li><li>如果第一个字符串在第二个字符串后面 strcmp () 返回一个正数</li></ul><p>比较过程中 strcmp () 会依次比较每个字符 知道发现第一对不同的字符为止 然后返回相应的值</p><p>strcmp () 与其说是比较字符串 不如说是根据 ASCII 的值 按照<strong>机器排序序列</strong>进行比较</p><p><strong>注意</strong> strcmp () 比较的是字符串而不是字符 也就是说即使要比较单个字符 也应该写成 "A" 而不是’A’<br>实际上因为 char 类型实际上是 int 类型 所以比较字符时 也不需要使用到 strcmp () 函数</p><h6 id="strncmp函数"><a class="markdownIt-Anchor" href="#strncmp函数">#</a> strncmp () 函数</h6><ul><li>strcmp () 比较字符串中的字符 这一过程会持续到直到发现不同</li><li>strncmp () 在比较两个字符串时 可以限定函数只比较哪几个字符 这样可以用来查找哪个字母 或者开头 结尾 相同的单词</li></ul><blockquote><pre><code>strncmp("transform","transparent",5)</code></pre></blockquote><p>此时函数就只会比较前面 5 个字符 并且输出的结果是 0 因为前 5 个字符 trans 相同</p><h5 id="strcpy和strncpy函数"><a class="markdownIt-Anchor" href="#strcpy和strncpy函数">#</a> strcpy () 和 strncpy () 函数</h5><p>如何希望拷贝整个字符串就用 strcpy ()<br> strcpy () 函数相当于<strong>字符串赋值运算符</strong></p><p>strcpy () 第二个参数 指向的字符串被拷贝至第一个参数指向的数组中</p><ul><li>拷贝出来的字符串被称为<strong>目标字符串</strong></li><li>最初的字符串被称为<strong>源字符串</strong></li></ul><p>如果拷贝到的数组没有被初始化 这时候可能被拷贝到任意地方</p><h6 id="strcpy的其他属性"><a class="markdownIt-Anchor" href="#strcpy的其他属性">#</a> strcpy () 的其他属性</h6><ul><li>strcpy () 的返回类型是 char * 该函数返回第一个字符的地址</li><li>第一个参数不必指向数组的开始</li></ul><h6 id="更谨慎的选择-strncpy"><a class="markdownIt-Anchor" href="#更谨慎的选择-strncpy">#</a> 更谨慎的选择: strncpy ()</h6><p>strcpy () 不能检查目标空间是否能容纳源字符串的副本<br> strncpy () 的第三个参数指明可拷贝的最大字符数</p><blockquote><pre><code>strncpy(target,source,n)</code></pre><p>把 source 中的 n 个字符或者空字符之前的字符拷贝到 target 中<br> strncpy () 拷贝字符串的长度不会超过 n<br><strong> 如果拷贝到底 n 还没有拷贝完整个字符串 就不会拷贝空字符</strong><br>如此写程序的时候可以用 if else 语句 把拷贝过去的字符串最后一个转化为空字符 以保证存储的是一个字符串</p></blockquote><h6 id="sprintf函数"><a class="markdownIt-Anchor" href="#sprintf函数">#</a> sprintf () 函数</h6><p>sprintf 函数声明在 stdio.h 中<br>该函数和 printf 类似 但是是把数据写入字符串 而不是打印在电脑屏幕上</p><ul><li>sprintf () 的第一个参数是目标字符串的地址</li><li>其他参数和 printf () 相同</li></ul><blockquote><pre><code>sprintf(formal,"    ",X,Y,Z)</code></pre><p>表示法 X,Y,Z 拼接成一个字符串并且存储在 formal 中</p></blockquote><h5 id="其他字符串函数"><a class="markdownIt-Anchor" href="#其他字符串函数">#</a> 其他字符串函数</h5><p>对以上函数 和一些常用函数的总结</p><blockquote><p>char *strcpy (char* restrict s1, const char * restrict s2);<br> 该函数把 s2 指向的字符串（包括空字符）拷贝至 s1 指向的位置，返回值是 s1。<br>char*strncpy(char * restrict s1, const char * restrict s2, size_t n);<br> 该函数把 s2 指向的字符串拷贝至 s1 指向的位置，拷贝的字符数不超过 n，其返回值是 s1。该函数不会拷贝空字符后面的字符，如果源字符串的字符少于 n 个，目标字符串就以拷贝的空字符结尾；如果源字符串有 n 个或超过 n 个字符，就不拷贝空字符。<br>char *strcat(char * restrict s1, const char * restrict s2);<br> 该函数把 s2 指向的字符串拷贝至 s1 指向的字符串末尾。s2 字符串的第 1 个字符将覆盖 s1 字符串末尾的空字符。该函数返回 s1。<br>char *strncat(char * restrict s1, const char * restrict s2, size_t n);<br> 该函数把 s2 字符串中的 n 个字符拷贝至 s1 字符串末尾。s2 字符串的第 1 个字符将覆盖 s1 字符串末尾的空字符。不会拷贝 s2 字符串中空字符和其后的字符，并在拷贝字符的末尾添加一个空字符。该函数返回 s1。<br>int strcmp(const char * s1, const char * s2);<br> 如果 s1 字符串在机器排序序列中位于 s2 字符串的后面，该函数返回一个正数；如果两个字符串相等，则返回 0；如果 s1 字符串在机器排序序列中位于 s2 字符串的前面，则返回一个负数。<br>int strncmp(const char * s1, const char * s2, size_t n);<br> 该函数的作用和 strcmp () 类似，不同的是，该函数在比较 n 个字符后或遇到第 1 个空字符时停止比较。<br>char *strchr(const char * s, int c);<br> 如果 s 字符串中包含 c 字符，该函数返回指向 s 字符串首次出现的 c 字符的指针（末尾的空字符也是字符串的一部分，所以在查找范围内）；如果在字符串 s 中未找到 c 字符，该函数则返回空指针。<br>char *strpbrk(const char * s1, const char * s2);<br> 如果 s1 字符中包含 s2 字符串中的任意字符，该函数返回指向 s1 字符串首位置的指针；如果在 s1 字符串中未找到任何 s2 字符串中的字符，则返回空字符。<br>char *strrchr(const char * s, char c);<br> 该函数返回 s 字符串中 c 字符的最后一次出现的位置（末尾的空字符也是字符串的一部分，所以在查找范围内）。如果未找到 c 字符，则返回空指针。<br>char *strstr(const char * s1, const char * s2);<br> 该函数返回指向 s1 字符串中 s2 字符串出现的首位置。如果在 s1 中没有找到 s2，则返回空指针。<br>size_t strlen(const char * s);<br> 该函数返回 s 字符串中的字符数，不包括末尾的空字符。<br>请注意，那些使用 const 关键字的函数原型表明，函数不会更改字符串。例如，下面的函数原型：<br>char *strcpy(char * restrict s1, const char * restrict s2);<br> 表明不能更改 s2 指向的字符串，至少不能在 strcpy () 函数中更改。但是可以更改 s1 指向的字符串。这样做很合理，因为 s1 是目标字符串，要改变，而 s2 是源字符串，不能更改。</p><p>关键字 restrict 将在第 12 章中介绍，该关键字限制了函数参数的用法。例如，不能把字符串拷贝给本身。</p><p>第 5 章中讨论过，size_t 类型是 sizeof 运算符返回的类型。C 规定 sizeof 运算符返回一个整数类型，但是并未指定是哪种整数类型，所以 size_t 在一个系统中可以是 unsigned int，而在另一个系统中可以是 unsigned long。string.h 头文件针对特定系统定义了 size_t，或者参考其他有 size_t 定义的头文件。</p><p>前面提到过，参考资料 V 中列出了 string.h 系列的所有函数。除提供 ANSI 标准要求的函数外，许多实现还提供一些其他函数。应查看你所使用的 C 实现文档，了解可以使用哪些函数。</p></blockquote><h4 id="字符串示例字符串排序"><a class="markdownIt-Anchor" href="#字符串示例字符串排序">#</a> 字符串示例：字符串排序</h4><blockquote><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define SIZE 81        /* 限制字符串长度，包括 \0 */#define LIM 20         /* 可读入的最多行数 */#define HALT ""        /* 空字符串停止输入 */void stsrt(char *strings [], int num);    /* 字符串排序函数 */char * s_gets(char * st, int n);int main(void){     char input[LIM][SIZE];       /* 存储输入的数组        */     char *ptstr[LIM];            /* 内含指针变量的数组    */     int ct = 0;                  /* 输入计数             */     int k;                       /* 输出计数             */     printf("Input up to %d lines, and I will sort them.\n", LIM);     printf("To stop, press the Enter key at a line's start.\n");     while (ct &lt; LIM &amp;&amp; s_gets(input[ct], SIZE) != NULL               &amp;&amp; input[ct][0] != '\0')     {          ptstr[ct] = input[ct];  /* 设置指针指向字符串    */          ct++;     }     stsrt(ptstr, ct);            /* 字符串排序函数        */     puts("\nHere's the sorted list:\n");     for (k = 0; k &lt; ct; k++)          puts(ptstr[k]);         /* 排序后的指针          */     return 0;}/* 字符串-指针-排序函数 */void stsrt(char *strings [], int num){     char *temp;     int top, seek;     for (top = 0; top &lt; num - 1; top++)          for (seek = top + 1; seek &lt; num; seek++)               if (strcmp(strings[top], strings[seek]) &gt; 0)               {                    temp = strings[top];                    strings[top] = strings[seek];                    strings[seek] = temp;               }}char * s_gets(char * st, int n){     char * ret_val;     int i = 0;     ret_val = fgets(st, n, stdin);     if (ret_val)     {          while (st[i] != '\n' &amp;&amp; st[i] != '\0')               i++;          if (st[i] == '\n')               st[i] = '\0';          else                while (getchar() != '\n')                       continue;     }     return ret_val;}</code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Html-first</title>
      <link href="/2021/11/06/html-shang/"/>
      <url>/2021/11/06/html-shang/</url>
      
        <content type="html"><![CDATA[<h1 id="html上"><a class="markdownIt-Anchor" href="#html上">#</a> Html (上)</h1><h3 id="the-article-from-yogmas-also-sam"><a class="markdownIt-Anchor" href="#the-article-from-yogmas-also-sam">#</a> the article from yogmas also sam</h3><h4 id="1基本架构"><a class="markdownIt-Anchor" href="#1基本架构">#</a> 1. 基本架构</h4><blockquote><pre><code>&lt;html&gt; &lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; </code></pre></blockquote><h4 id="2html标签"><a class="markdownIt-Anchor" href="#2html标签">#</a> 2.html 标签</h4><h6 id="标题标签"><a class="markdownIt-Anchor" href="#标题标签">#</a> 标题标签</h6><blockquote><pre><code>&lt;h1&gt;&lt;/h1&gt;   ……  &lt;h6&gt;&lt;/h6&gt;</code></pre></blockquote><p>一共六级标题，文字加粗，由大到小依次减小。<br><strong>大多数标签都是成对存在的，只有少数例如 br 的单标签</strong></p><h6 id="段落和换行标签"><a class="markdownIt-Anchor" href="#段落和换行标签">#</a> 段落和换行标签</h6><blockquote><pre><code>&lt;p&gt;&lt;/p&gt;&lt;/br&gt;</code></pre></blockquote><p>p 标签会自动换行，不用添加 br</p><h6 id="文本格式化标签"><a class="markdownIt-Anchor" href="#文本格式化标签">#</a> 文本格式化标签</h6><blockquote><pre><code>&lt;strong&gt;加粗&lt;/strong&gt; 或者 &lt;b&gt;加粗&lt;/b&gt;&lt;em&gt;倾斜&lt;/em&gt; 或者 &lt;i&gt;倾斜&lt;/i&gt;&lt;del&gt;删除线&lt;/del&gt; 或者 &lt;s&gt;删除线&lt;/s&gt;&lt;ins&gt;下划线&lt;/ins&gt; 或者 &lt;u&gt;下划线&lt;/u&gt;</code></pre></blockquote><h6 id="div和span标签"><a class="markdownIt-Anchor" href="#div和span标签">#</a> div 和 span 标签</h6><blockquote><pre><code>&lt;span&gt;&lt;/span&gt;</code></pre></blockquote><p>形象来说 div 是一个大盒子，span 通常是用来放在大盒子里面的小盒子（后期 div 在页面构造中非常常用)</p><h6 id="图像标签"><a class="markdownIt-Anchor" href="#图像标签">#</a> 图像标签</h6><blockquote><pre><code>&lt;img src="路径" alt="图片不显示时显示出来的" title="鼠标放在图片上面显示出来的文字" width="" height="" border=""&gt;</code></pre></blockquote><p>在后期使用的 width,height,border, 都会放入<strong> css</strong> 中来运行使用不会单独列入 img 中<br>图像标签的路径<br> 1. 同一级路径<br> eg:(img.jpg)<br> 2. 下一级路径<br> eg:(images/img.jpg)<br> 3. 绝对路径<br> eg:(C:\Users\apple\Desktop\ 前端基础第一天 - HTML\ 案例 \img.jpg)<br>eg：(<a href="http://www.itcast.cn/2018czgw/images/logo.png">http://www.itcast.cn/2018czgw/images/logo.png</a>)<br><a href="https://imgtu.com/i/IQmLi8"><img src="https://z3.ax1x.com/2021/11/06/IQmLi8.png" alt="IQmLi8.png"></a></p><h6 id="超链接标签"><a class="markdownIt-Anchor" href="#超链接标签">#</a> 超链接标签</h6><blockquote><pre><code>&lt;a href="链接"&gt;LOL&lt;/a&gt;</code></pre><p>LOL 可以以图片文字等等代替，点击就可以跳转到 href 所在的链接</p></blockquote><p>可以添加的元素：target=“X”<br>X 包括_self (覆盖当前页面)<br> 和_blank 重新启动新的页面<br>链接分类<br> 1. 内部链接：存放在你网站前端的链接也就是你写前端时电脑里面的链接<br> 2. 外部链接：例如 http 这类的其他网站的链接<br> 3. 空链接：当你还没有链接可以填时，留出空位用 #代替<br> 4. 下载链接：通常是以.zip 结尾的压缩包<br><a href="https://imgtu.com/i/IQC8kd"><img src="https://z3.ax1x.com/2021/11/06/IQC8kd.png" alt="IQC8kd.png"></a></p><h6 id="锚点定位"><a class="markdownIt-Anchor" href="#锚点定位">#</a> 锚点定位</h6><p>由两个相互呼应的标签组成<br>可以从页面的一个地方跳转到当前页面的另外一个地方</p><blockquote><pre><code>&lt;a href="#ID"&gt;&lt;/a&gt;&lt;h3 id="ID"&gt;</code></pre></blockquote><p>ID 可以写成任何你定义的名称<br> h3 并不是固定的，可以换成任意标签<br>当你点击 a 中携带的元素或标签时你将会跳转到拥有 id=“” 且和 a 相同 id 的标签这</p><h6 id="注释标签和特殊字符"><a class="markdownIt-Anchor" href="#注释标签和特殊字符">#</a> 注释标签和特殊字符</h6><blockquote><pre><code>&lt;!-- 注释内容 --&gt; &lt;用&amp;lt  &gt;用&amp;gt；(由于&lt;&gt;符号在html中的特殊性)</code></pre></blockquote><p>特殊内容可以用 ctrl+l 快速注释</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Html-second</title>
      <link href="/2021/11/06/html-xia/"/>
      <url>/2021/11/06/html-xia/</url>
      
        <content type="html"><![CDATA[<p>。</p><h1 id="html下"><a class="markdownIt-Anchor" href="#html下">#</a> Html (下)</h1><h3 id="the-article-from-yogmas-also-sam"><a class="markdownIt-Anchor" href="#the-article-from-yogmas-also-sam">#</a> the article from yogmas also sam</h3><h4 id="1表格"><a class="markdownIt-Anchor" href="#1表格">#</a> 1. 表格</h4><h6 id="表格基本语法"><a class="markdownIt-Anchor" href="#表格基本语法">#</a> 表格基本语法</h6><blockquote><pre><code>&lt;table&gt;  &lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;/tr&gt;  &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</code></pre></blockquote><h6 id="表头单元格标签"><a class="markdownIt-Anchor" href="#表头单元格标签">#</a> 表头单元格标签</h6><blockquote><p>align=""<br>border=""<br>cellpadding=""<br>cellspacing=""<br>width=""<br>height=""<br><strong> 这些标签要写到 table 里面去</strong></p></blockquote><p>align: 表格中的文字所处的文字 eg.center 就是未于中间类似的还有 left,right<br>border：表示表格边框的大小 0 表示没有 <strong>此属性的参数值是数字</strong><br> cellpadding：代表单元格边框到内容之间的距离（留白）<br>cellspacing：用来指定表格各单元格之间的空隙。<strong>此属性的参数值是数字</strong>，表示单元格间隙所占的像素点数。<br>同样 width,height 已经介绍过了 ，大多数时候都会用<strong> CSS</strong> 来写</p><h6 id="合并单元格"><a class="markdownIt-Anchor" href="#合并单元格">#</a> 合并单元格</h6><blockquote><p>rowspan=“合并单元格数目”<br>colspan=“合并单元格数目”</p></blockquote><p>rowspan: 合并行 (也就是将一列上的各行合并)<br> colspan: 合并列 (也就是将一行上的各列合并)<br> 合并准则：如果 rowspan 就在最上面的表格的标签里面加上 rowspan="合并数目" 并且删除已经被合并的表格<br> colspan 同理，注意 colspan 加在最左边的表格标签<br> eg.</p><blockquote><pre><code>  &lt;tr&gt;     &lt;td&gt;&lt;/td&gt;      &lt;td colspan="2"&gt;&lt;/td&gt;  &lt;/tr&gt;</code></pre></blockquote><p>表示合并一行上的 2 列 第三列删除 colspan 写在第二列的 td 表格标签内</p><h4 id="2列表"><a class="markdownIt-Anchor" href="#2列表">#</a> 2. 列表</h4><h6 id="无序列表"><a class="markdownIt-Anchor" href="#无序列表">#</a> 无序列表</h6><blockquote><pre><code>&lt;ul&gt;  &lt;li&gt;&lt;/li&gt;    …………  &lt;li&gt;&lt;/li&gt;  &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;</code></pre></blockquote><p>其中的 li 标签各位根据需要而定<br> ul:unorderlist<br>li:list</p><h6 id="有序列表"><a class="markdownIt-Anchor" href="#有序列表">#</a> 有序列表</h6><blockquote><pre><code>&lt;ol&gt;  &lt;li&gt;&lt;/li&gt;    …………  &lt;li&gt;&lt;/li&gt;&lt;/ol&gt;</code></pre></blockquote><p>ol:orderlist<br>li:list</p><h6 id="自定义列表"><a class="markdownIt-Anchor" href="#自定义列表">#</a> 自定义列表</h6><blockquote><pre><code> &lt;dl&gt;   &lt;dt&gt;&lt;/dt&gt;顶部总标签   &lt;dd&gt;&lt;/dd&gt;   &lt;dt&gt;&lt;/dt&gt;   &lt;dd&gt;&lt;/dd &lt;/dl&gt; 一个&lt;dt&gt;和&lt;/dt&gt;标签出现代表一列 直到下一个&lt;dt&gt;和&lt;/dt&gt;出现才换列</code></pre></blockquote><h4 id="3表单"><a class="markdownIt-Anchor" href="#3表单">#</a> 3. 表单</h4><h6 id="表单域"><a class="markdownIt-Anchor" href="#表单域">#</a> 表单域</h6><blockquote><pre><code>&lt;form action="" method="" name=""&gt;&lt;/form&gt;</code></pre></blockquote><p>表单域需要与后端结合使用只是接下来的一系列需要传输数据到后端的都需要写到表单域内<br>附：此时作者还不知道表单域的 action 等标签充当的角色和用处</p><h6 id="input表单元素"><a class="markdownIt-Anchor" href="#input表单元素">#</a> input 表单元素</h6><blockquote><pre><code>&lt;input type="" value="" name="" &gt;</code></pre></blockquote><p><a href="https://imgtu.com/i/IJqbX8"><img src="https://z3.ax1x.com/2021/11/09/IJqbX8.png" alt="IJqbX8.png"></a><br>type 里面可以填写的元素<br> text: 文本框，用户可以输入任何文字，但可以用 maxlength 等来加以限定<br> password：密码框，可以对你输入的数字进行保密 此时显示 *******<br>radio: 单选按钮</p><blockquote><p>将两个 input+radio 元素的标签 name 设置成相同 才可以进行单选 具体下面看图</p></blockquote><p>checkbox: 复选框，可以进行多个选择<br> submit: 提交按钮，点击可以将数据提交给后端<br> reset: 重新填写<br> button: 点击  例如：获取短信验证码需要使用</p><p>与 type 同等级的元素作用<br> value：提前显示在文本框内的文字<br> name：传送给后端时的数据名称，radio 只有 name 相同才能单选<br><a href="https://imgtu.com/i/IQmXRg"><img src="https://z3.ax1x.com/2021/11/06/IQmXRg.png" alt="IQmXRg.png"></a></p><h6 id="label标签"><a class="markdownIt-Anchor" href="#label标签">#</a> label 标签</h6><p>点击添加了 label 标签的元素等于点击 label 标签的输出端</p><blockquote><pre><code>&lt;label for="XXX"&gt; &lt;/label&gt;&lt;input type="" id="XXX"&gt;</code></pre></blockquote><p>并不一定要是 input 只是在 input 等填写数据中较为广泛地使用，xxx 可以换成任何自己命名的单词字母等<br> for 和 id 中填写的必须相同</p><h6 id="select下拉表单"><a class="markdownIt-Anchor" href="#select下拉表单">#</a> select 下拉表单</h6><blockquote><pre><code>&lt;select&gt;&lt;option&gt;&lt;/option&gt;&lt;option selected="selected"&gt; &lt;/potion&gt;&lt;/select&gt;</code></pre></blockquote><p>option 标签中间填写下拉菜单中的文字等<br>添加了 selected 元素的表示 未下拉时显示在表面的选项</p><h6 id="textarea文本域"><a class="markdownIt-Anchor" href="#textarea文本域">#</a> textarea 文本域</h6><blockquote><pre><code>&lt;textarea cols="" rows=""&gt;&lt;/textarea&gt;</code></pre></blockquote><p>文本域通常很大所以用 cols 和 rows 来进行限定<br> cols 限定一行的字数 rows 限定行数<br>在后期的学习中可以用<strong> css</strong> 将文本域的右下角拉伸和上下滑动进行去除，增加美观性</p><h4 id="4html5新增"><a class="markdownIt-Anchor" href="#4html5新增">#</a> 4.html5 新增</h4><h6 id="语义化标签"><a class="markdownIt-Anchor" href="#语义化标签">#</a> 语义化标签</h6><blockquote><pre><code>&lt;header&gt;头部标签&lt;/header&gt;&lt;nav&gt;导航栏标签&lt;/nav&gt;   &lt;section&gt;某个区域&lt;/section&gt;</code></pre></blockquote><h6 id="视频标签"><a class="markdownIt-Anchor" href="#视频标签">#</a> 视频标签</h6><blockquote><pre><code>&lt;video src="" autoplay=""muted="muted"  loop="loop" poster="media/mi9.jpg"&gt;</code></pre></blockquote><p>src: 路径<br> autoplay: 写入 autoplay 代表自动播放<br> mute: 播放时静音<br> loop: 预先加载<br> poster: 播放还没有加载出来的时候显示的图片<br> controls: 是否显示控制按钮</p><h6 id="音频标签"><a class="markdownIt-Anchor" href="#音频标签">#</a> 音频标签</h6><blockquote><pre><code>&lt;audio src="media/music.mp3" autoplay="autoplay" controls="controls"&gt;&lt;/audio&gt;</code></pre></blockquote><p>与视频标签相差无几</p><h6 id="input表单"><a class="markdownIt-Anchor" href="#input表单">#</a> input 表单</h6><p><a href="https://imgtu.com/i/IJqLnS"><img src="https://z3.ax1x.com/2021/11/09/IJqLnS.png" alt="IJqLnS.png"></a></p><h6 id="表单属性"><a class="markdownIt-Anchor" href="#表单属性">#</a> 表单属性</h6><blockquote><pre><code>&lt;input type="search" name="sear" id="" required="required" placeholder="pink老师" autofocus="autofocus" autocomplete="off"&gt;</code></pre></blockquote><pre><code> &lt;input type="file" name="" id="" multiple="multiple"&gt;</code></pre><p>required: 需要填写才能点确定<br> placeholder: 还没有填写时候显示的文字<br> autofocus: 打开网页时，指标会自动点一下这里<br> autocomplete: 自动储存你输入过的信息 (容易暴露信息，所以一般都会关闭)<br> multiple: 可以选取多个文件</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Css-first</title>
      <link href="/2021/11/06/css1/"/>
      <url>/2021/11/06/css1/</url>
      
        <content type="html"><![CDATA[<h1 id="css1"><a class="markdownIt-Anchor" href="#css1">#</a> css1</h1><h3 id="the-article-from-yogmas-also-sam"><a class="markdownIt-Anchor" href="#the-article-from-yogmas-also-sam">#</a> the article from yogmas also sam</h3><h4 id="1css基本架构"><a class="markdownIt-Anchor" href="#1css基本架构">#</a> 1.css 基本架构</h4><blockquote><pre><code>&lt;html&gt; &lt;head&gt;&lt;style&gt;&lt;/style&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;/html&gt; style为css放置位置</code></pre></blockquote><p>前期学习先将 css 放置在 html 文件夹里面后期会单独利用 css 文件来写 css</p><h4 id="2选择器"><a class="markdownIt-Anchor" href="#2选择器">#</a> 2. 选择器</h4><h6 id="标签选择器"><a class="markdownIt-Anchor" href="#标签选择器">#</a> 标签选择器</h6><blockquote><p>选择器 {样式}<br> 给谁改样式 {改什么样式}<br>eg.p { color: red;<br>font-size: 12px; }</p></blockquote><p>标签选择器为大类选择，同一类标签全部都会被 css 修改</p><h6 id="类选择器"><a class="markdownIt-Anchor" href="#类选择器">#</a> 类选择器</h6><blockquote><pre><code>.id {} eg .red {color:red;}&lt;# class="id"&gt;  &lt;/#&gt;</code></pre></blockquote><p>这里的 ID 还需要与 html 中的 class 相互匹配 #可以替换成任何你想选择的类别 id 可以替换成任何你命名的字母或者单词<br><strong>类选择器口诀：样式点定义  结构类 (class) 调用  一个或多个 开发最常用</strong><br><a href="https://imgtu.com/i/IQmbIf"><img src="https://z3.ax1x.com/2021/11/06/IQmbIf.png" alt="IQmbIf.png"></a><br> 同时类选择器可以有多个 ID 都会起作用 中间用空格隔开 例如<br><a href="https://imgtu.com/i/IQmHdP"><img src="https://z3.ax1x.com/2021/11/06/IQmHdP.png" alt="IQmHdP.png"></a></p><h6 id="id选择器"><a class="markdownIt-Anchor" href="#id选择器">#</a> id 选择器</h6><p>id 选择器与类选择器相似，不过 ID 选择器只能使用一次 并且一个 ID 只能调用一次</p><blockquote><pre><code>#ID {}&lt;XX id=""&gt;  &lt;/XX&gt;</code></pre></blockquote><h6 id="通配符选择器"><a class="markdownIt-Anchor" href="#通配符选择器">#</a> 通配符选择器</h6><blockquote><pre><code>* { }</code></pre></blockquote><p>通配符 简而言之就是对所有元素和类都有作用，后期主要用来先去除掉浏览器自身所带的一些 css 属性方便我们后续进行 css 操作</p><h4 id="3css字体属性"><a class="markdownIt-Anchor" href="#3css字体属性">#</a> 3.CSS 字体属性</h4><p><a href="https://imgtu.com/i/IQmjzQ"><img src="https://z3.ax1x.com/2021/11/06/IQmjzQ.png" alt="IQmjzQ.png"></a></p><h6 id="字体系列"><a class="markdownIt-Anchor" href="#字体系列">#</a> 字体系列</h6><blockquote><p>font-family:’   ';</p></blockquote><p>通常会根据团队的要求来确定书写的字体 一般来说是微软雅黑也就是 microsoft YaHei 当然也可以有其他的一系列字体<br>比如在后期的<strong>字体图标</strong>中就需要修改 font-family</p><h6 id="字体大小"><a class="markdownIt-Anchor" href="#字体大小">#</a> 字体大小</h6><blockquote><p>font-size:;</p></blockquote><p>顾名思义，是修改字体的大小，不过需要注意的是这后面不能跟单独的数字 这样是没有效果的 需要跟单位 px</p><h6 id="字体粗细"><a class="markdownIt-Anchor" href="#字体粗细">#</a> 字体粗细</h6><blockquote><p>font-weight:  ;</p></blockquote><p>这里需要谨记 2 个数字<br> 700: 加粗<br> 400: 正常大小<br> font-weight 后面跟数字，可以根据需要来进行调整 不过一般都是 700 和 400 之间切换</p><h6 id="文字样式风格"><a class="markdownIt-Anchor" href="#文字样式风格">#</a> 文字样式风格</h6><blockquote><p>font-style: ;</p></blockquote><p>一般运用的都 italic (倾斜) 和 normal (正常) 两种<br>实际运用场景：<br>1. 用来修改需要倾斜的汉字<br> 2. 当没有标签可用时，可以用 em 倾斜标签先将汉字包括，在通过 font-style:normal；将倾斜属性去掉</p><h6 id="字体复合属性"><a class="markdownIt-Anchor" href="#字体复合属性">#</a> 字体复合属性</h6><p>通过简写的方式来节约代码 (不过有顺序要求)</p><blockquote><pre><code>font: font-style  font-weight  font-size/line-height  font-family;eg:font: italic 700 16px 'Microsoft yahei'; 前面两个可以省略，但是后面连个一定要写</code></pre></blockquote><h4 id="4文本外观属性"><a class="markdownIt-Anchor" href="#4文本外观属性">#</a> 4. 文本外观属性</h4><p><a href="https://imgtu.com/i/IQn9Zq"><img src="https://z3.ax1x.com/2021/11/06/IQn9Zq.png" alt="IQn9Zq.png"></a></p><h6 id="颜色"><a class="markdownIt-Anchor" href="#颜色">#</a> 颜色</h6><blockquote><pre><code>color: "</code></pre></blockquote><p>这里 color 后面所带有 4 种写法<br> 1. 直接加颜色例如 red,blue<br>2. 加颜色编号，主要这里 #必须加例如 #123456 (常用) 后期通常会用吸色笔 然后负值颜色编号<br> 3.rgb (X,X,X) 三色的搭配<br> 4.rgba (X,X,X,G) 这个主要是用来设置颜色的透明度 G 取值从 0~1<br> 用来设置颜色的透明度</p><h6 id="文字对齐"><a class="markdownIt-Anchor" href="#文字对齐">#</a> 文字对齐</h6><blockquote><p>text-align: ;</p></blockquote><p>设置文字的对齐方式，<br>left,center,right</p><h6 id="装饰文本"><a class="markdownIt-Anchor" href="#装饰文本">#</a> 装饰文本</h6><blockquote><pre><code>text-deroration: ;</code></pre></blockquote><p>可加元素:<br>line-through 删除线<br> overline 上划线<br><strong> none</strong> (常用) 通常用来配合通配符选择器来取消 a 的下划线</p><h6 id="文本缩进"><a class="markdownIt-Anchor" href="#文本缩进">#</a> 文本缩进</h6><blockquote><p>text-indent: ;</p></blockquote><p>后面添加数据时需要注意单位 用像素 (px) 或者 em (一个汉字所占的大小)</p><h6 id="行间距"><a class="markdownIt-Anchor" href="#行间距">#</a> 行间距</h6><blockquote><p>line-height: ;</p></blockquote><p>也需要加 px<br> 后期通常使 line-height 和 height 相等，来使文字垂直对齐</p><h4 id="5style样式表"><a class="markdownIt-Anchor" href="#5style样式表">#</a> 5.style 样式表</h4><h6 id="内部样式表"><a class="markdownIt-Anchor" href="#内部样式表">#</a> 内部样式表</h6><p>也就是我们最开始介绍，直到现在一直在使用的加到 style 里面的 css 属性</p><h6 id="行内样式表"><a class="markdownIt-Anchor" href="#行内样式表">#</a> 行内样式表</h6><p>直接加在 html 标签中的样式表</p><blockquote><pre><code> 例如: &lt;div style="";&gt; &lt;/div&gt; 不常使用，会使html标签显得臃肿</code></pre></blockquote><h6 id="外部样式表"><a class="markdownIt-Anchor" href="#外部样式表">#</a> 外部样式表</h6><blockquote><pre><code>&lt;link rel=""; href="文件地址";&gt;</code></pre></blockquote><p>另建一个.css 文件，在另外一个文件中书写 css 属性<br>再通过在 style 中书写 link 将其引入</p><h4 id="6vscode中使用emmet语法快速书写代码"><a class="markdownIt-Anchor" href="#6vscode中使用emmet语法快速书写代码">#</a> 6.vscode 中使用 emmet 语法快速书写代码</h4><p><a href="https://imgtu.com/i/IQnSLn"><img src="https://z3.ax1x.com/2021/11/06/IQnSLn.png" alt="IQnSLn.png"></a></p><h4 id="7选择器拓展"><a class="markdownIt-Anchor" href="#7选择器拓展">#</a> 7. 选择器拓展</h4><p><a href="https://imgtu.com/i/IQnZQJ"><img src="https://z3.ax1x.com/2021/11/06/IQnZQJ.png" alt="IQnZQJ.png"></a></p><h6 id="后代选择器"><a class="markdownIt-Anchor" href="#后代选择器">#</a> 后代选择器</h6><p>顾名思义就是将大元素中包括的小元素提取出来，这里通过列子来展示<br><a href="https://imgtu.com/i/IQnCd0"><img src="https://z3.ax1x.com/2021/11/06/IQnCd0.png" alt="IQnCd0.png"></a></p><h6 id="子元素选择器"><a class="markdownIt-Anchor" href="#子元素选择器">#</a> 子元素选择器</h6><p>例如上面的 ol li 变成 ol&gt;li 就只对 ol 中的下一级 li 有用也就是他的儿子，而他的下下级，也就是孙子则不起作用</p><h6 id="并集选择器"><a class="markdownIt-Anchor" href="#并集选择器">#</a> 并集选择器</h6><p>在标签和标签中间用逗号连接，这样就可以达到同时对两个盒子都起作用的效果</p><blockquote><p>例如 div,p,li {}</p></blockquote><p>需要注意的是最后一个选择器不需要加逗号</p><h6 id="链接伪类选择器"><a class="markdownIt-Anchor" href="#链接伪类选择器">#</a> 链接伪类选择器</h6><p><a href="https://imgtu.com/i/IJqEWt"><img src="https://z3.ax1x.com/2021/11/09/IJqEWt.png" alt="IJqEWt.png"></a></p><blockquote><p>X:GGGG {}</p></blockquote><p>X 可以是你的选择器中的任何<br>：后面可以添加 4 中元素 (其中 hover 最经常使用)：<br>link: 未访问链接：把没有点击过的链接选择出来<br> visited: 访问过的链接，把点击过的链接选择出来<br> hover: 当鼠标经过时<br> active: 鼠标点击但是还未弹起来时<br><a href="https://imgtu.com/i/IQmxMj"><img src="https://z3.ax1x.com/2021/11/06/IQmxMj.png" alt="IQmxMj.png"></a></p><h6 id="focus选择器"><a class="markdownIt-Anchor" href="#focus选择器">#</a> focus 选择器</h6><p>把获得光标的 input 选择显示出来<br>下面是代码，可以通过自己运行来进行查看<br><a href="https://imgtu.com/i/IQnPoV"><img src="https://z3.ax1x.com/2021/11/06/IQnPoV.png" alt="IQnPoV.png"></a></p><h4 id="8元素显示模式"><a class="markdownIt-Anchor" href="#8元素显示模式">#</a> 8. 元素显示模式</h4><p><a href="https://imgtu.com/i/IJqmy8"><img src="https://z3.ax1x.com/2021/11/09/IJqmy8.png" alt="IJqmy8.png"></a></p><h6 id="块级元素"><a class="markdownIt-Anchor" href="#块级元素">#</a> 块级元素</h6><p><a href="https://imgtu.com/i/IQnkJU"><img src="https://z3.ax1x.com/2021/11/06/IQnkJU.png" alt="IQnkJU.png"></a></p><h6 id="行内元素"><a class="markdownIt-Anchor" href="#行内元素">#</a> 行内元素</h6><p><a href="https://imgtu.com/i/IQnAWF"><img src="https://z3.ax1x.com/2021/11/06/IQnAWF.png" alt="IQnAWF.png"></a></p><h6 id="行内块元素"><a class="markdownIt-Anchor" href="#行内块元素">#</a> 行内块元素</h6><p>特殊情况，同时具有块级元素和行内元素的特点，可以进行的大小设置，也可以书写汉字，但是大小会随着汉字的多少而改变</p><h6 id="元素显示模式转换"><a class="markdownIt-Anchor" href="#元素显示模式转换">#</a> 元素显示模式转换</h6><blockquote><pre><code> display:   ;</code></pre></blockquote><p>inline: 行内元素<br> block: 块级元素<br> inline-block: 行内块元素<br><strong>学到这里去做一下小米侧边栏试试吧</strong></p><h6 id="单行文字垂直居中"><a class="markdownIt-Anchor" href="#单行文字垂直居中">#</a> 单行文字垂直居中</h6><p>也就是上面和大家提及过的，这里让 height 和 line-height 相同即可</p><h4 id="9背景"><a class="markdownIt-Anchor" href="#9背景">#</a> 9. 背景</h4><p><a href="https://imgtu.com/i/IQ6dHA"><img src="https://z3.ax1x.com/2021/11/06/IQ6dHA.png" alt="IQ6dHA.png"></a></p><h6 id="背景颜色"><a class="markdownIt-Anchor" href="#背景颜色">#</a> 背景颜色</h6><blockquote><p>background-color: ;</p></blockquote><p>后面的元素参照前面 color 属性</p><h6 id="背景图片"><a class="markdownIt-Anchor" href="#背景图片">#</a> 背景图片</h6><blockquote><p>background-image: url (链接 / 地址)；</p></blockquote><h6 id="背景平铺"><a class="markdownIt-Anchor" href="#背景平铺">#</a> 背景平铺</h6><blockquote><p>background-repeat: ;</p></blockquote><p>no-repeat (常用): 不平铺<br> repeat (默认): 平铺<br> repeat-x: 沿着 X 轴平铺<br> repeat-y: 沿着 Y 轴平铺<br><strong>背景图片会压住背景颜色</strong><br><a href="https://imgtu.com/i/IQnFiT"><img src="https://z3.ax1x.com/2021/11/06/IQnFiT.png" alt="IQnFiT.png"></a></p><h6 id="背景位置"><a class="markdownIt-Anchor" href="#背景位置">#</a> 背景位置</h6><blockquote><p>background-position: ;</p></blockquote><p>left top center right bottom<br> 也可以用 right center 等同时使用 但是有几点需要注意<br> 1. 如果是方位名词  right center 和 center right 效果是等价的 跟顺序没有关系<br> 2. 当有参数省略时，并且不全是方位名字时，例如 right top ,<br> 省略 right，此时 top 会自动顶部对齐，而省略的会被判定为水平居中<br>省略 top，则会被判定为垂直居中<br><a href="https://imgtu.com/i/IQnEz4"><img src="https://z3.ax1x.com/2021/11/06/IQnEz4.png" alt="IQnEz4.png"></a><br> 也可以用具体的数据来进行移动，主要用于精灵图<br><a href="https://imgtu.com/i/IQney9"><img src="https://z3.ax1x.com/2021/11/06/IQney9.png" alt="IQney9.png"></a><br> 需要注意的时，html 的 X 轴向右，而 y 轴是向下的，需要向反方向移动时可以添加负号</p><h6 id="背景固定"><a class="markdownIt-Anchor" href="#背景固定">#</a> 背景固定</h6><blockquote><p>backgrounf-attachment: fixed;</p></blockquote><p>将背景图片固定，这样滑动鼠标滚轮时，背景图片会一直存在于网页上，并不会滑走<br><a href="https://imgtu.com/i/IQnmLR"><img src="https://z3.ax1x.com/2021/11/06/IQnmLR.png" alt="IQnmLR.png"></a></p><h6 id="背景属性复合写法"><a class="markdownIt-Anchor" href="#背景属性复合写法">#</a> 背景属性复合写法</h6><p><a href="https://imgtu.com/i/IQ6tje"><img src="https://z3.ax1x.com/2021/11/06/IQ6tje.png" alt="IQ6tje.png"></a></p><h6 id="背景半透明"><a class="markdownIt-Anchor" href="#背景半透明">#</a> 背景半透明</h6><p>主要这个不是放在 background-color 中</p><blockquote><p>background: rgba(X,X,X,X);</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Css-second</title>
      <link href="/2021/11/06/css2/"/>
      <url>/2021/11/06/css2/</url>
      
        <content type="html"><![CDATA[<h1 id="css2"><a class="markdownIt-Anchor" href="#css2">#</a> css2</h1><h3 id="the-article-from-yogmas-also-sam"><a class="markdownIt-Anchor" href="#the-article-from-yogmas-also-sam">#</a> the article from yogmas also sam</h3><h4 id="1css选择器的性质"><a class="markdownIt-Anchor" href="#1css选择器的性质">#</a> 1.css 选择器的性质</h4><h6 id="css层叠性"><a class="markdownIt-Anchor" href="#css层叠性">#</a> css 层叠性</h6><p>长江后浪推前浪，前浪死在沙滩上<br>当两个完全相同的选择器写在一起时，此时根据就近原则处理</p><h6 id="css继承性"><a class="markdownIt-Anchor" href="#css继承性">#</a> css 继承性</h6><p>大元素中的小元素会继承写在大元素中的属性</p><h6 id="行高的继承"><a class="markdownIt-Anchor" href="#行高的继承">#</a> 行高的继承</h6><p><a href="https://imgtu.com/i/IQ6YcD"><img src="https://z3.ax1x.com/2021/11/06/IQ6YcD.png" alt="IQ6YcD.png"></a></p><p>孩子拥有 font-size 元素会优先使用定义在自身的，而后面的倍数孩子自身没有就会继承父亲的倍数</p><h6 id="css优先级"><a class="markdownIt-Anchor" href="#css优先级">#</a> css 优先级</h6><p>这个主要是根据后面的权重的大小而判定的，权重大的优先。</p><h6 id="css权重"><a class="markdownIt-Anchor" href="#css权重">#</a> css 权重</h6><p><a href="https://imgtu.com/i/IQ6UnH"><img src="https://z3.ax1x.com/2021/11/06/IQ6UnH.png" alt="IQ6UnH.png"></a></p><h6 id="权重的叠加"><a class="markdownIt-Anchor" href="#权重的叠加">#</a> 权重的叠加</h6><p>权重的叠加可以用加减法来计算<br>例如 0,1,0,0 相当于 100</p><h4 id="2盒子模型"><a class="markdownIt-Anchor" href="#2盒子模型">#</a> 2. 盒子模型</h4><p>盒子通常是块级元素<br>也可以通过 display 将其变成块级元素 a 元素通常使用这种方法</p><h6 id="盒子边框"><a class="markdownIt-Anchor" href="#盒子边框">#</a> 盒子边框</h6><p><a href="https://imgtu.com/i/IQ6aBd"><img src="https://z3.ax1x.com/2021/11/06/IQ6aBd.png" alt="IQ6aBd.png"></a></p><blockquote><p>border-width: ;<br>border-style: ;<br>border-color: ;<br>border:width style color ; 复合写法</p></blockquote><p>这边建议大家使用复合写法<br> style:solid 实线 dotted 虚线 dashed 更大点的虚线</p><p><strong>边框会影响盒子的实际大小</strong></p><h6 id="盒子内边框"><a class="markdownIt-Anchor" href="#盒子内边框">#</a> 盒子内边框</h6><p><a href="https://imgtu.com/i/IQ66gS"><img src="https://z3.ax1x.com/2021/11/06/IQ66gS.png" alt="IQ66gS.png"></a></p><blockquote><p>padding: ;<br>padding-left: ;</p></blockquote><p>同理 left 可以换成其他的方位</p><p>内边距复合写法：从顶部顺时针数<br><strong>内边距会影响盒子的大小</strong></p><p>内边距不会影响盒子大小的情况:<br> 当盒子内没有给宽时，padding-left/right 不会影响<br>没有给高时 padding-top/bottom 不会影响</p><h6 id="盒子外边距"><a class="markdownIt-Anchor" href="#盒子外边距">#</a> 盒子外边距</h6><blockquote><p>margin:  ;<br>margin-top/XXX: ;</p></blockquote><p>复合写法和内边距同理</p><p><strong>外边距典型应用</strong>:<br>margin: XXXpx auto;<br> 此时 auto 代表左右两边自动设置可以让盒子水平对齐</p><h6 id="行内元素或行内块元素水平居中对齐"><a class="markdownIt-Anchor" href="#行内元素或行内块元素水平居中对齐">#</a> 行内元素或行内块元素水平居中对齐</h6><p>margin 对行内元素没有作用，但是可以给这两种元素的父盒子添加 text-align:center;</p><h6 id="外边距合并"><a class="markdownIt-Anchor" href="#外边距合并">#</a> 外边距合并</h6><p>当子盒子给 margin 时，父盒子和子盒子会塌陷，两个盒子会边框重合</p><h6 id="清除内外边距"><a class="markdownIt-Anchor" href="#清除内外边距">#</a> 清除内外边距</h6><p>通常浏览器会自带内外边距这时就需要使用通用符选择器将浏览器自带的边距出去</p><blockquote><pre><code>* {padding:0 ;   margin:0;}</code></pre></blockquote><h6 id="圆角边框"><a class="markdownIt-Anchor" href="#圆角边框">#</a> 圆角边框</h6><blockquote><p>border-radius: Xpx ;</p></blockquote><p>原理：利用一个半径为 Xpx 的圆，与边角重叠，然后切去没有重叠的边角；</p><h6 id="盒子阴影"><a class="markdownIt-Anchor" href="#盒子阴影">#</a> 盒子阴影</h6><p><a href="https://imgtu.com/i/IQCJfI"><img src="https://z3.ax1x.com/2021/11/06/IQCJfI.png" alt="IQCJfI.png"></a></p><blockquote><p>box-shadow: X X X X X;</p></blockquote><p>由左到右依次为 往右边移动的距离 往下面移动的距离 阴影发散度 (往四面八方发散)  往四面八方扩散的距离 颜色 (通常是 rgba 控制)</p><h6 id="文字阴影"><a class="markdownIt-Anchor" href="#文字阴影">#</a> 文字阴影</h6><blockquote><p>text-shadow:X X X rgba;</p></blockquote><p>分别是 往右边移动的距离 往下面移动的距离 虚实度 (越大越虚)</p><h6 id="行内块元素中间有缝隙"><a class="markdownIt-Anchor" href="#行内块元素中间有缝隙">#</a> 行内块元素中间有缝隙</h6><h4 id="3浮动"><a class="markdownIt-Anchor" href="#3浮动">#</a> 3. 浮动</h4><blockquote><pre><code>  float: left/right;</code></pre></blockquote><h6 id="浮动特性-脱标"><a class="markdownIt-Anchor" href="#浮动特性-脱标">#</a> 浮动特性 - 脱标</h6><p>1. 脱离标准普通流的控制（浮）移动到指定位置（动）。<br>2. 浮动的盒子不在保留原先的位置</p><p><strong>浮动元素具有行内块元素的特点</strong><br>浮动盒子通常搭配标准流父盒子</p><h6 id="浮动的注意点"><a class="markdownIt-Anchor" href="#浮动的注意点">#</a> 浮动的注意点</h6><p>1. 如果一个子元素浮动了，尽量其他盒子也浮动，这样保证这些子元素一行显示</p><h6 id="清除浮动的方法"><a class="markdownIt-Anchor" href="#清除浮动的方法">#</a> 清除浮动的方法</h6><p><a href="https://imgtu.com/i/IQCN1P"><img src="https://z3.ax1x.com/2021/11/06/IQCN1P.png" alt="IQCN1P.png"></a></p><p><a href="https://imgtu.com/i/IJqJS0"><img src="https://z3.ax1x.com/2021/11/09/IJqJS0.png" alt="IJqJS0.png"></a></p><p>额外标签法：在子盒子的最后新增一个块级盒子 并且用 css 给快捷盒子加上 clear:both; 属性</p><p>父元素 overflow: 给父元素加上一个 overflow: hidden; 的 css 属性<br><a href="https://imgtu.com/i/IJqtyT"><img src="https://z3.ax1x.com/2021/11/09/IJqtyT.png" alt="IJqtyT.png"></a></p><p>伪元素清除:</p><blockquote><p>.clearfix:after {<br>content: “”;<br>display: block;<br>height: 0;<br>clear: both;<br>visibility: hidden;<br>}<br>.clearfix {<br>IE6、7 专有<br> zoom: 1;<br>}</p></blockquote><p><a href="https://imgtu.com/i/IQ60AI"><img src="https://z3.ax1x.com/2021/11/06/IQ60AI.png" alt="IQ60AI.png"></a></p><p>给父盒子一个 class 为 clearfix 然后将这串代码心如 css 中</p><p>双伪元素清除:</p><blockquote><p>.clearfix:before,<br>.clearfix:after {<br>content: “”;<br>display: table;<br>}<br>.clearfix:after {<br>clear: both;<br>}<br>.clearfix {<br>*zoom: 1;<br>}</p></blockquote><p>同理给一个 clearfix 标签，然后将这串代码写入 css 中</p><h4 id="4定位"><a class="markdownIt-Anchor" href="#4定位">#</a> 4. 定位</h4><p><a href="https://imgtu.com/i/IQCGtA"><img src="https://z3.ax1x.com/2021/11/06/IQCGtA.png" alt="IQCGtA.png"></a><br><a href="https://imgtu.com/i/IJqwTJ"><img src="https://z3.ax1x.com/2021/11/09/IJqwTJ.png" alt="IJqwTJ.png"></a></p><blockquote><p>position: ;</p></blockquote><p>static: 默认静态定位<br> absolute: 绝对定位<br> relative: 相对定位<br> fixed: 固定定位<br> sticky: 粘性定位</p><p>相对定位：可以进行定位，但依旧会占用空间<br>绝对定位<br>如果没施加绝对定位的盒子没有父盒子，那么绝对定位就是在浏览器的基础上的<br>如果绝对定位的盒子有父盒子，那么绝对定位就是在父盒子的基础上，并且<strong>父盒子一定要有定位，否则绝对定位就会失效</strong>所以通常说相对定位就是给绝对定位当爹的</p><p>固定定位：会固定在屏幕上，无视浏览器的滑块移动</p><p>粘性定位：会先随着浏览器滑块的滑动而滑动，但是后来会静止，并且无法滑出浏览器屏幕</p><h6 id="定位的堆叠顺序"><a class="markdownIt-Anchor" href="#定位的堆叠顺序">#</a> 定位的堆叠顺序</h6><p>如果有很多个绝对定位，可能会放在同一个位置，这时候需要确定谁放置在最上面</p><blockquote><pre><code>z-index: ;</code></pre></blockquote><p>默认为 0，数值越大显示等级越高</p><h6 id="小技巧-绝对定位的水平垂直居中"><a class="markdownIt-Anchor" href="#小技巧-绝对定位的水平垂直居中">#</a> 小技巧 - 绝对定位的水平垂直居中</h6><p>1.left 走 50%  父容器宽度的一半<br> 2.margin 负值 往左边走 自己盒子宽度的一半</p><h6 id="定位的特殊特性"><a class="markdownIt-Anchor" href="#定位的特殊特性">#</a> 定位的特殊特性</h6><p><a href="https://imgtu.com/i/IQC1TH"><img src="https://z3.ax1x.com/2021/11/06/IQC1TH.png" alt="IQC1TH.png"></a><br><a href="https://imgtu.com/i/IQCtpt"><img src="https://z3.ax1x.com/2021/11/06/IQCtpt.png" alt="IQCtpt.png"></a></p><h6 id="定位和浮动的差异"><a class="markdownIt-Anchor" href="#定位和浮动的差异">#</a> 定位和浮动的差异</h6><p>定位和浮动有相似部分，类如都会转化为行内块元素，都会压住盒子，但是浮动不会压住文字，定位会将所有东西压住</p><h4 id="5显示隐藏"><a class="markdownIt-Anchor" href="#5显示隐藏">#</a> 5. 显示隐藏</h4><h6 id="display"><a class="markdownIt-Anchor" href="#display">#</a> display</h6><blockquote><p>display: ;</p></blockquote><p><a href="https://imgtu.com/i/IQCaX8"><img src="https://z3.ax1x.com/2021/11/06/IQCaX8.png" alt="IQCaX8.png"></a></p><h6 id="visibility"><a class="markdownIt-Anchor" href="#visibility">#</a> visibility</h6><p><a href="https://imgtu.com/i/IQCwnS"><img src="https://z3.ax1x.com/2021/11/06/IQCwnS.png" alt="IQCwnS.png"></a></p><h6 id="overflow"><a class="markdownIt-Anchor" href="#overflow">#</a> overflow</h6><blockquote><p>overflow: ;</p></blockquote><p><a href="https://imgtu.com/i/IQC00g"><img src="https://z3.ax1x.com/2021/11/06/IQC00g.png" alt="IQC00g.png"></a><br><a href="https://imgtu.com/i/IQCB7Q"><img src="https://z3.ax1x.com/2021/11/06/IQCB7Q.png" alt="IQCB7Q.png"></a></p><h4 id="6精灵图"><a class="markdownIt-Anchor" href="#6精灵图">#</a> 6. 精灵图</h4><p>这里不好介绍怎样操作只能简单而言<br>一张包含各种小图片的大图片<br>利用前面所讲的背景图片位置的移动使其只能显示出一张小图片来<br>问：为什么需要精灵图<br>利用精灵图可以将多张图片整合在一起，从而可以减少信息的发送和接受量，减少服务器的负担</p><h4 id="7字体图标的使用"><a class="markdownIt-Anchor" href="#7字体图标的使用">#</a> 7. 字体图标的使用</h4><p>通过在网站上寻找字体图标，下载</p><p>然后将代码写入 css 中</p><blockquote><p>@font-face {<br>font-family: ‘icomoon’;<br>src:  url(‘fonts/icomoon.eot?p4ssmb’);<br>src:  url(‘fonts/icomoon.eot?p4ssmb#iefix’) format(‘embedded-opentype’),<br>url(‘fonts/icomoon.ttf?p4ssmb’) format(‘truetype’),<br>url(‘fonts/icomoon.woff?p4ssmb’) format(‘woff’),<br>url(‘fonts/icomoon.svg?p4ssmb#icomoon’) format(‘svg’);<br>font-weight: normal;<br>font-style: normal;<br>font-display: block;<br>}</p></blockquote><p>font 文件夹移动到主文件夹中</p><p>此时就可以用字体图标代码来进行表示字体图标</p><p>好处：可以对图标进行改变颜色大小等等的改变字体时用到的属性</p><h4 id="8css三角的制作"><a class="markdownIt-Anchor" href="#8css三角的制作">#</a> 8.css 三角的制作</h4><p>利用 cssborder 属性来进行三角的制作<br>由于不好叙述，自己输入，理解并体验这几组代码，应该就能理解 css 三角的制作<br><a href="https://imgtu.com/i/IQCsts"><img src="https://z3.ax1x.com/2021/11/06/IQCsts.png" alt="IQCsts.png"></a><br><a href="https://imgtu.com/i/IQCrkj"><img src="https://z3.ax1x.com/2021/11/06/IQCrkj.png" alt="IQCrkj.png"></a></p><h4 id="9用户界面样式"><a class="markdownIt-Anchor" href="#9用户界面样式">#</a> 9. 用户界面样式</h4><h6 id="表单轮廓"><a class="markdownIt-Anchor" href="#表单轮廓">#</a> 表单轮廓</h6><p>由于点击表单或者 text 文本框时边框上会出现颜色变化边框变大拖拽文本域等一系列的反应，从而利用 css 取消边框的轮廓</p><blockquote><pre><code>outline: none;  (input,textarea)</code></pre></blockquote><blockquote><pre><code>resize:none; (textarea)</code></pre><p>用来防止拖拽文本域的</p></blockquote><h6 id="鼠标样式"><a class="markdownIt-Anchor" href="#鼠标样式">#</a> 鼠标样式</h6><blockquote><p>cursor: ;</p></blockquote><p>default: 小白鼠标样式<br> pointer: 鼠标小手样式<br> move: 鼠标移动样式<br> text: 鼠标文本样式<br> not-allowed: 鼠标禁止样式</p><h6 id="图片文字垂直居中"><a class="markdownIt-Anchor" href="#图片文字垂直居中">#</a> 图片文字垂直居中</h6><p><a href="https://imgtu.com/i/IJqrf1"><img src="https://z3.ax1x.com/2021/11/09/IJqrf1.png" alt="IJqrf1.png"></a></p><h6 id="图片底侧有空白缝隙的解决方案"><a class="markdownIt-Anchor" href="#图片底侧有空白缝隙的解决方案">#</a> 图片底侧有空白缝隙的解决方案</h6><p>先将图片变为块级元素，然后再给块级元素设置边框就可以解决</p><h4 id="10文字溢出显示"><a class="markdownIt-Anchor" href="#10文字溢出显示">#</a> 10. 文字溢出显示</h4><h6 id="单行文字溢出显示"><a class="markdownIt-Anchor" href="#单行文字溢出显示">#</a> 单行文字溢出显示</h6><p><a href="https://imgtu.com/i/IQCyhn"><img src="https://z3.ax1x.com/2021/11/06/IQCyhn.png" alt="IQCyhn.png"></a></p><h6 id="多行文字溢出显示"><a class="markdownIt-Anchor" href="#多行文字溢出显示">#</a> 多行文字溢出显示</h6><p><a href="https://imgtu.com/i/IJqc6K"><img src="https://z3.ax1x.com/2021/11/09/IJqc6K.png" alt="IJqc6K.png"></a></p><h4 id="11margin负值的巧妙运动"><a class="markdownIt-Anchor" href="#11margin负值的巧妙运动">#</a> 11.margin 负值的巧妙运动</h4><p>如果多个盒子都有边框，此时相交部分边框会重合在一起，从而增加边框的大小，此时只需要写入 margin-left: -1px; 就可以得到解决</p><h4 id="12文字围绕浮动元素"><a class="markdownIt-Anchor" href="#12文字围绕浮动元素">#</a> 12. 文字围绕浮动元素</h4><p>众所周知浮动元素是不占用空间的，此时如果将一个照片浮动，而需要在照片旁边写入汉字的话，汉字是否会出现在图片的下方呢，答案是不会，因为汉字会围绕浮动元素</p><h4 id="13css初始化"><a class="markdownIt-Anchor" href="#13css初始化">#</a> 13.css 初始化</h4><p>这里给出一串代码，初始化网页，将网页元素自带的一些 css 属性给去掉</p><blockquote><p>/* 把我们所有标签的内外边距清零 <em>/<br>* {<br>margin: 0;<br>padding: 0<br>}<br>/</em>em 和 i 斜体的文字不倾斜 <em>/<br>em,<br>i {<br>font-style: normal<br>}<br>/</em> 去掉 li 的小圆点 <em>/<br>li {<br>list-style: none<br>}<br>img {<br>/</em>border 0 照顾低版本浏览器 如果 图片外面包含了链接会有边框的问题 <em>/<br>border: 0;<br>/</em> 取消图片底侧有空白缝隙的问题 <em>/<br>vertical-align: middle<br>}<br>button {<br>/</em> 当我们鼠标经过 button 按钮的时候，鼠标变成小手 <em>/<br>cursor: pointer<br>}<br>a {<br>color: #666;<br>text-decoration: none<br>}<br>a:hover {<br>color: #c81623<br>}<br>button,<br>input {<br>/</em> “\5B8B\4F53” 就是宋体的意思 这样浏览器兼容性比较好 <em>/<br>font-family: Microsoft YaHei, Heiti SC, tahoma, arial, Hiragino Sans GB, “\5B8B\4F53”, sans-serif<br>}<br>body {<br>/</em> CSS3 抗锯齿形 让文字显示的更加清晰 <em>/<br>-webkit-font-smoothing: antialiased;<br>background-color: #fff;<br>font: 12px/1.5 Microsoft YaHei, Heiti SC, tahoma, arial, Hiragino Sans GB, “\5B8B\4F53”, sans-serif;<br>color: #666<br>}<br>.hide,<br>.none {<br>display: none<br>}<br>/</em> 清除浮动 */<br>.clearfix:after {<br>visibility: hidden;<br>clear: both;<br>display: block;<br>content: “.”;<br>height: 0<br>}<br>.clearfix {<br>*zoom: 1<br>}</p></blockquote><h4 id="14css新增属性"><a class="markdownIt-Anchor" href="#14css新增属性">#</a> 14.css 新增属性</h4><h6 id="新增属性选择器"><a class="markdownIt-Anchor" href="#新增属性选择器">#</a> 新增属性选择器</h6><p><a href="https://imgtu.com/i/IJqRmD"><img src="https://z3.ax1x.com/2021/11/09/IJqRmD.png" alt="IJqRmD.png"></a></p><p>通过举例进行说明<br> input [type=text] {}<br> 这个表示选出 input 中 type=text 的元素</p><p>div [class^=XXX]: 选出以 XXX 开头的元素</p><p>div [class$=XXX]: 选出以 XXX 结尾的元素</p><h6 id="结构伪类选择器"><a class="markdownIt-Anchor" href="#结构伪类选择器">#</a> 结构伪类选择器</h6><p><a href="https://imgtu.com/i/IJqgOO"><img src="https://z3.ax1x.com/2021/11/09/IJqgOO.png" alt="IJqgOO.png"></a></p><blockquote><pre><code>xxx:firstchildxxx:secondchildxxx:nth-child(number)</code></pre></blockquote><p>都是选出第几个子元素的意思</p><p><a href="https://imgtu.com/i/IJq4kd"><img src="https://z3.ax1x.com/2021/11/09/IJq4kd.png" alt="IJq4kd.png"></a></p><p>括号里面不仅仅可以跟数字，也可以很有特殊意义的单词，甚至可以跟公式 n 将取自然数</p><p>nth-of-type 选择器</p><p>两个选择器的区别如下<br><a href="https://imgtu.com/i/IJqfTH"><img src="https://z3.ax1x.com/2021/11/09/IJqfTH.png" alt="IJqfTH.png"></a></p><p>举例子来说明:</p><blockquote><pre><code>&lt;p&gt;光头强&lt;/p&gt;&lt;div&gt;熊大&lt;/div&gt;&lt;div&gt;熊二&lt;/div&gt;</code></pre></blockquote><p>此时如果给一个 section div:nth-child (1) { background-color: red; } 指令，你觉得谁会被加上红色呢<br>答案是都不会<br> child 先看后面的数字 1   ，此时第一个孩子是 p，然后再来看前面的 div，发现 div 不是 P，所以不成立 谁都不给</p><p>但如果给一个 section div:nth-of-type (1) {<br>background-color: blue;} 指令呢<br>答案是会给熊大，type 先看前面的 div，找出 div，再发现后面的 1，所以会给 div 中的第一个孩子</p><h6 id="伪元素选择器"><a class="markdownIt-Anchor" href="#伪元素选择器">#</a> 伪元素选择器</h6><blockquote><p>XXX::before/after {<br>content:’’;<br>}<br> 这里面的 content 是必须加的，表示里面的内容，即使你没有内容要写，也需要写出 content 否则无效，注意是单引号</p></blockquote><p>用处：可以里面 css 来个父元素添加盒子 词的的 before 表示出现在父元素的左边 after 表示出现在父元素的右边</p><h6 id="css3盒子模型"><a class="markdownIt-Anchor" href="#css3盒子模型">#</a> css3 盒子模型</h6><p>前面我们说了 padding 和边框都会撑大盒子，所以说我们使用 border 和 padding 还需要减去其尺寸，现在我们提供了修复的方法</p><blockquote><p>box-sizing:  ;</p></blockquote><p>content-box: 按照原来会撑大盒子的方式<br> border-box: 会自动减去撑大的尺寸，保证盒子的尺寸不变</p><h6 id="图片模糊处理"><a class="markdownIt-Anchor" href="#图片模糊处理">#</a> 图片模糊处理</h6><blockquote><p>filter:blur()</p></blockquote><p>blur 是一个函数 小括号里面数值越大，图片越模糊 注意数值要加 px 单位</p><h6 id="css3宽度calc函数"><a class="markdownIt-Anchor" href="#css3宽度calc函数">#</a> css3 宽度 calc 函数</h6><p>calc 函数主要提供了一个计算的方法<br>例如在有一个父盒子的前提下，子盒子写出这样一个函数 width: calc (100% - 30px); 表示在父亲 100% 尺寸的前提下始终减去 30px 的宽度</p><h6 id="过渡效果"><a class="markdownIt-Anchor" href="#过渡效果">#</a> 过渡效果</h6><p>大概来说就是将一个瞬间变化的过程转化成阶段性有时间长短的变化<br><a href="https://imgtu.com/i/IJqTpt"><img src="https://z3.ax1x.com/2021/11/09/IJqTpt.png" alt="IJqTpt.png"></a><br> 在这里 0s 开始一般可以不写而省略，变化曲线也一遍使用 ease 这是最常用的变化曲线</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript基础(未完待续)</title>
      <link href="/2021/11/06/javascript-ji-chu-ban/"/>
      <url>/2021/11/06/javascript-ji-chu-ban/</url>
      
        <content type="html"><![CDATA[<h1 id="javascript"><a class="markdownIt-Anchor" href="#javascript">#</a> javascript</h1><h2 id="article-by-yogmas"><a class="markdownIt-Anchor" href="#article-by-yogmas">#</a> Article By Yogmas</h2><h3 id="js的组成"><a class="markdownIt-Anchor" href="#js的组成">#</a> js 的组成</h3><p>1.ECNscript:JS 语法<br> 2.DOM: 页面文档模型<br> 3.BOM: 浏览器对象模型</p><h4 id="js初体验"><a class="markdownIt-Anchor" href="#js初体验">#</a> js 初体验</h4><p>1. 行内式 js: 直接写到元素的内部<br><a href="https://imgtu.com/i/IGFyQJ"><img src="https://z3.ax1x.com/2021/11/08/IGFyQJ.png" alt="IGFyQJ.png"></a><br>2. 内嵌式的 js:</p><blockquote><pre><code>&lt;head&gt;&lt;script&gt; &lt;/script&gt;&lt;/head&gt;</code></pre></blockquote><p>3. 外部式 js: 创建 XXX.js 文件在通过标签引出到 html 文件中<br><a href="https://imgtu.com/i/IGF2e1"><img src="https://z3.ax1x.com/2021/11/08/IGF2e1.png" alt="IGF2e1.png"></a></p><h4 id="js注释"><a class="markdownIt-Anchor" href="#js注释">#</a> js 注释</h4><blockquote><pre><code>1.单行注释    //    ctrl + /2.多行注释     /*    */    shift + alt + a</code></pre></blockquote><h4 id="js输入输出语句"><a class="markdownIt-Anchor" href="#js输入输出语句">#</a> js 输入输出语句</h4><p><a href="https://imgtu.com/i/IGFWo6"><img src="https://z3.ax1x.com/2021/11/08/IGFWo6.png" alt="IGFWo6.png"></a></p><blockquote><pre><code>prompt('') 输入框 alert('')警示框  展示给用户的console 控制台打印的信息 给程序员看的</code></pre></blockquote><h3 id="变量概述"><a class="markdownIt-Anchor" href="#变量概述">#</a> 变量概述</h3><h4 id="什么是变量"><a class="markdownIt-Anchor" href="#什么是变量">#</a> 什么是变量</h4><p>变量是用来存放数据的容器，简而言之就是一个装东西的盒子<br>变量是内存中申请的一部分用来存放数据的空间</p><h3 id="变量的使用"><a class="markdownIt-Anchor" href="#变量的使用">#</a> 变量的使用</h3><h4 id="声明变量"><a class="markdownIt-Anchor" href="#声明变量">#</a> 声明变量</h4><blockquote><p>var age;</p></blockquote><p>var 是一个 js 关键字用来声明变量<br> age 是程序员取的名字</p><h4 id="赋值"><a class="markdownIt-Anchor" href="#赋值">#</a> 赋值</h4><p>赋值就是把值存入变量中</p><blockquote><p>age=10</p></blockquote><p>这里的 = 是赋值的意思 在变量中存储一个数据</p><h4 id="变量的初始化"><a class="markdownIt-Anchor" href="#变量的初始化">#</a> 变量的初始化</h4><blockquote><p>var age=18;</p></blockquote><p>在声明变量的同时赋值给 18  使程序变得更加简便</p><blockquote><pre><code>var myname = prompt('请输入你的名字')</code></pre></blockquote><p>这样在弹出的对话框里面输入的名字 可以储存到变量 myname 中去</p><h4 id="变量语法扩展"><a class="markdownIt-Anchor" href="#变量语法扩展">#</a> 变量语法扩展</h4><h5 id="更新变量"><a class="markdownIt-Anchor" href="#更新变量">#</a> 更新变量</h5><blockquote><pre><code> var myname = 'pink'; console.log(myname);  myname = '迪丽热巴';  console.log(myname);</code></pre></blockquote><p>这样从上到下 第一次输出的 pink 第二次输出的是迪丽热巴  变量在不断更新</p><h5 id="声明多个变量"><a class="markdownIt-Anchor" href="#声明多个变量">#</a> 声明多个变量</h5><blockquote><pre><code>eg:var age=18,address='火影村'</code></pre></blockquote><p>这里声明了 age 和 address 多个变量，变量与变量之间通过英文的逗号隔开</p><h5 id="声明变量的特殊情况"><a class="markdownIt-Anchor" href="#声明变量的特殊情况">#</a> 声明变量的特殊情况</h5><p>1. 只声明不赋值 这时候输出的结果是 undefined (未定义的)<br> 2. 不声明不赋值 直接使用 浏览器会进行报错<br> 3. 不声明直接赋值使用 在 js 之中只可以使用的</p><p>注意:js 是从上到下处理的，如果中间有错误的代码，那么错误代码下面的代码将不再被 js 处理<br><a href="https://imgtu.com/i/IG0QRf"><img src="https://z3.ax1x.com/2021/11/08/IG0QRf.png" alt="IG0QRf.png"></a></p><h5 id="变量命名规范"><a class="markdownIt-Anchor" href="#变量命名规范">#</a> 变量命名规范</h5><p><a href="https://imgtu.com/i/IGieEV"><img src="https://z3.ax1x.com/2021/11/08/IGieEV.png" alt="IGieEV.png"></a><br> 尽量不要直接使用 name 作为变量名，name 在大部分浏览器中有变量含义</p><h4 id="小结"><a class="markdownIt-Anchor" href="#小结">#</a> 小结</h4><p>自我问答环节<br><a href="https://imgtu.com/i/IGin4U"><img src="https://z3.ax1x.com/2021/11/08/IGin4U.png" alt="IGin4U.png"></a><br><a href="https://imgtu.com/i/IGiM34"><img src="https://z3.ax1x.com/2021/11/08/IGiM34.png" alt="IGiM34.png"></a></p><h3 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型">#</a> 数据类型</h3><h4 id="简介"><a class="markdownIt-Anchor" href="#简介">#</a> 简介</h4><p>不同的数据占用的存储空间不同，为了充分利用存储空间，于是定义了不同的数据类型.</p><h4 id="变量的数据类型"><a class="markdownIt-Anchor" href="#变量的数据类型">#</a> 变量的数据类型</h4><p>js 是一种弱类型或者说动态语言，这意味着不用提前声明变量的类型，在程序运行的过程中，类型会自动确定.</p><p>js 的变量数据类型是只有程序在运行过程中，根据等号右边的值来确定的.</p><p>js 是动态语言，变量的数据类型是可以变化的</p><blockquote><p>var x = 10;x 是数字型<br> var x = ‘yogmas’; x 是字符串型</p></blockquote><h5 id="简单数据类型"><a class="markdownIt-Anchor" href="#简单数据类型">#</a> 简单数据类型</h5><p><a href="https://imgtu.com/i/IGFTQH"><img src="https://z3.ax1x.com/2021/11/08/IGFTQH.png" alt="IGFTQH.png"></a></p><h6 id="数字型"><a class="markdownIt-Anchor" href="#数字型">#</a> 数字型</h6><p>1. 在我们程序里面数字前面加 0 表示 8 进制</p><blockquote><pre><code>eg:var num = 010 转化为10进制就是8</code></pre></blockquote><p>2. 十六进制 0~9 a~f<br> 在数字前面加 0x 表示 16 进制</p><blockquote><pre><code>eg:var num = 0xa 转外为10进制就是10</code></pre></blockquote><p>3. 数字型的最大值</p><blockquote><pre><code>console.log(Number.MAX_VALUE)  1.7976e+308</code></pre></blockquote><p>4. 数字型的最小值</p><blockquote><pre><code>console.log(Number.MIN_VALUE)  5e-324</code></pre></blockquote><p>数字型的三个特殊数值<br> alert (infinity) 无穷大<br> alert (-infinity) 无穷小<br>这两个数都可以通过将前面的最大数或者最小数通过加减乘除扩大或缩小得到<br> alert (NAN) 非数值</p><p>可以通过 isNAN 用来判断非数字 并且返回一个值， 如果是数值返回的是 false 如果不是数字 返回的是 true<br>console.log(isNaN(XX));<br><a href="https://imgtu.com/i/IGFOTP"><img src="https://z3.ax1x.com/2021/11/08/IGFOTP.png" alt="IGFOTP.png"></a></p><h5 id="字符串型"><a class="markdownIt-Anchor" href="#字符串型">#</a> 字符串型</h5><p>字符串数据类型用单引号圈出 (字符串必须加引号，不然会提示错误)</p><p>注意引号内不能内嵌引号，如果要引号内嵌，使用不同的引号 (<strong>引号判定是就近一致原则</strong>)</p><blockquote><pre><code>例如:var str = "我是一个'高富帅'程序员";</code></pre></blockquote><h6 id="字符串长度"><a class="markdownIt-Anchor" href="#字符串长度">#</a> 字符串长度</h6><p>检测获取字符串的长度 用 length</p><blockquote><pre><code>        var str = 'my name is andy ';        console.log(str.length)</code></pre></blockquote><h6 id="字符转义符"><a class="markdownIt-Anchor" href="#字符转义符">#</a> 字符转义符</h6><p><a href="https://imgtu.com/i/IGkmpF"><img src="https://z3.ax1x.com/2021/11/08/IGkmpF.png" alt="IGkmpF.png"></a><br> 都是以 \ 开头 ，但是这些转义字符要写到引号里面</p><h6 id="字符串的拼接"><a class="markdownIt-Anchor" href="#字符串的拼接">#</a> 字符串的拼接</h6><blockquote><pre><code>console.log ('' + '' + '')字符串之间通过加号连接eg:console.log ('沙漠'+'骆驼 ') = '沙漠骆驼'console.log ('12' + 12) 最后为1212  这是字符串的相加   console.log (12 + 12) 最后为24   这是数字型的相加</code></pre></blockquote><p>只要有一个是字符串 其他全部都会以字符串相连<br><strong>数字相加，字符相连</strong></p><h6 id="字符串拼接加强"><a class="markdownIt-Anchor" href="#字符串拼接加强">#</a> 字符串拼接加强</h6><p>通过改变变量中的值 来改变显示中的值</p><blockquote><pre><code>eg:var age = 18;   console.log('pink老师'+age+'岁')</code></pre></blockquote><p>需要注意的时，<strong>变量不要写到字符串里面，是通过和字符串相连的方式实现的</strong></p><blockquote><pre><code>  console.log ('pink老师age岁')  console.log ('pink老师'+'age'+'岁')  console.log ('pink老师'+'age岁')</code></pre></blockquote><p>如上这些等等做法，都是不能实现的.<br><a href="https://imgtu.com/i/IGku6J"><img src="https://z3.ax1x.com/2021/11/08/IGku6J.png" alt="IGku6J.png"></a><br> 交互编程：</p><p>用户输入 → 处理 → 输出</p><blockquote><pre><code>eg         var age = prompt('请输入您的年龄');           var str = '你今年已经' + age + '岁了';           alert(str);</code></pre></blockquote><h5 id="布尔型boolean"><a class="markdownIt-Anchor" href="#布尔型boolean">#</a> 布尔型 Boolean</h5><p>布尔型中有两个值 true 和 false</p><blockquote><pre><code>eg         var flag = true; 布尔型           var flag1 = false; 布尔型</code></pre></blockquote><p>需要注意的是参与加法运算时布尔型 true 就是 1，false 就是 0.</p><h5 id="undefined-和null"><a class="markdownIt-Anchor" href="#undefined-和null">#</a> Undefined 和 Null</h5><p>如果一个变量声明未赋值 就是 undefined 未定义数据类型</p><blockquote><pre><code>   eg: var str;       console.log(var);</code></pre></blockquote><p>未定义和字符串相加，最终的结果是 undefined+ 字符串的内容</p><p>undefined 和数字相加 最后得到的结果是 NaN: not a number</p><p>null : 空值</p><blockquote><pre><code>var space = nullconsole.log(space + 'yogmas')  输出的结果是 spaceyogmasconsole.log(space + 1) 输出的结果是1  (和undefined区别)</code></pre></blockquote><h4 id="获取变量数据类型"><a class="markdownIt-Anchor" href="#获取变量数据类型">#</a> 获取变量数据类型</h4><h5 id="使用typeof来检测"><a class="markdownIt-Anchor" href="#使用typeof来检测">#</a> 使用 typeof 来检测</h5><blockquote><pre><code>   eg:   var num = 10;         console.log(typeof num);</code></pre></blockquote><p>比较特殊的是 在这里对 null 进行数据类型检测 输出来的是 object (对象)</p><p>经过检测发现 我们 prompt 取过来的值是字符型的</p><h5 id="观察控制台中的数据颜色"><a class="markdownIt-Anchor" href="#观察控制台中的数据颜色">#</a> 观察控制台中的数据颜色</h5><p>数字型 浅蓝色<br>字符型 黑色<br>布尔型 深蓝色<br> undefined 和 null 灰色</p><h4 id="字面量"><a class="markdownIt-Anchor" href="#字面量">#</a> 字面量</h4><p>字面量是在源代码中一个固定值得表示法，通俗来说，就是字面量表示如何表达这个值<br><a href="https://imgtu.com/i/IGkQmR"><img src="https://z3.ax1x.com/2021/11/08/IGkQmR.png" alt="IGkQmR.png"></a></p><h4 id="数据类型转换"><a class="markdownIt-Anchor" href="#数据类型转换">#</a> 数据类型转换</h4><p>通常会实现 3 中方式的转换<br> 1. 转换为字符串类型<br> 2. 转换为数字型<br> 3. 转换为布尔型</p><h5 id="转换成字符串型"><a class="markdownIt-Anchor" href="#转换成字符串型">#</a> 转换成字符串型</h5><p><a href="https://imgtu.com/i/IGkGtK"><img src="https://z3.ax1x.com/2021/11/08/IGkGtK.png" alt="IGkGtK.png"></a></p><blockquote><pre><code>var num = 18;console.log(num.toString())console.log(String(num))console.log(num + '')</code></pre></blockquote><p>注意:toString () 和 String () 的使用方法不同<br>三种方法中 其中拼接转换字符串最为实用</p><h5 id="转换为数字型重点"><a class="markdownIt-Anchor" href="#转换为数字型重点">#</a> 转换为数字型 (重点)</h5><p><a href="https://imgtu.com/i/IGkN1e"><img src="https://z3.ax1x.com/2021/11/08/IGkN1e.png" alt="IGkN1e.png"></a><br> 其中前两个较为实用<br> 1.parseInt (变量) 可以把字符型的转换为数字型 但是得到的是整数 并且约分不会四舍五入，会直接去掉小数点后面的数字 如果数字后面有单位，也会去掉单位，如果以字母开头那么输出的为 NaN<br>2.paseFloat (变量) 可以把字符型的转化为数字型，得到的是浮点数也就是小数，但同样也会把后面的单位去掉<br> 3.Number (变量)<br> 4. 利用了算数运算 - * / 隐式转换<br><a href="https://imgtu.com/i/IGk2cQ"><img src="https://z3.ax1x.com/2021/11/08/IGk2cQ.png" alt="IGk2cQ.png"></a></p><blockquote><pre><code>   console.log(parseInt('123'));   console.log(parseFloat('123'));   console.log(Number('123'));   console.log('12' - 0);   console.log('123' - '123');   console.log('123' * 1);</code></pre></blockquote><h5 id="转化为布尔型"><a class="markdownIt-Anchor" href="#转化为布尔型">#</a> 转化为布尔型</h5><p>代表<strong>空，否定</strong>的值会被转化为 false，如’’,0,NaN,null,undefined. 其他的值都会被转化成 true<br><a href="https://imgtu.com/i/IGkjBR"><img src="https://z3.ax1x.com/2021/11/08/IGkjBR.png" alt="IGkjBR.png"></a></p><blockquote><pre><code>eg: console.log(Boolean(''));      这是false</code></pre></blockquote><h4 id="解释型语言和编译型语言"><a class="markdownIt-Anchor" href="#解释型语言和编译型语言">#</a> 解释型语言和编译型语言</h4><p>编译型语言：全部编译成功后再执行代码.(做好菜 再吃饭)<br> 解释型语言：解释一行代码后就执行一行代码.(吃火锅：边吃边涮)</p><h4 id="标识符关键字保留字"><a class="markdownIt-Anchor" href="#标识符关键字保留字">#</a> 标识符，关键字，保留字</h4><p>标识符：开发人员为变量，属性，函数，参数取的名字<br><strong>标识符不能是关键字和保留字</strong><br>关键字：是指 js 本身已经使用了子，不能充当变量名和方法名<br><a href="https://imgtu.com/i/IGBhAs"><img src="https://z3.ax1x.com/2021/11/08/IGBhAs.png" alt="IGBhAs.png"></a><br> 保留字：预留的关键字，未来可能会成为关键字<br><a href="https://imgtu.com/i/IGBHjU"><img src="https://z3.ax1x.com/2021/11/08/IGBHjU.png" alt="IGBHjU.png"></a></p><h3 id="运算符"><a class="markdownIt-Anchor" href="#运算符">#</a> 运算符</h3><h4 id="算数运算符"><a class="markdownIt-Anchor" href="#算数运算符">#</a> 算数运算符</h4><p><a href="https://imgtu.com/i/IGAQgg"><img src="https://z3.ax1x.com/2021/11/08/IGAQgg.png" alt="IGAQgg.png"></a><br> 需要注意的是浮点数在算数运算里面会有问题 (会有一定的误差)</p><blockquote><pre><code>eg:console.log(0.07*100); 最终的结果是7.000000000000001</code></pre></blockquote><p><a href="https://imgtu.com/i/IGAaCT"><img src="https://z3.ax1x.com/2021/11/08/IGAaCT.png" alt="IGAaCT.png"></a><br> 我们不能拿着浮点数来进行相比较是否相等</p><h5 id="表达式返回值"><a class="markdownIt-Anchor" href="#表达式返回值">#</a> 表达式，返回值</h5><p>由数字，运算符，变量等组成的式子</p><p>在程序中的计算是把右边表达式计算完毕把返回值给左边</p><p>式子通过计算得到的结果 称为返回值</p><h4 id="自增和自减运算符"><a class="markdownIt-Anchor" href="#自增和自减运算符">#</a> 自增和自减运算符</h4><p>反复用给数字变量添加或者减去 1，可以用 ++ 或者–来实现<br>在 js 中，自增自减运算符既可以放在变量前面又可以放在变量后面，称为前置或者后置.<br> 需要注意的是 这个运算符必须和变量配合才能使用<br>前置和后置有区别的是，前置表示先自增或自减再返回，后置表示先返回再自增或自减<br><a href="https://imgtu.com/i/IGYJ4U"><img src="https://z3.ax1x.com/2021/11/08/IGYJ4U.png" alt="IGYJ4U.png"></a></p><h4 id="比较运算符关系运算符"><a class="markdownIt-Anchor" href="#比较运算符关系运算符">#</a> 比较运算符 &amp; 关系运算符</h4><p><a href="https://imgtu.com/i/IGYwuR"><img src="https://z3.ax1x.com/2021/11/08/IGYwuR.png" alt="IGYwuR.png"></a><br><a href="https://imgtu.com/i/IGYy4O"><img src="https://z3.ax1x.com/2021/11/08/IGYy4O.png" alt="IGYy4O.png"></a></p><h4 id="逻辑运算符"><a class="markdownIt-Anchor" href="#逻辑运算符">#</a> 逻辑运算符</h4><p><a href="https://imgtu.com/i/IGYhDI"><img src="https://z3.ax1x.com/2021/11/08/IGYhDI.png" alt="IGYhDI.png"></a></p><h5 id="短路运算逻辑中断"><a class="markdownIt-Anchor" href="#短路运算逻辑中断">#</a> 短路运算 (逻辑中断)</h5><p>原理：左边表达式的值可以确定结果时，就不再继续运算右边的值</p><p>逻辑与：如果表达式 1 结果为真，则返回表达式 2. 如果表达式 1 结果为假，则返回表达式 1<br><a href="https://imgtu.com/i/IGYIVP"><img src="https://z3.ax1x.com/2021/11/08/IGYIVP.png" alt="IGYIVP.png"></a><br><a href="https://imgtu.com/i/IGYoUf"><img src="https://z3.ax1x.com/2021/11/08/IGYoUf.png" alt="IGYoUf.png"></a><br> 逻辑或：如果表达式 1 结果为真，则返回表达式 1. 如果表达式 1 结果为假，则返回表达式 2.<br><a href="https://imgtu.com/i/IGYT58"><img src="https://z3.ax1x.com/2021/11/08/IGYT58.png" alt="IGYT58.png"></a></p><h5 id="赋值运算符"><a class="markdownIt-Anchor" href="#赋值运算符">#</a> 赋值运算符</h5><p>把右边的数据赋给左边的变量<br><a href="https://imgtu.com/i/IGYLvj"><img src="https://z3.ax1x.com/2021/11/08/IGYLvj.png" alt="IGYLvj.png"></a></p><h5 id="运算符优先级"><a class="markdownIt-Anchor" href="#运算符优先级">#</a> 运算符优先级</h5><p><a href="https://imgtu.com/i/IGtSaV"><img src="https://z3.ax1x.com/2021/11/08/IGtSaV.png" alt="IGtSaV.png"></a><br> 注意逻辑与的权重大于逻辑或的权重</p><h3 id="流程控制-分支"><a class="markdownIt-Anchor" href="#流程控制-分支">#</a> 流程控制 - 分支</h3><h4 id="流程控制"><a class="markdownIt-Anchor" href="#流程控制">#</a> 流程控制</h4><p>控制代码按照什么结构顺序来执行</p><p>流程控制有三种结构，分别是顺序结构，分支结构和循环结构<br><a href="https://imgtu.com/i/IGti24"><img src="https://z3.ax1x.com/2021/11/08/IGti24.png" alt="IGti24.png"></a></p><h5 id="顺序流程控制"><a class="markdownIt-Anchor" href="#顺序流程控制">#</a> 顺序流程控制</h5><p>按照写的代码的顺序从上到下执行，我们现在的代码大多数都是按照顺序流程控制来写的</p><h5 id="分支流程控制"><a class="markdownIt-Anchor" href="#分支流程控制">#</a> 分支流程控制</h5><p>从上到下执行代码的过程中，根据不同的条件，执行不同的路径代码，从而得到不同的结果</p><h4 id="if分支语句"><a class="markdownIt-Anchor" href="#if分支语句">#</a> if 分支语句</h4><blockquote><pre><code>if (条件表达式) {执行语句}</code></pre></blockquote><p>如果条件表达式结果为真就执行大括号里面的执行语句<br>如果条件表达式结果为假就执行 if 语句后面的代码<br><a href="https://imgtu.com/i/IGBOHJ"><img src="https://z3.ax1x.com/2021/11/08/IGBOHJ.png" alt="IGBOHJ.png"></a><br><a href="https://imgtu.com/i/IGBx41"><img src="https://z3.ax1x.com/2021/11/08/IGBx41.png" alt="IGBx41.png"></a></p><h5 id="if-else-双分支语句"><a class="markdownIt-Anchor" href="#if-else-双分支语句">#</a> if else 双分支语句</h5><p><a href="https://imgtu.com/i/IGDp36"><img src="https://z3.ax1x.com/2021/11/08/IGDp36.png" alt="IGDp36.png"></a><br> 如果表达式结果为真，那么执行语句 1 否则执行语句 2<br> 语句 1 和语句 2 只能二选一执行<br> else 后面直接加大括号而不是小括号<br><a href="https://imgtu.com/i/IGDVUA"><img src="https://z3.ax1x.com/2021/11/08/IGDVUA.png" alt="IGDVUA.png"></a></p><h5 id="if-else-多分支语句"><a class="markdownIt-Anchor" href="#if-else-多分支语句">#</a> if else 多分支语句</h5><p>利用多个条件来选择不同的语句执行，得到不同的结果，是多选 1 的过程</p><p>语法规范:<br>if (条件表达式 1) {</p><p>} else if (条件表达式 2) {</p><p>} else if …{</p><p>} else {<br>最后的语句<br>}<br> 如果条件表达式 1 满足就执行语句 1，执行完毕后退出整个 if 分支语句<br>如果条件 1 不满足就判断表达式 2 以此类推<br>如果全都不成立，则执行最后的 else 里面的语句<br>注意<br> 1. 多分支语句还是多选 1 最后只有 1 个语句能执行<br> 2.else if 里面的条件理论上是可以任意多个的<br> 3.else if 中间有个空格<br><a href="https://imgtu.com/i/IGD9gK"><img src="https://z3.ax1x.com/2021/11/08/IGD9gK.png" alt="IGD9gK.png"></a></p><h4 id="三元表达式"><a class="markdownIt-Anchor" href="#三元表达式">#</a> 三元表达式</h4><p>有三元运算符组成的式子我们称为三元表达式</p><p>条件表达式 1? 表达式 1: 表达式 2</p><p>如果条件表达式结果为真，则返回表达式 1 的值，如果条件表达式的结果为假，则返回表达式 2 的值</p><h4 id="switch语句"><a class="markdownIt-Anchor" href="#switch语句">#</a> switch 语句</h4><p>也是多分支语句可以实现多选 1 的效果<br><a href="https://imgtu.com/i/IGDn8P"><img src="https://z3.ax1x.com/2021/11/08/IGDn8P.png" alt="IGDn8P.png"></a><br> 语法结构:<br>switch (表达式) {<br>case value1:<br> 执行语句 1;<br>break;<br>case value2:<br> 执行语句 2;<br>break;<br>…………<br>default :<br> 执行最后的语句；<br>}<br> 利用表达式的值和 case 里面的选项匹配如果匹配上就执行相应的 case 里面的值，如果都没有匹配上就执行 default 里面的语句<br><a href="https://imgtu.com/i/IGDKv8"><img src="https://z3.ax1x.com/2021/11/08/IGDKv8.png" alt="IGDKv8.png"></a></p><h4 id="switch语句和-if-else-if语句的区别"><a class="markdownIt-Anchor" href="#switch语句和-if-else-if语句的区别">#</a> switch 语句和 if else if 语句的区别</h4><p>一般情况下，他们两个语句可以相互替换<br> switch…case 语句 一般在 case 为比较固定值得情况下而 if…else 语句一般来判断范围<br> switch 判断时直接跳到判断语句上而 if 语句从上往下一次判断，这样 switch 语句的效率更高一点，但是如果分支少的话 if else if 的效率会更高一点，分支多的时候 switch 语句的效率更高<br><a href="https://imgtu.com/i/IGDQKS"><img src="https://z3.ax1x.com/2021/11/08/IGDQKS.png" alt="IGDQKS.png"></a></p><h3 id="流程控制-循环"><a class="markdownIt-Anchor" href="#流程控制-循环">#</a> 流程控制 - 循环</h3><p>可以反复不断地循环执行某些代码</p><h4 id="for循环"><a class="markdownIt-Anchor" href="#for循环">#</a> for 循环</h4><p>for 循环重复执行某些代码，通常和计数有关<br>被重复的语句称为循环体，是否重复执行取决于循环的终止条件，由循环体及循环的终止条件<br>初始化变量 就是用 var 声明的一个普通变量，通常用于作为计数器使用<br>条件表达式 就是用来决定每一次循环是否继续执行 就是终止的条件<br>操作表达式 是每次循环最后执行的代码，经常用来对我们的计数器进行更新 (递增或者递减)</p><h5 id="断点调试"><a class="markdownIt-Anchor" href="#断点调试">#</a> 断点调试</h5><p>自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看着各个变量当前的值，出错的话，调试到出错的代码行及硻错误，停下.</p><p>在浏览器调试中的 source 中可以进行断点调试<br><a href="https://imgtu.com/i/IGtai8"><img src="https://z3.ax1x.com/2021/11/08/IGtai8.png" alt="IGtai8.png"></a></p><h5 id="for循环重复相同的代码"><a class="markdownIt-Anchor" href="#for循环重复相同的代码">#</a> for 循环重复相同的代码</h5><blockquote><pre><code>   var num = prompt('请输入重复的次数');   for (i = 1; i &lt;= num; i++) {   console.log('你是大傻逼');   }</code></pre></blockquote><h5 id="for循环重复不同的代码"><a class="markdownIt-Anchor" href="#for循环重复不同的代码">#</a> for 循环重复不同的代码</h5><p>循环可以重复执行不同的代码，因为计数器变量 i 的存在 i 每次循环值都会变化</p><blockquote><pre><code>   for (var i = 1; i &lt;= 100; i++) {   console.log('这个人今年' + i + '岁了');   }</code></pre></blockquote><h5 id="for循环重复相同的操作"><a class="markdownIt-Anchor" href="#for循环重复相同的操作">#</a> for 循环重复相同的操作</h5><p>例如:</p><blockquote><pre><code>   var sum = 0, aver = 0;   for (var i = 1; i &lt;= 100; i++) {   sum += i   }   aver = sum / i   console.log(aver);</code></pre></blockquote><h5 id="双重for循环"><a class="markdownIt-Anchor" href="#双重for循环">#</a> 双重 for 循环</h5><p>也就是 for 循环嵌套，在一个循环语句中 再定义一个循环语句.</p><blockquote><pre><code>for (外层的初始化变量;外层的条件表达式;外层的操作表达式) {     for (初始化变量;条件表达式;操作表达式){     }     }</code></pre></blockquote><p>里层的循环可以看成是外层循环的语句</p><h5 id="for循环小结"><a class="markdownIt-Anchor" href="#for循环小结">#</a> for 循环小结</h5><p><a href="https://imgtu.com/i/IGD1bQ"><img src="https://z3.ax1x.com/2021/11/08/IGD1bQ.png" alt="IGD1bQ.png"></a></p><h4 id="while循环"><a class="markdownIt-Anchor" href="#while循环">#</a> while 循环</h4><p><a href="https://imgtu.com/i/IGD8Ej"><img src="https://z3.ax1x.com/2021/11/08/IGD8Ej.png" alt="IGD8Ej.png"></a></p><p>条件表达式结果为 true 则执行循环体 否则 退出循环</p><p>while 循环中应该也有计数器初始化变量，也该有操作表达式完成计数器的更新防止死循环</p><h4 id="do-while-循环"><a class="markdownIt-Anchor" href="#do-while-循环">#</a> do while 循环</h4><p>语法结构</p><blockquote><p>do {循环体} while (条件表达式)</p></blockquote><p>执行思路不同的地方跟 while 在于 do whild 先执行一遍循环体再判断条件<br> do while 语句至少执行一次循环体</p><p><a href="https://imgtu.com/i/IGDwKU"><img src="https://z3.ax1x.com/2021/11/08/IGDwKU.png" alt="IGDwKU.png"></a></p><h4 id="循环小结"><a class="markdownIt-Anchor" href="#循环小结">#</a> 循环小结</h4><p><a href="https://imgtu.com/i/IGtwRg"><img src="https://z3.ax1x.com/2021/11/08/IGtwRg.png" alt="IGtwRg.png"></a></p><h3 id="continue关键字"><a class="markdownIt-Anchor" href="#continue关键字">#</a> continue 关键字</h3><p>用于立即跳出本次循环，继续下一次循环.</p><h3 id="break关键字"><a class="markdownIt-Anchor" href="#break关键字">#</a> break 关键字</h3><p>break 退出整个循环，使循环立马结束</p><h3 id="命名规范"><a class="markdownIt-Anchor" href="#命名规范">#</a> 命名规范</h3><h4 id="标志符命名规范"><a class="markdownIt-Anchor" href="#标志符命名规范">#</a> 标志符命名规范</h4><p><a href="https://imgtu.com/i/IGtrss"><img src="https://z3.ax1x.com/2021/11/08/IGtrss.png" alt="IGtrss.png"></a></p><h4 id="操作符规范"><a class="markdownIt-Anchor" href="#操作符规范">#</a> 操作符规范</h4><p>操作符左右两侧各保留一个空格<br>单行注释在 // 后面敲个空格</p><h4 id="循环作业"><a class="markdownIt-Anchor" href="#循环作业">#</a> 循环作业</h4><p><a href="https://imgtu.com/i/IGtgoV"><img src="https://z3.ax1x.com/2021/11/08/IGtgoV.png" alt="IGtgoV.png"></a></p><h3 id="javascript数组"><a class="markdownIt-Anchor" href="#javascript数组">#</a> javascript 数组</h3><h4 id="数组的概念"><a class="markdownIt-Anchor" href="#数组的概念">#</a> 数组的概念</h4><p>数组是一组数据的集合，其中每个数据都被称为元素，在数组中可以存放任何类型的元素，数组是可以将数据存储在单个变量下的优雅方式</p><h4 id="创建数组"><a class="markdownIt-Anchor" href="#创建数组">#</a> 创建数组</h4><p>1.new 创建数组<br> 2. 利用数组关键字创造数组</p><h5 id="利用new创建数组"><a class="markdownIt-Anchor" href="#利用new创建数组">#</a> 利用 new 创建数组</h5><p><a href="https://imgtu.com/i/IGrSaj"><img src="https://z3.ax1x.com/2021/11/08/IGrSaj.png" alt="IGrSaj.png"></a><br> 注意 Array 的 A 要大写</p><h5 id="利用数组字面量创建数组"><a class="markdownIt-Anchor" href="#利用数组字面量创建数组">#</a> 利用数组字面量创建数组</h5><p>[] 是数组的的字面量</p><blockquote><p>var arr = [];<br> 这样便创建了一个空的数组<br> var arr = [1,1,2,3,‘pink’,true]</p></blockquote><p>在数组内可以放任何的数据类型，但是每一个数据之间必须用逗号分隔.</p><h4 id="获取数组元素"><a class="markdownIt-Anchor" href="#获取数组元素">#</a> 获取数组元素</h4><h5 id="数组的索引"><a class="markdownIt-Anchor" href="#数组的索引">#</a> 数组的索引</h5><p>索引又被称为下标：用来访问数组元素的序号 (数组下标从 0 开始)<br><a href="https://imgtu.com/i/IGNAfS"><img src="https://z3.ax1x.com/2021/11/08/IGNAfS.png" alt="IGNAfS.png"></a></p><blockquote><pre><code> 数组名[索引号] console.log(arr[1])</code></pre></blockquote><p><strong>索引号从 0 开始</strong><br>如果没有该数组元素 就会输出 undefined</p><h4 id="遍历数组"><a class="markdownIt-Anchor" href="#遍历数组">#</a> 遍历数组</h4><p>遍历：就是把数组中的每个元素从头到尾访问一次</p><blockquote><pre><code>eg:var arr = [1, 2, 3, 4, 5, 'pink'];   for (i = 0; i &lt; 6; i++) {   console.log(arr[i]);   }</code></pre></blockquote><p>输出的时候计数器当索引号来用</p><h5 id="数组长度"><a class="markdownIt-Anchor" href="#数组长度">#</a> 数组长度</h5><p>数组名.length  可以访问数组中的数组元素的数量</p><blockquote><pre><code>console.log(arr.length);</code></pre></blockquote><p>同时 数组名.length 可以动态检测数组元素的个数</p><h4 id="数组中新增元素"><a class="markdownIt-Anchor" href="#数组中新增元素">#</a> 数组中新增元素</h4><h5 id="通过修改length长度新增数组长度"><a class="markdownIt-Anchor" href="#通过修改length长度新增数组长度">#</a> 通过修改 length 长度新增数组长度</h5><blockquote><pre><code>   var arr = ['pink', 'red', 'blue'];   arr.length = 5</code></pre></blockquote><p>如果扩容的数组元素中没有给值，其中的元素是 undefined</p><h5 id="修改索引号-增加数组元素"><a class="markdownIt-Anchor" href="#修改索引号-增加数组元素">#</a> 修改索引号 增加数组元素</h5><blockquote><pre><code>var arr = ['pink', 'red', 'blue'];arr[3] = 'pink'</code></pre></blockquote><p>如果这个索引号原先已经被占用，就会替换原来的数组元素<br><strong>不要直接给数组名赋值，否则会覆盖掉以前的数据，导致数据一个都没有了</strong></p><h4 id="筛选数组的方法"><a class="markdownIt-Anchor" href="#筛选数组的方法">#</a> 筛选数组的方法</h4><h5 id="方法1"><a class="markdownIt-Anchor" href="#方法1">#</a> 方法 1</h5><blockquote><pre><code>   var arr = [1, 2, 3, 4, 5, 6, 8, 11, 45, 13, 48, 46, 13];   var newArr = [];   var j = 0;   for (var i = 0; i &lt; arr.length; i++) {       if (arr[i] &gt; 10) {           newArr[j] = arr[i]           j++       }   }   console.log(newArr);</code></pre></blockquote><p>这里通过声明一个变量 j 来使新数组从 0 开始</p><h5 id="方法2"><a class="markdownIt-Anchor" href="#方法2">#</a> 方法 2</h5><blockquote><pre><code>   var arr = [1, 2, 3, 4, 5, 6, 8, 11, 45, 13, 48, 46, 13];   var newArr = [];   for (var i = 0; i &lt; arr.length; i++) {       if (arr[i] &gt; 10) {           newArr[newArr.length] = arr[i]       }   }   console.log(newArr);</code></pre></blockquote><p>将 j 替换成 newArr, 最开始当新数组里面没有元素时是 0，当有元素时 newArr.length 开始不断增多</p><h4 id="翻转数组"><a class="markdownIt-Anchor" href="#翻转数组">#</a> 翻转数组</h4><blockquote><pre><code>   var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];   var newArr = [];   for (i = arr.length - 1; i &gt;= 0; i--) {       newArr[newArr.length] = arr[i]   }   console.log(newArr);</code></pre></blockquote><p>这里需要注意的是：元素的索引号的最大值等于数组长度 - 1</p><h4 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序">#</a> 冒泡排序</h4><p>是一种算法，把一系列数组按照一定的顺序进行排列显示 (从小到大或者从大到小)<br> 算法：观察执行过程，从而找到其中的规律，并且找到代码</p><blockquote><pre><code>   var arr = [1, 5, 4, 3, 2];   for (var i = 0; i &lt; arr.length - 1; i++) { // 外层循环次数       for (var j = 0; j &lt; arr.length - i - 1; j++) { // 内层循环次数           if (arr[j] &gt; arr[j + 1]) {               var temp = arr[j]               arr[j] = arr[j + 1]               arr[j + 1] = temp           }       }   }</code></pre></blockquote><h3 id="javascript函数"><a class="markdownIt-Anchor" href="#javascript函数">#</a> javascript 函数</h3><h4 id="函数的概念"><a class="markdownIt-Anchor" href="#函数的概念">#</a> 函数的概念</h4><p>js 中经常会定义相同的代码，这些代码可能会大量使用<br>函数：就是封装了一段可被重复调用执行的代码块，通过调用代码块可以实现大量代码的重复使用.</p><h4 id="函数的使用"><a class="markdownIt-Anchor" href="#函数的使用">#</a> 函数的使用</h4><p>步骤：1. 声明函数 2. 调用函数</p><h5 id="声明函数"><a class="markdownIt-Anchor" href="#声明函数">#</a> 声明函数</h5><blockquote><pre><code>function 函数名() {函数体}</code></pre></blockquote><p>注意事项：1.function 声明函数的关键字 全部小写 2. 函数是做某件事情，函数名一般是动词 3. 函数不调用自己不会执行</p><h5 id="调用函数"><a class="markdownIt-Anchor" href="#调用函数">#</a> 调用函数</h5><blockquote><pre><code>函数名();</code></pre></blockquote><p>调用函数时，千万不要忘了加小括号.</p><h5 id="函数的参数"><a class="markdownIt-Anchor" href="#函数的参数">#</a> 函数的参数</h5><p>我们可以利用函数的参数实现函数重复不同的代码<br>参数: 1. 形参 2. 实参<br><a href="https://imgtu.com/i/IGrNod"><img src="https://z3.ax1x.com/2021/11/08/IGrNod.png" alt="IGrNod.png"></a></p><blockquote><pre><code>function (形参1,形参2,....) {  在声明函数的小括号里面是形参 }函数名(实参1,实参2...)     在函数调用的小括号里面是实参</code></pre></blockquote><p>形参类似于一个变量来接受实参的<br>函数的参数可以有也可以没有，个数不限<br>多个参数之间用逗号隔开</p><h6 id="函数形参实参个数匹配"><a class="markdownIt-Anchor" href="#函数形参实参个数匹配">#</a> 函数形参实参个数匹配</h6><p>1. 如果实参的个数和形参的个数一直，则正常输出结果<br> 2. 如果实参的个数多于形参的个数，会取到形参的个数，实参中多的自动忽略<br> 3. 如果实参的个数小于形参的个数，num2 可以看做一个变量但是没有接收值，所以最终的结果就是 undefined<br><a href="https://imgtu.com/i/IGN3fU"><img src="https://z3.ax1x.com/2021/11/08/IGN3fU.png" alt="IGN3fU.png"></a></p><h6 id="函数参数小结"><a class="markdownIt-Anchor" href="#函数参数小结">#</a> 函数参数小结</h6><p><a href="https://imgtu.com/i/IGrBSP"><img src="https://z3.ax1x.com/2021/11/08/IGrBSP.png" alt="IGrBSP.png"></a></p><h5 id="函数的返回值"><a class="markdownIt-Anchor" href="#函数的返回值">#</a> 函数的返回值</h5><h6 id="return语句"><a class="markdownIt-Anchor" href="#return语句">#</a> return 语句</h6><p>函数只是实现某种功能，最终的结果需要返回给函数的调用者函数名 () 通过 return 实现<br>只要函数遇到 return 就把后面的结果返回给函数的调用者 函数名 ()=return 后面的结果</p><blockquote><pre><code> function 函数名() {       return 需要返回的结果; } 函数名();</code></pre></blockquote><p>代码验证</p><blockquote><pre><code>   function getSum(num1, num2) {       return num1 + num2;   }   console.log(getSum(1, 3));</code></pre></blockquote><p>这样输出的结果就是 4 (来自于 1+3)</p><p>return 终止函数：函数遇到 return 就终止函数<br> return 的返回值:return 只能返回一个值，如果有多个值，return 只返回最后一个值<br>如果想要返回多个数值时，我们可以将数值放在一个数组里面，一个数组代表一个结果<br>函数如果 return 则返回的是 return 后面的值，如果函数没有 return 就返回 undefined<br>break,continue,return 的区别:<br><a href="https://imgtu.com/i/IGrDQf"><img src="https://z3.ax1x.com/2021/11/08/IGrDQf.png" alt="IGrDQf.png"></a></p><h4 id="函数的理解"><a class="markdownIt-Anchor" href="#函数的理解">#</a> 函数的理解</h4><p><a href="https://imgtu.com/i/IGNJl4"><img src="https://z3.ax1x.com/2021/11/08/IGNJl4.png" alt="IGNJl4.png"></a></p><h4 id="函数的作业"><a class="markdownIt-Anchor" href="#函数的作业">#</a> 函数的作业</h4><p><a href="https://imgtu.com/i/IGrWYn"><img src="https://z3.ax1x.com/2021/11/08/IGrWYn.png" alt="IGrWYn.png"></a></p><h4 id="arguments的作用"><a class="markdownIt-Anchor" href="#arguments的作用">#</a> arguments 的作用</h4><p>当我们不确定有多少个参数传递时，可以用 argument 在获取，他实际上是当前函数的一个内置对象，arguements 存储了传递过来的所有实参</p><p>arguments 实际上是伪数组.<br> 伪数组:<br>1. 具有数组的 length 属性.<br>2. 按照索引的方式进行存储.<br>3. 没有真正数组的一些方法:pop () 等</p><h4 id="函数可以调用另外一个函数"><a class="markdownIt-Anchor" href="#函数可以调用另外一个函数">#</a> 函数可以调用另外一个函数</h4><h4 id="函数的两种声明方式"><a class="markdownIt-Anchor" href="#函数的两种声明方式">#</a> 函数的两种声明方式</h4><p>1. 利用函数关键字自定义函数</p><blockquote><pre><code>function fn() {}fn()</code></pre></blockquote><p>也被称为命名函数</p><p>2. 函数表达式</p><blockquote><pre><code>var 变量名 = function() {}</code></pre></blockquote><p>又被叫做匿名函数<br>这是变量名不是函数名<br>函数表达式声明方式跟声明变量差不多，只不过变量里面存的是值，而函数表达式里面存的是函数。</p><h3 id="作用域"><a class="markdownIt-Anchor" href="#作用域">#</a> 作用域</h3><h4 id="作用域概述"><a class="markdownIt-Anchor" href="#作用域概述">#</a> 作用域概述</h4><p>1.js 的作用域就是代码名字在某个范围内起作用和效果 目的是为了提高程序的可靠性，重要的是减少命名冲突<br> 2.js 的作用域 (es6) 之前：全局作用域 和 局部作用域<br> 3. 全局作用域：整个 script 标签 或者是一个单独的 js 文件<br> 4. 局部作用域：在函数内部就是局部作用域，这个代码的名字只在函数内部起作用和效果 又叫做函数作用域</p><h4 id="变量的作用域"><a class="markdownIt-Anchor" href="#变量的作用域">#</a> 变量的作用域</h4><p>根据作用域的不同我们变量分为全局变量和局部变量<br> 1. 全局变量：在全局作用域下的变量 在全局下都可以使用 (当然包括函数内部)<br> 2. 局部变量：在局部作用域下的变量 在函数内部的变量就是局部变量 只能在函数内部使用<br> 3. 特殊情况：如果在函数内部没有声明直接赋值的变量也称为全局变量，函数的形参也可以看成局部变量</p><p>从执行效率来看全局变量和局部变量<br> 1. 全局变量只有浏览器关闭的时候才会销毁，比较占内存资源<br> 2. 局部变量 当我们程序执行完毕就会销毁，比较节约内存支援<br><strong>现阶段 js 没有块级作用域</strong></p><h4 id="作用域链"><a class="markdownIt-Anchor" href="#作用域链">#</a> 作用域链</h4><p>内部函数访问外部函数的电量，采取的是链式查找的方式来决定取哪种值，这种结构我们称为作用域链<br>内部函数是可以访问外部函数的变量的</p><h3 id="javascript预解析"><a class="markdownIt-Anchor" href="#javascript预解析">#</a> javascript 预解析</h3><p>1.js 解析器在运行 js 代码的时候分为两部分：先进行预解析，再进行代码执行<br> (2). 预解析:js 引擎会把 js 里面所有的 var 还有 function 提升到当前作用域的最前面<br> (3). 代码执行：按照代码书写的顺序从上往下执行.<br>2. 预解析分为变量预解析 (变量提升) 和函数预解析 (函数执行)<br>(1). 变量提升：就是把所有的变量声明提升到当前的作用域最前面 不提升赋值</p><blockquote><pre><code>console.log(num);var num= 10;在预解析的时候执行顺序是这样的var num;console.log(num);num=10</code></pre></blockquote><p>(2). 函数声明：就是先把函数声明提升到当前作用域的最前面，不执行函数.</p><h3 id="js对象"><a class="markdownIt-Anchor" href="#js对象">#</a> js 对象</h3><h4 id="对象概念"><a class="markdownIt-Anchor" href="#对象概念">#</a> 对象概念</h4><p>对象是一个具体的事物 (不是泛指)<br> 比如 明星不是对象 但刘德华是对象<br><a href="https://imgtu.com/i/IGNspD"><img src="https://z3.ax1x.com/2021/11/08/IGNspD.png" alt="IGNspD.png"></a></p><h4 id="对象的使用方向"><a class="markdownIt-Anchor" href="#对象的使用方向">#</a> 对象的使用方向</h4><p>保存一个值可以使用变量，保存多个值可以使用数组，但如果保存一个人的完整信就需要用到对象了</p><h4 id="创建对象的三种方式"><a class="markdownIt-Anchor" href="#创建对象的三种方式">#</a> 创建对象的三种方式</h4><p>1. 利用字面量创建对象<br> 2. 利用 new Object 创建对象<br> 3. 利用构造函数创建对象</p><h4 id="对象字面量"><a class="markdownIt-Anchor" href="#对象字面量">#</a> 对象字面量</h4><p>{} 是对象的字面量<br> 1. 里面的属性或者方法我们采取键值对的形式 键 属性名：值 属性值<br> 2. 多个属性或者方法中间用逗号隔开，函数后面加；而不加逗号<br> 3. 方法冒号后面跟的是一个匿名函数</p><h4 id="使用对象"><a class="markdownIt-Anchor" href="#使用对象">#</a> 使用对象</h4><p>调用对象的属性 我们采取 对象名。属性名</p><blockquote><p>console.log(obj.uname)</p></blockquote><p>其中这个。我们可以理解为的 比如说对象的属性<br>调用属性还有一种方法 对象名 [‘属性名’]</p><blockquote><p>console.log(abj[‘age’])</p></blockquote><p>需要注意的是 后面这种方法需要’' 而前面一种方法不需要<br>调用对象中的函数时，千万不要忘记添加小括号<br><a href="https://imgtu.com/i/IGN66H"><img src="https://z3.ax1x.com/2021/11/08/IGN66H.png" alt="IGN66H.png"></a></p><h4 id="变量-属性-函数-方法的区别"><a class="markdownIt-Anchor" href="#变量-属性-函数-方法的区别">#</a> 变量 属性 函数 方法的区别</h4><p>相同点：都是用来存储数据的<br>不同点：1. 变量 单独声明并赋值 使用的时候直接写变量名 单独存在<br> 2. 属性 在对象里面的不需要声明的 使用的时候必须是 对象。属性</p><p>函数和方法<br>相同点：都是实现某种功能 做某件事<br>不同点：函数时单独声明 并且调用的 是单独存在的<br>方法 在对象里面</p><h4 id="利用new-object来创建对象"><a class="markdownIt-Anchor" href="#利用new-object来创建对象">#</a> 利用 new Object 来创建对象</h4><blockquote><pre><code>var obj = new Object();   创建了一个空的对象obj.uname = '张三丰';</code></pre></blockquote><p>利用 等号 = 赋值的方法 添加对象的属性和方法<br>每个属性和方法之间用分号结束</p><h4 id="利用构造函数创建对象"><a class="markdownIt-Anchor" href="#利用构造函数创建对象">#</a> 利用构造函数创建对象</h4><p>构造函数 就是把我们对象里面一些相同的属性和方法抽象出来封装到函数里面<br>语法格式:</p><blockquote><pre><code>function 构造函数名() {    this.属性 = 值;    this.方法 = function() {} }使用: new 构造函数名();</code></pre></blockquote><p>1. 构造函数名的首字母要大写<br> 2. 构造函数 不需要 return 就可以返回结果<br> 3. 我们调用构造函数必须使用 new<br>4. 属性和方法前面必须添加 this<br><a href="https://imgtu.com/i/IGroOU"><img src="https://z3.ax1x.com/2021/11/08/IGroOU.png" alt="IGroOU.png"></a></p><h4 id="for-in遍历我们的对象"><a class="markdownIt-Anchor" href="#for-in遍历我们的对象">#</a> for in 遍历我们的对象</h4><blockquote><pre><code>for (变量 in 对象) {  }</code></pre></blockquote><h3 id="javascript内置对象"><a class="markdownIt-Anchor" href="#javascript内置对象">#</a> javascript 内置对象</h3><p>1. 自定义对象<br> 2. 内置对象<br> 3. 浏览器对象 (js 特有)</p><p>内置对象是 js 语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或者是最基本的属性和方法<br> Math Date Array String</p><h4 id="查阅文档"><a class="markdownIt-Anchor" href="#查阅文档">#</a> 查阅文档</h4><blockquote><pre><code>https://developer.mozilla.org/zh-CN</code></pre></blockquote><p><a href="https://imgtu.com/i/IGNW7t"><img src="https://z3.ax1x.com/2021/11/08/IGNW7t.png" alt="IGNW7t.png"></a></p><h4 id="math对象"><a class="markdownIt-Anchor" href="#math对象">#</a> Math 对象</h4><p>不是一个构造函数，不用 new 来调用，直接使用即可<br><a href="https://imgtu.com/i/IGr7mF"><img src="https://z3.ax1x.com/2021/11/08/IGr7mF.png" alt="IGr7mF.png"></a></p><p>Math.round 四舍五入中.5 是特殊数字 他往大了去  比如 - 1.5 的结果是 - 1</p><h5 id="math随机数法"><a class="markdownIt-Anchor" href="#math随机数法">#</a> Math 随机数法</h5><blockquote><pre><code>console.log(Math.random());</code></pre></blockquote><h4 id="date日期数法"><a class="markdownIt-Anchor" href="#date日期数法">#</a> Date 日期数法</h4><p>是一个构造函数 必须使用 new 来调用创建我们的日期对象</p><blockquote><pre><code>   var day = new Date();   console.log(day);</code></pre></blockquote><p>使用 date 如果没有参数 返回当前系统的当前时间<br>参数常用的写法 数字型 2019,10,01 或者是字符串型’2019-10-01’<br><a href="https://imgtu.com/i/IGrbTJ"><img src="https://z3.ax1x.com/2021/11/08/IGrbTJ.png" alt="IGrbTJ.png"></a></p><h5 id="日期格式化date"><a class="markdownIt-Anchor" href="#日期格式化date">#</a> 日期格式化 Date</h5><p><a href="https://imgtu.com/i/IGNo9S"><img src="https://z3.ax1x.com/2021/11/08/IGNo9S.png" alt="IGNo9S.png"></a><br> 返回的月份小一个月 记得月份 +1</p><h5 id="获取日期的总的毫秒形式"><a class="markdownIt-Anchor" href="#获取日期的总的毫秒形式">#</a> 获取日期的总的毫秒形式</h5><p>Date 对象是基于 1970 年 1 月 1 日 (世界标准时间) 起的毫秒数</p><blockquote><pre><code>1.valueOf()    getTime()2.var date1= +new Date();3.H5新增 console(Date.now());</code></pre></blockquote><h4 id="数组对象array"><a class="markdownIt-Anchor" href="#数组对象array">#</a> 数组对象 Array</h4><p>1. 数组字面量创建<br> 2. 利用 new Array () 创建</p><p>检测是非为数组<br> 1.instanceof Array<br>2.Array.isArray (参数)</p><h5 id="添加删除数组元素的方法"><a class="markdownIt-Anchor" href="#添加删除数组元素的方法">#</a> 添加删除数组元素的方法</h5><p><a href="https://imgtu.com/i/IGN7cQ"><img src="https://z3.ax1x.com/2021/11/08/IGN7cQ.png" alt="IGN7cQ.png"></a><br> 添加:arr.push ();arr.unshift ();<br> 删除:arr.pop ();arr.shift;</p><h5 id="数组排序"><a class="markdownIt-Anchor" href="#数组排序">#</a> 数组排序</h5><p><a href="https://imgtu.com/i/IGNqns"><img src="https://z3.ax1x.com/2021/11/08/IGNqns.png" alt="IGNqns.png"></a></p><blockquote><pre><code>       arr1.sort(function (a, b) {       return a - b //升序的顺序排列       //return b - a 是降序的顺序排列        });</code></pre></blockquote><h5 id="数组索引方法"><a class="markdownIt-Anchor" href="#数组索引方法">#</a> 数组索引方法</h5><p><a href="https://imgtu.com/i/IGNO7q"><img src="https://z3.ax1x.com/2021/11/08/IGNO7q.png" alt="IGNO7q.png"></a><br> 注意，如果有两个重复 只范湖第一个满足条件的索引号。如果里面没有相对元素返回的结果是 - 1;</p><h5 id="数组转化成字符串"><a class="markdownIt-Anchor" href="#数组转化成字符串">#</a> 数组转化成字符串</h5><p><a href="https://imgtu.com/i/IGUiu9"><img src="https://z3.ax1x.com/2021/11/08/IGUiu9.png" alt="IGUiu9.png"></a></p><h4 id="字符串对象"><a class="markdownIt-Anchor" href="#字符串对象">#</a> 字符串对象</h4><p>基本包装类型：就是把简单数据类型 包装称为了 复杂数据类型<br> (1) 把简单数据类型包装称为复杂数据类型<br> var temp = new String (‘Andy’)<br>(2) 把临时变量的值给 str<br>str=temp<br> (3) 销毁这个临时变量<br> temp = null<br><a href="https://imgtu.com/i/IGrOYR"><img src="https://z3.ax1x.com/2021/11/08/IGrOYR.png" alt="IGrOYR.png"></a></p><h5 id="字符串的不可变型"><a class="markdownIt-Anchor" href="#字符串的不可变型">#</a> 字符串的不可变型</h5><p><a href="https://imgtu.com/i/IGU1HI"><img src="https://z3.ax1x.com/2021/11/08/IGU1HI.png" alt="IGU1HI.png"></a></p><blockquote><pre><code>   var str = '改革吹风吹满地'   console.log(str.indexOf('吹',3));</code></pre></blockquote><h5 id="根据位置返回字符"><a class="markdownIt-Anchor" href="#根据位置返回字符">#</a> 根据位置返回字符</h5><p><a href="https://imgtu.com/i/IGUUgg"><img src="https://z3.ax1x.com/2021/11/08/IGUUgg.png" alt="IGUUgg.png"></a></p><h5 id="字符串操作方法"><a class="markdownIt-Anchor" href="#字符串操作方法">#</a> 字符串操作方法</h5><p><a href="https://imgtu.com/i/IGUavQ"><img src="https://z3.ax1x.com/2021/11/08/IGUavQ.png" alt="IGUavQ.png"></a></p><blockquote><pre><code>   var str = '改革春风吹满地'   console.log(str.substr(2, 2));  //第一个2是索引号的2  第二个2是取几个字符</code></pre></blockquote><h5 id="替换字符串"><a class="markdownIt-Anchor" href="#替换字符串">#</a> 替换字符串</h5><blockquote><pre><code>replace('被替换的字符','替换为的字符')</code></pre></blockquote><p>如果有相同的两个字符 只会替换前面一个字符</p><h5 id="把字符串转化成数组"><a class="markdownIt-Anchor" href="#把字符串转化成数组">#</a> 把字符串转化成数组</h5><p>split (‘分隔符’) 把字符转换成数组<br> join (‘分隔符’) 把数组转换成字符串</p><p>split 中的分隔符取决于原字符串中的分隔符是什么</p><h3 id="web-apis"><a class="markdownIt-Anchor" href="#web-apis">#</a> Web APIs</h3><p>浏览器提供的一套操作浏览器功能和页面元素的 API</p><h4 id="dom"><a class="markdownIt-Anchor" href="#dom">#</a> DOM</h4><p><a href="https://imgtu.com/i/IGrvSx"><img src="https://z3.ax1x.com/2021/11/08/IGrvSx.png" alt="IGrvSx.png"></a></p><h4 id="获取页面元素"><a class="markdownIt-Anchor" href="#获取页面元素">#</a> 获取页面元素</h4><h5 id="id获取"><a class="markdownIt-Anchor" href="#id获取">#</a> ID 获取</h5><p>getElementByld()<br> console.dir (); 打印我们返回的元素对象 更好地查看里面的属性和方法</p><h5 id="根据标签名来获取"><a class="markdownIt-Anchor" href="#根据标签名来获取">#</a> 根据标签名来获取</h5><p>element.getElementsByTagName (‘标签名’)<br> 1. 获取过来元素对象的集合 以伪数组的形式储存<br> 2. 如果页面中只有一个元素 返回的还是伪数组的形式<br> 3. 如果页面中没有这个元素 返回的是空的伪数组</p><blockquote><pre><code>   var lis = document.getElementsByTagName('ul')   var li = lis[0].getElementsByTagName('li')</code></pre></blockquote><h5 id="根据类型来获取新增html5属性"><a class="markdownIt-Anchor" href="#根据类型来获取新增html5属性">#</a> 根据类型来获取 (新增 Html5 属性)</h5><p>document.getElementsByClassName (‘类名’)<br> document.querySelector (‘选择器’) 根据选择器返回第一个元素对象<br> document.querySelectorAll (‘选择器’) 根据选择器返回所有的集合</p><h5 id="获取特殊元素"><a class="markdownIt-Anchor" href="#获取特殊元素">#</a> 获取特殊元素</h5><p>1. 获取 body 元素<br> document.body<br>2. 获取 html 元素<br> document.documentElement</p><h4 id="事件基础"><a class="markdownIt-Anchor" href="#事件基础">#</a> 事件基础</h4><p>js 让我们有能力创建动态页面，而时间是可以被 js 侦测到的行为<br>在网页中每个元素都可以产生某些触发 js 的事件</p><p>事件的组成部分<br> 1. 事件源：事件被触发的对象<br> 2. 事件类型：如何触发 什么事件 比如 鼠标点击 (onclick) 触发  还是鼠标经过触发<br> 3. 事件处理程序：通过函数赋值的方式完成</p><h5 id="执行事件的步骤"><a class="markdownIt-Anchor" href="#执行事件的步骤">#</a> 执行事件的步骤</h5><p>1. 获取事件源<br> 2. 绑定事件<br> 3. 添加事件处理程序 (采取函数赋值的形式)</p><h4 id="操作元素"><a class="markdownIt-Anchor" href="#操作元素">#</a> 操作元素</h4><h5 id="改变元素内容"><a class="markdownIt-Anchor" href="#改变元素内容">#</a> 改变元素内容</h5><p>element.innerText<br>element.innerHTML<br> 这两个属性是可读写的 可以获取元素里面的内容<br><a href="https://imgtu.com/i/IGUy5V"><img src="https://z3.ax1x.com/2021/11/08/IGUy5V.png" alt="IGUy5V.png"></a></p><h5 id="改变元素属性"><a class="markdownIt-Anchor" href="#改变元素属性">#</a> 改变元素属性</h5><h5 id="表单元素属性设置"><a class="markdownIt-Anchor" href="#表单元素属性设置">#</a> 表单元素属性设置</h5><p><a href="https://imgtu.com/i/IGURv4"><img src="https://z3.ax1x.com/2021/11/08/IGURv4.png" alt="IGURv4.png"></a></p><h5 id="修改样式属性"><a class="markdownIt-Anchor" href="#修改样式属性">#</a> 修改样式属性</h5><p>element.style 行内样式操作<br> element.className 类名样式操作<br><a href="https://imgtu.com/i/IGaMGT"><img src="https://z3.ax1x.com/2021/11/08/IGaMGT.png" alt="IGaMGT.png"></a></p><p>onfocus 获得焦点事件<br> onblur 失去焦点事件</p><h5 id="操作元素总结"><a class="markdownIt-Anchor" href="#操作元素总结">#</a> 操作元素总结</h5><p><a href="https://imgtu.com/i/IGaNIx"><img src="https://z3.ax1x.com/2021/11/08/IGaNIx.png" alt="IGaNIx.png"></a></p><h5 id="排他思想"><a class="markdownIt-Anchor" href="#排他思想">#</a> 排他思想</h5><p>先清除样式，再给当前元素设置样式</p><blockquote><pre><code>   var btn = document.getElementsByTagName('button')   for (i = 0; i &lt; btn.length; i++) {       btn[i].onclick = function () {           for (i = 0; i &lt; btn.length; i++) {               btn[i].style.backgroundColor = 'white'           }           this.style.backgroundColor = 'pink'       }   }</code></pre></blockquote><p>鼠标经过 onmouseover<br> 鼠标离开 onmouseout</p><h5 id="自定义属性值的操作"><a class="markdownIt-Anchor" href="#自定义属性值的操作">#</a> 自定义属性值的操作</h5><h6 id="获取属性值"><a class="markdownIt-Anchor" href="#获取属性值">#</a> 获取属性值</h6><p><a href="https://imgtu.com/i/IGa0zD"><img src="https://z3.ax1x.com/2021/11/08/IGa0zD.png" alt="IGa0zD.png"></a></p><h6 id="设置属性值"><a class="markdownIt-Anchor" href="#设置属性值">#</a> 设置属性值</h6><p>element. 属性 = ‘值’<br>element.setAttribute (‘属性’,‘值’)</p><p>setAttribute 主要用于设置自定义属性</p><p>removeAttribute 移除属性</p><h6 id="h5自定义属性值"><a class="markdownIt-Anchor" href="#h5自定义属性值">#</a> H5 自定义属性值</h6><p>H5 新规范：自定义属性都用 data- 开头<br> H5 新增的获取自定义属性的方法 <a href="http://element.dataset.XXX">element.dataset.XXX</a><br>dataset 是一个集合 里面存放了所有以 data 开头的自定义属性<br>如果自定义属性里面有多个 - 链接的单词，我们获取的时候采取驼峰命名法</p><p><a href="https://imgtu.com/i/IGrz6K"><img src="https://z3.ax1x.com/2021/11/08/IGrz6K.png" alt="IGrz6K.png"></a></p><h4 id="节点操作"><a class="markdownIt-Anchor" href="#节点操作">#</a> 节点操作</h4><p>为什么要学节点操作<br><a href="https://imgtu.com/i/IGaRFP"><img src="https://z3.ax1x.com/2021/11/08/IGaRFP.png" alt="IGaRFP.png"></a></p><h5 id="节点概述"><a class="markdownIt-Anchor" href="#节点概述">#</a> 节点概述</h5><p><a href="https://imgtu.com/i/IGa4SS"><img src="https://z3.ax1x.com/2021/11/08/IGa4SS.png" alt="IGa4SS.png"></a></p><h5 id="节点层级"><a class="markdownIt-Anchor" href="#节点层级">#</a> 节点层级</h5><p><a href="https://imgtu.com/i/IGaIyQ"><img src="https://z3.ax1x.com/2021/11/08/IGaIyQ.png" alt="IGaIyQ.png"></a></p><h5 id="父节点"><a class="markdownIt-Anchor" href="#父节点">#</a> 父节点</h5><p><a href="https://imgtu.com/i/IGaHwn"><img src="https://z3.ax1x.com/2021/11/08/IGaHwn.png" alt="IGaHwn.png"></a></p><h5 id="子节点"><a class="markdownIt-Anchor" href="#子节点">#</a> 子节点</h5><p><a href="https://imgtu.com/i/IGaLF0"><img src="https://z3.ax1x.com/2021/11/08/IGaLF0.png" alt="IGaLF0.png"></a><br><a href="https://imgtu.com/i/IGaboq"><img src="https://z3.ax1x.com/2021/11/08/IGaboq.png" alt="IGaboq.png"></a><br><a href="https://imgtu.com/i/IGdSOJ"><img src="https://z3.ax1x.com/2021/11/08/IGdSOJ.png" alt="IGdSOJ.png"></a></p><h5 id="兄弟节点"><a class="markdownIt-Anchor" href="#兄弟节点">#</a> 兄弟节点</h5><p><a href="https://imgtu.com/i/IGdCwR"><img src="https://z3.ax1x.com/2021/11/08/IGdCwR.png" alt="IGdCwR.png"></a><br> 解决兄弟节点的兼容性问题:<br><a href="https://imgtu.com/i/IGdumd"><img src="https://z3.ax1x.com/2021/11/08/IGdumd.png" alt="IGdumd.png"></a></p><h5 id="创建和删除节点"><a class="markdownIt-Anchor" href="#创建和删除节点">#</a> 创建和删除节点</h5><h6 id="创建节点"><a class="markdownIt-Anchor" href="#创建节点">#</a> 创建节点</h6><p><a href="https://imgtu.com/i/IGsC0e"><img src="https://z3.ax1x.com/2021/11/08/IGsC0e.png" alt="IGsC0e.png"></a></p><h6 id="添加节点"><a class="markdownIt-Anchor" href="#添加节点">#</a> 添加节点</h6><p><a href="https://imgtu.com/i/IGdGp8"><img src="https://z3.ax1x.com/2021/11/08/IGdGp8.png" alt="IGdGp8.png"></a><br>node.appendChild(child)<br> node.insertbefore (child, 指定元素);</p><h6 id="删除节点"><a class="markdownIt-Anchor" href="#删除节点">#</a> 删除节点</h6><p>code.removeChild (节点)<br>eg:ul.removeChild(ul.children[0])</p><h6 id="复制节点克隆节点"><a class="markdownIt-Anchor" href="#复制节点克隆节点">#</a> 复制节点 (克隆节点)</h6><p>node.cloneNode()<br> 如果括号为空，则只复制标签 不复制里面的内容<br>括号里面为 true 则里面的内容也跟着赋值</p><h6 id="三种动态创建元素区别"><a class="markdownIt-Anchor" href="#三种动态创建元素区别">#</a> 三种动态创建元素区别</h6><p>document.write () 如果页面加载完毕 再执行这个指令 会导致页面全部重绘<br> innerHTML<br>document.createElement(’’)<br> 最后两个大致上没有区别 但是如果需要创造很多个元素 最后一个的效率会大大提高，因为最后一个不是拼接字符串 而是在电脑中重新开辟一个新的空间</p><p><a href="https://imgtu.com/i/IGdDhV"><img src="https://z3.ax1x.com/2021/11/08/IGdDhV.png" alt="IGdDhV.png"></a><br> 改进方法:innerHTML 不采用拼接字符串的方式，而是采用数组形式拼接，现在数组中拼接字符串，然后将数组引入到 innerHTML 中</p><h4 id="dom重点核心"><a class="markdownIt-Anchor" href="#dom重点核心">#</a> DOM 重点核心</h4><p>(一) 创建<br> 1.document.write<br>2.innerHTML<br>3.createElement<br> (二) 增<br> 1.appendChild<br>2.innerBefore<br> (三) 删<br> 1.removeChild<br> (四) 改<br> 1. 修改元素属性:src,href,title<br>2. 修改普通元素内容:innerHTML,innerText<br>3. 修改表单元素:value,type,disabled<br>4. 修改元素样式:style,className<br> (五) 查<br> 1.DOM 提供的 API 方法:getElementById,getElementsByTagName  (<strong>古老用法不推荐</strong>)<br> 2.H5 提供的新方法:querySelector,querySelectorAll 提倡<br> 3. 利用节点获取元素：父 (parentNode), 子 (children), 兄 (previousElementSibing,nextElementSibing) 提倡<br> (六) 属性操作<br> 1.setAttribute: 设置 dom 的属性值<br> 2.getAttribute: 得到 dom 的属性值<br> 3.removeAttribute: 移除属性<br> (七) 事件操作<br> onclick: 鼠标点击左键触发<br> onmouseover: 鼠标经过触发<br> onmouseout: 鼠标离开触发<br> onfocus: 获得鼠标焦点触发<br> onblur: 失去鼠标焦点触发<br> onmousemove: 鼠标移动触发<br> onmouseup: 鼠标弹起触发<br> onmousedown: 鼠标按下触发</p><h4 id="事件高级导读"><a class="markdownIt-Anchor" href="#事件高级导读">#</a> 事件高级导读</h4><h5 id="注册事件"><a class="markdownIt-Anchor" href="#注册事件">#</a> 注册事件</h5><p>传统方式和方法监听注册方式<br><a href="https://imgtu.com/i/IGd6cF"><img src="https://z3.ax1x.com/2021/11/08/IGd6cF.png" alt="IGd6cF.png"></a></p><blockquote><pre><code>eventTarget.addEventListener(type,listener[,useCapture])</code></pre></blockquote><p><a href="https://imgtu.com/i/IGsktA"><img src="https://z3.ax1x.com/2021/11/08/IGsktA.png" alt="IGsktA.png"></a><br> 里面的事件类型是字符串 必定加引号 不带 on<br> 同一个元素 同一个事件可以添加多个侦听器 (事件处理程序)</p><p>AttachEvent 事件监听方式 (<strong>不提倡仅供了解</strong>)<br><a href="https://imgtu.com/i/IGsVpt"><img src="https://z3.ax1x.com/2021/11/08/IGsVpt.png" alt="IGsVpt.png"></a></p><p>注册事件兼容性解决方法<br><a href="https://imgtu.com/i/IGdW7R"><img src="https://z3.ax1x.com/2021/11/08/IGdW7R.png" alt="IGdW7R.png"></a></p><h5 id="删除事件解绑事件"><a class="markdownIt-Anchor" href="#删除事件解绑事件">#</a> 删除事件 (解绑事件)</h5><p>1. 传统法式:element.onclick = null<br>2. 方法监听事件: eventTarget.removeEventListener (type,listener [,useCapture])<br> 删除事件兼容性解决方案:<br><a href="https://imgtu.com/i/IGd4tx"><img src="https://z3.ax1x.com/2021/11/08/IGd4tx.png" alt="IGd4tx.png"></a></p><h5 id="dom事件流"><a class="markdownIt-Anchor" href="#dom事件流">#</a> DOM 事件流</h5><p><a href="https://imgtu.com/i/IGsunS"><img src="https://z3.ax1x.com/2021/11/08/IGsunS.png" alt="IGsunS.png"></a></p><p>注意事项<br><a href="https://imgtu.com/i/IGsGpq"><img src="https://z3.ax1x.com/2021/11/08/IGsGpq.png" alt="IGsGpq.png"></a><br> 捕获阶段<br><a href="https://imgtu.com/i/IGs3hn"><img src="https://z3.ax1x.com/2021/11/08/IGs3hn.png" alt="IGs3hn.png"></a><br> 冒泡阶段<br><a href="https://imgtu.com/i/IGs1ts"><img src="https://z3.ax1x.com/2021/11/08/IGs1ts.png" alt="IGs1ts.png"></a></p><h4 id="事件对象"><a class="markdownIt-Anchor" href="#事件对象">#</a> 事件对象</h4><p><a href="https://imgtu.com/i/IGdqnH"><img src="https://z3.ax1x.com/2021/11/08/IGdqnH.png" alt="IGdqnH.png"></a></p><h5 id="事件对象的常见属性和方法"><a class="markdownIt-Anchor" href="#事件对象的常见属性和方法">#</a> 事件对象的常见属性和方法</h5><p><a href="https://imgtu.com/i/IGdLBd"><img src="https://z3.ax1x.com/2021/11/08/IGdLBd.png" alt="IGdLBd.png"></a><br>e.target 返回的是触发事件的对象 而 this 返回的是绑定事件的对象，currentTarget 和 this 一样返回的是绑定事件的对象 ie678 不认识 currentTarget<br>e.type: 返回事件类型 例如 click,mouseover</p><p>组织默认事件 让链接不跳转 或者让提交按钮不提交 e.preventDefault ();<br><a href="https://imgtu.com/i/IGdx4P"><img src="https://z3.ax1x.com/2021/11/08/IGdx4P.png" alt="IGdx4P.png"></a></p><p>组织事件冒泡 e.stopPropagation ()<br> 兼容性解决方法<br><a href="https://imgtu.com/i/IGdvNt"><img src="https://z3.ax1x.com/2021/11/08/IGdvNt.png" alt="IGdvNt.png"></a></p><h5 id="事件委托"><a class="markdownIt-Anchor" href="#事件委托">#</a> 事件委托</h5><p>原理：给父节点添加侦听器，利用事件冒泡影响每一个子节点</p><h5 id="常用的鼠标事件"><a class="markdownIt-Anchor" href="#常用的鼠标事件">#</a> 常用的鼠标事件</h5><p><a href="https://imgtu.com/i/IGw9gS"><img src="https://z3.ax1x.com/2021/11/08/IGw9gS.png" alt="IGw9gS.png"></a><br> 禁止鼠标右键菜单:contextmenu 主要控制应该在何时显示上下文菜单，主要用于程序员取消默认的上下文菜单<br>禁止鼠标选中:selectstart</p><blockquote><pre><code>   document.addEventListener('contextmenu', function (e) {       e.preventDefault();   })   document.addEventListener('selectstart', function (e) {       e.preventDefault();   })</code></pre></blockquote><h5 id="鼠标事件对象"><a class="markdownIt-Anchor" href="#鼠标事件对象">#</a> 鼠标事件对象</h5><p>Mouseevent 鼠标事件对象<br> keyboard 键盘事件对象<br><a href="https://imgtu.com/i/IGwCjg"><img src="https://z3.ax1x.com/2021/11/08/IGwCjg.png" alt="IGwCjg.png"></a><br>client 以可视区为主 跟屏幕滚动没有关系<br> page 相对于文档页面的 X 和 Y 坐标<br> screen 鼠标相当于电脑屏幕的 X 和 Y 坐标 (当浏览器缩小或者放大时会变化)<br> mousemove 鼠标移动事件</p><h5 id="键盘事件对象"><a class="markdownIt-Anchor" href="#键盘事件对象">#</a> 键盘事件对象</h5><p><a href="https://imgtu.com/i/IGwkHs"><img src="https://z3.ax1x.com/2021/11/08/IGwkHs.png" alt="IGwkHs.png"></a><br> 三个事件的执行顺序是 keydown keypress keyup</p><p>KeyCode 返回键盘按键的 ASCII 的值<br> keyup 和 keydown 事件不区分字母大小写 a 和 A 得到的就是 65<br>keypress 区分字母大小写</p><h3 id="bom浏览器对象模型"><a class="markdownIt-Anchor" href="#bom浏览器对象模型">#</a> BOM 浏览器对象模型</h3><h4 id="bom概述"><a class="markdownIt-Anchor" href="#bom概述">#</a> BOM 概述</h4><p>BOM: 浏览器对象模型<br><a href="https://imgtu.com/i/IJFREt"><img src="https://z3.ax1x.com/2021/11/08/IJFREt.png" alt="IJFREt.png"></a><br>BOM 的构成<br><a href="https://imgtu.com/i/IJFf4f"><img src="https://z3.ax1x.com/2021/11/08/IJFf4f.png" alt="IJFf4f.png"></a></p><h4 id="浏览器顶级对象window"><a class="markdownIt-Anchor" href="#浏览器顶级对象window">#</a> 浏览器顶级对象 window</h4><p><a href="https://imgtu.com/i/IJF4C8"><img src="https://z3.ax1x.com/2021/11/08/IJF4C8.png" alt="IJF4C8.png"></a></p><h5 id="窗口加载事件"><a class="markdownIt-Anchor" href="#窗口加载事件">#</a> 窗口加载事件</h5><p>window.onload 窗口加载事件，当文档内容完全加载完成后会触发该事件 (包括图像 css 脚本等等)<br> 注意:<br>1. 有了 window.onload 我们就可以将 js 写在任何位置 onload 是等页面文档加载完成后 最后加载的东西<br> 2.window,onload 传统注册事件只能写一次，如果有多个，会以最后一个 window.onload 为准<br> 3. 如果使用 AddEventListener 则没有限制<br> document.addEventListener (‘DOMContentLoaded’,function (){})<br> 仅当 DOM 加载完成就开始触发，不包括样式表，图片，flash 等等<br>后一个加载更快，如果是图片较多的网站等 会因为图片刷新过快 如果使用第一个方式 有可能无法加载出 js 文件 而使用后一个方式 则在 DOM 加载完成后 就加载 js</p><h5 id="调整窗口大小事件"><a class="markdownIt-Anchor" href="#调整窗口大小事件">#</a> 调整窗口大小事件</h5><p><a href="https://imgtu.com/i/IGwEEn"><img src="https://z3.ax1x.com/2021/11/08/IGwEEn.png" alt="IGwEEn.png"></a></p><h4 id="定时器"><a class="markdownIt-Anchor" href="#定时器">#</a> 定时器</h4><h5 id="settimeout定时器"><a class="markdownIt-Anchor" href="#settimeout定时器">#</a> setTimeout () 定时器</h5><p>window.setTimeout (调用函数，[延迟的毫秒数]);<br> 在定时器到期后执行函数<br> 1.window 在调用的时候可以省略<br> 2. 时间单位是毫秒，可以省略 如果省略默认为 0<br>3. 页面中可能有很多的定时器 我们经常给定时器起一个标识符</p><p>callback 回调函数<br><a href="https://imgtu.com/i/IJFovQ"><img src="https://z3.ax1x.com/2021/11/08/IJFovQ.png" alt="IJFovQ.png"></a></p><h6 id="停止settimeout定时器"><a class="markdownIt-Anchor" href="#停止settimeout定时器">#</a> 停止 setTimeout () 定时器</h6><p>window.clearaTimeout (定时器名字)</p><h5 id="setinterval定时器"><a class="markdownIt-Anchor" href="#setinterval定时器">#</a> setInterval () 定时器</h5><p><a href="https://imgtu.com/i/IJFLEq"><img src="https://z3.ax1x.com/2021/11/08/IJFLEq.png" alt="IJFLEq.png"></a></p><p>区别:setTimeout 只调用一次回调函数<br> setInterval 会一直调用函数</p><h4 id="this指向问题"><a class="markdownIt-Anchor" href="#this指向问题">#</a> this 指向问题</h4><p>1. 全局作用域或者普通函数中 this 指向全局对象 window (定时器里面的 this 指向 window)<br> 2. 方法调用中谁调用 this 指向谁<br> 3. 构造函数中 this 可以指向构造函数<br><a href="https://imgtu.com/i/oSEMu9"><img src="https://z3.ax1x.com/2021/11/22/oSEMu9.png" alt="oSEMu9.png"></a><br><a href="https://imgtu.com/i/oSEQBR"><img src="https://z3.ax1x.com/2021/11/22/oSEQBR.png" alt="oSEQBR.png"></a></p><h4 id="js的执行队列"><a class="markdownIt-Anchor" href="#js的执行队列">#</a> js 的执行队列</h4><p>js 是单线程的 同一个时间只能做一件事<br>为了解决这个问题，利用多核 CPU 的计算能力，HTML5 允许 js 脚本创建多个线程，于是 js 中出现了同步和异步<br><a href="https://imgtu.com/i/IGwugU"><img src="https://z3.ax1x.com/2021/11/08/IGwugU.png" alt="IGwugU.png"></a></p><h5 id="js执行机制"><a class="markdownIt-Anchor" href="#js执行机制">#</a> js 执行机制</h5><p><a href="https://imgtu.com/i/IGw1b9"><img src="https://z3.ax1x.com/2021/11/08/IGw1b9.png" alt="IGw1b9.png"></a><br><a href="https://imgtu.com/i/IGwQu4"><img src="https://z3.ax1x.com/2021/11/08/IGwQu4.png" alt="IGwQu4.png"></a><br><a href="https://imgtu.com/i/IJkczF"><img src="https://z3.ax1x.com/2021/11/08/IJkczF.png" alt="IJkczF.png"></a><br><a href="https://imgtu.com/i/IJFz2F"><img src="https://z3.ax1x.com/2021/11/08/IJFz2F.png" alt="IJFz2F.png"></a><br> 事件循环：主线程不断的城府获得任务 执行任务 再获取任务 执行任务</p><h4 id="location对象"><a class="markdownIt-Anchor" href="#location对象">#</a> location 对象</h4><p><a href="https://imgtu.com/i/IJAmF0"><img src="https://z3.ax1x.com/2021/11/08/IJAmF0.png" alt="IJAmF0.png"></a><br><a href="https://imgtu.com/i/IJAnYV"><img src="https://z3.ax1x.com/2021/11/08/IJAnYV.png" alt="IJAnYV.png"></a></p><h5 id="location对象方法"><a class="markdownIt-Anchor" href="#location对象方法">#</a> location 对象方法</h5><p><a href="https://imgtu.com/i/IGwJ4x"><img src="https://z3.ax1x.com/2021/11/08/IGwJ4x.png" alt="IGwJ4x.png"></a><br>assign 能够记录历史 可以实现后退功能</p><h4 id="navigator对象"><a class="markdownIt-Anchor" href="#navigator对象">#</a> navigator 对象</h4><p>包含浏览器的信息 有很多属性 我们最常用的属性是 userAgent 该属性可以返回由客户机发送服务器的 user-agent 头部的值</p><p><a href="https://imgtu.com/i/IJAuWT"><img src="https://z3.ax1x.com/2021/11/08/IJAuWT.png" alt="IJAuWT.png"></a></p><h4 id="history对象"><a class="markdownIt-Anchor" href="#history对象">#</a> history 对象</h4><p><a href="https://imgtu.com/i/IJAQlF"><img src="https://z3.ax1x.com/2021/11/08/IJAQlF.png" alt="IJAQlF.png"></a></p><blockquote><pre><code>btn.addEventListener('click',function(){history.forward();  })back() 和 go() 同理其中go(-1) 表示后退一页 go(-1)表示后退两页</code></pre></blockquote><h3 id="pc端网页特效"><a class="markdownIt-Anchor" href="#pc端网页特效">#</a> PC 端网页特效</h3><h4 id="元素偏移量offset系列"><a class="markdownIt-Anchor" href="#元素偏移量offset系列">#</a> 元素偏移量 offset 系列</h4><p>动态获取元素位置和大小</p><ul><li>获取元素距离带有定位父元素的位置</li><li>获得元素自身的大小 (包含 padding 和 border)</li><li>返回的数值不带单位</li></ul><p><a href="https://imgtu.com/i/oih8C6"><img src="https://z3.ax1x.com/2021/11/24/oih8C6.png" alt="oih8C6.png"></a><br>offsetParent  返回的是带有定位的父元素 (没有则返回 body)<br> parentNode 返回的是最近一级的父元素 不管父元素有没有定位</p><h5 id="offset和style的区别"><a class="markdownIt-Anchor" href="#offset和style的区别">#</a> offset 和 style 的区别</h5><ul><li>offsetWidth 与 style.width<br><a href="https://imgtu.com/i/oiTCtA"><img src="https://z3.ax1x.com/2021/11/24/oiTCtA.png" alt="oiTCtA.png"></a></li></ul><h4 id="元素可视区client系列"><a class="markdownIt-Anchor" href="#元素可视区client系列">#</a> 元素可视区 client 系列</h4><p>使用 client 系列的相关属性获取元素可视区的相关信息<br>通过 client 系列的相关属性可以动态得到该元素的边框大小，元素大小等<br><a href="https://imgtu.com/i/oib09s"><img src="https://z3.ax1x.com/2021/11/24/oib09s.png" alt="oib09s.png"></a></p><h4 id="淘宝源码分析"><a class="markdownIt-Anchor" href="#淘宝源码分析">#</a> 淘宝源码分析</h4><h5 id="立即执行函数"><a class="markdownIt-Anchor" href="#立即执行函数">#</a> 立即执行函数</h5><p>不需要调用 立即执行</p><blockquote><pre><code>(function XXX() { })()  第二个小括号可以看成调用函数 也可以传递参数(function XXX(){}()) 第二个小括号可以看成调用函数 也可以传递参数</code></pre></blockquote><ul><li>XXX 为函数名 可以省略</li><li><strong>多个立即执行函数之间必须使用分号隔开</strong></li><li>好处：独立创建了一个作用域 里面所有的变量都是局部变量 避免了命名冲突的问题</li></ul><h4 id="元素滚动scroll系列"><a class="markdownIt-Anchor" href="#元素滚动scroll系列">#</a> 元素滚动 scroll 系列</h4><p>得到元素的大小 滚动距离 与页面中的滚动条有关<br><a href="https://imgtu.com/i/oAwKnP"><img src="https://z3.ax1x.com/2021/11/25/oAwKnP.png" alt="oAwKnP.png"></a><br><strong> 不包含边框 包含 padding 值</strong><br>对于超出父元素的汉字 会按照所有汉字叠加的高度计算 (真正的内容实际大小)<br> 与 client 不同的是 client 并不会计算超出的大小 而只是原有父元素的大小<br><a href="https://imgtu.com/i/oA0u8J"><img src="https://z3.ax1x.com/2021/11/25/oA0u8J.png" alt="oA0u8J.png"></a></p><h5 id="scroll事件"><a class="markdownIt-Anchor" href="#scroll事件">#</a> scroll 事件</h5><p>当滚动条发生变化时会触发的事件</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
