{
    "version": "https://jsonfeed.org/version/1",
    "title": "YogMas学习站 • All posts by \"程序设计\" category",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2021/11/06/c-yu-yan/",
            "url": "http://example.com/2021/11/06/c-yu-yan/",
            "title": "C语言",
            "date_published": "2021-11-05T16:00:00.000Z",
            "content_html": "<h1 id=\"c语言\"><a class=\"markdownIt-Anchor\" href=\"#c语言\">#</a> C 语言</h1>\n<h2 id=\"the-article-made-by-yogmas\"><a class=\"markdownIt-Anchor\" href=\"#the-article-made-by-yogmas\">#</a> the article made by Yogmas</h2>\n<h3 id=\"c语言的执行过程\"><a class=\"markdownIt-Anchor\" href=\"#c语言的执行过程\">#</a> C 语言的执行过程</h3>\n<p>1. 预处理：可以给程序添加内容也可以修改程序 (例如: #include&lt;stdio.h&gt; 就会在预处理中运用 stdio.h 中的内容对源代码进行处理)<br>\n 2. 编译：将预处理过的语言转变为机器指令.<br>\n3. 链接：把编译器产生的目标代码和所需的其他附加代码整合到一起，产生最终完全可执行的程序.<br>\n(这三个过程是自动实现的)</p>\n<h3 id=\"c语言开始\"><a class=\"markdownIt-Anchor\" href=\"#c语言开始\">#</a> C 语言开始</h3>\n<h4 id=\"基本结构\"><a class=\"markdownIt-Anchor\" href=\"#基本结构\">#</a> 基本结构</h4>\n<blockquote>\n<p>指令<br>\n int main (void)<br>\n{<br>\n语句<br>\n}</p>\n</blockquote>\n<h4 id=\"指令\"><a class=\"markdownIt-Anchor\" href=\"#指令\">#</a> 指令</h4>\n<p>例如 #include &lt;stdio.h&gt; 这条指令说明在编译前将 &lt; stdio.h &gt; 中的信息包含到程序中</p>\n<h4 id=\"函数\"><a class=\"markdownIt-Anchor\" href=\"#函数\">#</a> 函数</h4>\n<p>函数分为两类，一类是程序员写的函数，一类是作为 C 语言实现的一部分提供的函数，我们把后者称为库函数。</p>\n<h4 id=\"语句\"><a class=\"markdownIt-Anchor\" href=\"#语句\">#</a> 语句</h4>\n<p>一种是调用语句 例如 printf (\"\"); 就是调用打印函数，将内容打印在屏幕上</p>\n<p>一种是返回语句<br>\n<strong> C 语言的每条语句都要以；结尾</strong></p>\n<h4 id=\"注释\"><a class=\"markdownIt-Anchor\" href=\"#注释\">#</a> 注释</h4>\n<blockquote>\n<pre><code>/*     */ \n</code></pre>\n</blockquote>\n<p>注释中的内容不会计入到程序中，只是方便程序员观看理解内容</p>\n<p>“盒子形状” 注释</p>\n<blockquote>\n<pre><code>    /*************************\n    *                        *\n    *                        *\n    *************************/\n</code></pre>\n</blockquote>\n<p>如此可以方便程序员更好地观察到注释</p>\n<p>C99 提供了另一种注释的方法</p>\n<blockquote>\n<pre><code>// XXXXXXXXX\n  双斜杠注释\n   这种风格的注释会在行末自动终止，注释第二行还应该添加双斜杠\n</code></pre>\n</blockquote>\n<p>优点：多行 // 可以让注释更加醒目，由于每一行都必须添加 // 可以有效防止注释吞没程序的事情发生</p>\n<h4 id=\"变量和赋值\"><a class=\"markdownIt-Anchor\" href=\"#变量和赋值\">#</a> 变量和赋值</h4>\n<p>程序进行一系列的运算，会有一种临时存储数据的方法，这种储存单元被称为变量</p>\n<h4 id=\"类型\"><a class=\"markdownIt-Anchor\" href=\"#类型\">#</a> 类型</h4>\n<p>每个变量都有一个类型，来说明所储存的数据的种类<br>\n列入 int (整数) 类型和 float (小数) 类型</p>\n<p>同时 float 类型可以储存的数可以比 int 大很多，但是坏处就是 float 的计算可能更加缓慢，而且会造成一定量的误差</p>\n<h4 id=\"声明\"><a class=\"markdownIt-Anchor\" href=\"#声明\">#</a> 声明</h4>\n<p>声明变量首先确定变量的类型，然后说明变量的名字<br>\n eg int height<br>\nint 就是变量的类型，而 height 就是变量的名字<br>\n<strong> main 的声明要放在语句之前</strong></p>\n<h4 id=\"赋值\"><a class=\"markdownIt-Anchor\" href=\"#赋值\">#</a> 赋值</h4>\n<p>变量通过赋值语句获得值</p>\n<blockquote>\n<pre><code>eg: height=8\n</code></pre>\n</blockquote>\n<p>这种确定的数值称为常量<br>\n赋值右侧可以是一个含有常量，变量和运算符的公式，在 C 语言中称为<strong>表达式</strong></p>\n<h4 id=\"显示变量的值\"><a class=\"markdownIt-Anchor\" href=\"#显示变量的值\">#</a> 显示变量的值</h4>\n<blockquote>\n<p>eg:pritnf(\"%d \\n\",height)</p>\n</blockquote>\n<p>这里 % d 是一个占位符，用来指明在显示过程中变量 height 的显示位置</p>\n<p>% d 只用于 int     % f 用于 float 类型变量 f 显示小数点后六位，没有的用 0 补齐<br>\n<strong>注意声明和赋值可以同时进行</strong></p>\n<blockquote>\n<p>eg: int weight=8</p>\n</blockquote>\n<p>需要注意的是，以下这种情况只有 width 拥有初始化器 10</p>\n<blockquote>\n<p>int height,length,width=10</p>\n</blockquote>\n<h4 id=\"宏定义给常量命名\"><a class=\"markdownIt-Anchor\" href=\"#宏定义给常量命名\">#</a> 宏定义给常量命名</h4>\n<blockquote>\n<p>eg:#define INCHES 166</p>\n</blockquote>\n<p>在后面的程序中所有的 INCHES 都会被替换成 166，这里需要注意的，一般宏定义的名称都用大写字母表示，这里没有硬性规定，但这是程序员遵循了几十年的基本准则，可以方便程序更方便的阅读<br>\n同样后面的 166 也可以为一个表达式，表达式建议用括号括上<br>\n<strong>注意 C 语言四舍五入时向下取整</strong></p>\n<h4 id=\"标识符\"><a class=\"markdownIt-Anchor\" href=\"#标识符\">#</a> 标识符</h4>\n<p>在编写程序时，需要进行大量的命名，这些名字被称为<strong>标识符</strong>，在 C 语言中标识符可以有字母，数字，和下划线，但是必须<strong>以字母或者下划线开头</strong></p>\n<p>同时标识符是区分大小写的也就是说 JOB 和 job 是两个完全不同的标识符</p>\n<h4 id=\"关键字\"><a class=\"markdownIt-Anchor\" href=\"#关键字\">#</a> 关键字</h4>\n<p>关键字对 C 编译器有着特殊的意义，因此这些关键字不能作为标识符来使用</p>\n<p><a href=\"https://imgtu.com/i/IQ9uZQ\"><img src=\"https://z3.ax1x.com/2021/11/06/IQ9uZQ.md.jpg\" alt=\"IQ9uZQ.md.jpg\"></a></p>\n<h4 id=\"书写规范\"><a class=\"markdownIt-Anchor\" href=\"#书写规范\">#</a> 书写规范</h4>\n<p>语句可以分开放在任意多行内。<br>\n记号间的宫格可以让我们更容易区分记号，基于这个原因，我通常会在每个运算符的前后都放上一个空格</p>\n<blockquote>\n<pre><code> eg volume = height * width * length\n</code></pre>\n</blockquote>\n<p>缩进有助于轻松识别程序嵌套</p>\n<p>空行可以把程序分为逻辑单元，从而使读者更容易辨别程序的结构，没有空行的程序很难阅读，就像不分章节的书一样.</p>\n<h3 id=\"格式化输入输出\"><a class=\"markdownIt-Anchor\" href=\"#格式化输入输出\">#</a> 格式化输入 / 输出</h3>\n<h4 id=\"printf函数\"><a class=\"markdownIt-Anchor\" href=\"#printf函数\">#</a> printf 函数</h4>\n<blockquote>\n<pre><code>   printf(\" i = %d , j = %d\",i,j);\n   printf(格式化字符串,表达式1，表达式2,...;)\n</code></pre>\n</blockquote>\n<p>格式化字母串包含<strong>普通字符</strong>和<strong>转换说明</strong><br>\n转换说明以 % 开头，% 后面的信息指定了把数值从内部形式转换为打印字母的方法<br>\n eg:% d 表示把 int 型数值从二进制转换成十进制的字符串</p>\n<p>注意编译器不会检测格式串中转换说明的数量是否和输出项的数量相匹配，但是如果多于或者少于会让程序简单地无意义地输出<br>\n如果转换说明的个数小于变量数，多的变量就无法显示出来<br>\n变量和占位符不匹配时，就是显示出一个无意义的数值.<br>\n<a href=\"https://imgtu.com/i/IQ9FPI\"><img src=\"https://z3.ax1x.com/2021/11/06/IQ9FPI.png\" alt=\"IQ9FPI.png\"></a></p>\n<h5 id=\"转换说明\"><a class=\"markdownIt-Anchor\" href=\"#转换说明\">#</a> 转换说明</h5>\n<h5 id=\"标志\"><a class=\"markdownIt-Anchor\" href=\"#标志\">#</a> 标志</h5>\n<p>-: 左对齐，也就是加空格或 0 时加在后面<br>\n不加 - 默认为右对齐，也就是加空格或 0 时加在前面</p>\n<p>0: 加 0 表示用空格代替 0，不加 0 时输出的值多的用空格代替</p>\n<h6 id=\"最小栏宽m\"><a class=\"markdownIt-Anchor\" href=\"#最小栏宽m\">#</a> 最小栏宽 m</h6>\n<p>最小栏宽 m 指定了要显示的最少字符数量 (<strong>m 表示了输出的数最少占几列</strong>)，如果要系那是的字符数少于 m，那么值在字段内是右对齐的 (换句话说，在值得前面显示空格)<br>\n 例如 %4d 将以<strong>空格 123</strong> 的形式显示数 123，如果要显示的值所需字符多于 m，那么栏宽会自动拓展为所需的尺寸。因此，转换说明 %4d 将以 12345 的形式显示数 12345，而不会丢失数字。在 m 前放上一个负号，会导致左对齐；转换说明 %-4d 将以<strong> 123 空格</strong>的形式显示 123</p>\n<h6 id=\"精度p\"><a class=\"markdownIt-Anchor\" href=\"#精度p\">#</a> 精度 p</h6>\n<p>精度的含义很难 6+<br>\n+ 描述，因为他依赖于转换指定符号<br>\n d:p 指明了待限制数字的最少个数 (包括空格)<br>\n, 如果省略 p，则默认它的值为 1<br>\ne: 表示科学计数法形式的浮点数。p 指明了小数点后应该出现的数字个数 (默认值为 6) 如果 p 为 0 则不显示小数点<br>\n g: 自动选 f 格式或 e 格式中较短的一种输出，且不输出无意义的 0<br>\no：无符号数转化为八进制数<br>\n x：无符号数转化为十六进制数<br>\n<a href=\"https://imgtu.com/i/IQ9ARP\"><img src=\"https://z3.ax1x.com/2021/11/06/IQ9ARP.png\" alt=\"IQ9ARP.png\"></a><br>\n<a href=\"https://imgtu.com/i/IQ9Exf\"><img src=\"https://z3.ax1x.com/2021/11/06/IQ9Exf.png\" alt=\"IQ9Exf.png\"></a></p>\n<h5 id=\"转义序列\"><a class=\"markdownIt-Anchor\" href=\"#转义序列\">#</a> 转义序列</h5>\n<p>警报响铃符:    \\a<br>\n 回退符:     \\b<br>\n 换行符:     \\n<br>\n 水平制表符：   \\t<br>\n“:”( \\  + 特殊字符 = 特殊字符 )</p>\n<h4 id=\"scanf函数\"><a class=\"markdownIt-Anchor\" href=\"#scanf函数\">#</a> scanf 函数</h4>\n<blockquote>\n<p>scanf (\"&amp;d\", 变量名)</p>\n</blockquote>\n<p>scanf 函数起到读取用户输入到屏幕的数据<br>\n pritnf 函数起到将程序中的数据显示到屏幕上的作用<br>\n scanf 与 prinf 函数是相对的<br>\n scanf 函数的工作原理 这里不一一叙述<br>\n可见程序与设计第 32 页 3.2.1</p>\n<p>另外 % i 也可以充当整数的占位符，在 printf 中与 % d 没有区别，但是在 scanf 中 % i 可以储存 10 进制，8 进制，16 进制的数字，而 % d 只能储存 10 进制的数字，如果输入的数前面有 0 那么 % i 会当成 8 进制处理，如果前面有 0x 那么输入的数会当成 16 进制处理，所以一般情况下我们坚持使用 % d，防止因为在数字前面加入 0 而导致数据识别错误</p>\n<h4 id=\"表达式\"><a class=\"markdownIt-Anchor\" href=\"#表达式\">#</a> 表达式</h4>\n<h5 id=\"算术运算符\"><a class=\"markdownIt-Anchor\" href=\"#算术运算符\">#</a> 算术运算符</h5>\n<blockquote>\n<p>一元运算符: + 正号  - 负号<br>\n二元运算符: + 加法 - 减法  * 乘法  / 除法 % 求余</p>\n</blockquote>\n<p>可能产生的意外结果</p>\n<blockquote>\n<p>两个操作数都是整数时，结果会进行四舍五入，例如 1/2 的结果是 0 而不是 0.5<br>\n% 要求操作数是整数 如果两个操作数中有一个不是整数，程序将无法编译通过<br>\n根据 C89 标准，如果两个运算符中有一个为负数，那么结果不确定，可能向上取整，也可能向下取整<br>\n在 C99 标准中 除法的结果总是趋向 0 截取    i% j 的结果的值得负号与 i 相同 例如 - 9%7 的结果为 - 2</p>\n</blockquote>\n<h5 id=\"优先级和结合性\"><a class=\"markdownIt-Anchor\" href=\"#优先级和结合性\">#</a> 优先级和结合性</h5>\n<blockquote>\n<p>最高优先级: + - (一元运算符)  *  /  %<br>\n 最低优先级:    +  -  (二元运算符)</p>\n</blockquote>\n<p>当有多个相同优先级的符号时，从左到右依次结合.<br>\n<a href=\"https://imgtu.com/i/IQ99VH\"><img src=\"https://z3.ax1x.com/2021/11/06/IQ99VH.png\" alt=\"IQ99VH.png\"></a></p>\n<h5 id=\"赋值运算符\"><a class=\"markdownIt-Anchor\" href=\"#赋值运算符\">#</a> 赋值运算符</h5>\n<p>求出表达式的值后，将值储存在变量中，就需要对变量进行赋值</p>\n<p>如果变量表示的含义和所输入的数字不同，将会把数字改成变量所对应的数字<br>\n例如: int i=72.999   这个时候 i 对应的值就是 72 而不是 72.999</p>\n<p>多个运算符可以串联在一起<br>\n i = j = k = 0;<br>\n 需要注意的是，赋值表达式是从右开始赋值的<br>\n i = (j = (k = 0))</p>\n<h5 id=\"左值\"><a class=\"markdownIt-Anchor\" href=\"#左值\">#</a> 左值</h5>\n<p>大多数 C 语言运算符允许他们的操作数是变量，常量，或者是其他运算符表达式，但是他们的<strong>左值</strong>必须是对象</p>\n<p>目前为止<strong>变量</strong>是唯一的左值</p>\n<h5 id=\"复合赋值\"><a class=\"markdownIt-Anchor\" href=\"#复合赋值\">#</a> 复合赋值</h5>\n<blockquote>\n<p>复合运算符 -=,*=,/=,%=,+=<br>\n 另外 5 种赋值运算符将在后面的章节中介绍</p>\n</blockquote>\n<p>v += e 表示 v 加上 e 再把结果储存在 v 中<br>\n这并不等价于 v = v+e 例如变量 i*=j+k 就不等于 i= i*j + k</p>\n<p>复合赋值运算符同样也是右结合的<br>\n语句 i += j += k 表示 i += (j += k)</p>\n<p>最常使用的两种运算是 自增和自减<br>\n例如 i = i + 1 而复合运算符可以缩短这串代码 可以改写为 i += 1</p>\n<h5 id=\"自增运算符和自减运算符\"><a class=\"markdownIt-Anchor\" href=\"#自增运算符和自减运算符\">#</a> 自增运算符和自减运算符</h5>\n<p>C 语言还允许使用 ++ (自增) 和 – (自减) 运算符将这些语句缩得更短<br>\n实际上自增和自减运算符的使用非常复杂，原因是 ++ 和 -- 既可以作为前缀，也可以作为后缀，根据实际使用情况而定</p>\n<p>而这种情况实际上是有副作用的，副作用的效果就是自增 i</p>\n<p>前缀自增和后缀自增的区别：前缀自增表示先自增 i 再将变量 i 代入表达式中，后缀自增表示先把变量 i 代入表达式中，再自增 i</p>\n<p>并且在同一个句子中多次使用 ++ 和 -- 往往难以理解，例如<br>\n i = 1; j = 2 ; k = <ins>i + j</ins>;</p>\n<p>后缀<ins>和 -- 优先级 比正号和负号高，并且都是左结合<br>\n前缀</ins>和 -- 优先级和正号负号相同，并且都是右结合</p>\n<h4 id=\"选择语句\"><a class=\"markdownIt-Anchor\" href=\"#选择语句\">#</a> 选择语句</h4>\n<h5 id=\"逻辑表达式\"><a class=\"markdownIt-Anchor\" href=\"#逻辑表达式\">#</a> 逻辑表达式</h5>\n<p>测试表达式的结果是 \"真\" 还是 \"假\"，这类表达式只有这两个效果，翻译为电脑语言就是这个表示只会输出两个值 0 或者 1<br>\n<a href=\"https://imgtu.com/i/IQ9ZM8\"><img src=\"https://z3.ax1x.com/2021/11/06/IQ9ZM8.png\" alt=\"IQ9ZM8.png\"></a><br>\n 逻辑运算符对操作数进行短路计算，这些运算符首先计算出左操作数的值，然后计算出右操作数的值，如果做操作数的值可以直接推导表达式的值，那么将不计算右操作数的值</p>\n<p>运算符！的优先级等于一元正负号的优先级，而运算符 &amp;&amp; 和 || 的优先级低于关系运算符和判等运算符，运算符！是右结合的，而运算符 &amp;&amp; 和运算符 || 是左结合的.</p>\n<h5 id=\"关系运算符\"><a class=\"markdownIt-Anchor\" href=\"#关系运算符\">#</a> 关系运算符</h5>\n<p><a href=\"https://imgtu.com/i/IQ9PIA\"><img src=\"https://z3.ax1x.com/2021/11/06/IQ9PIA.png\" alt=\"IQ9PIA.png\"></a></p>\n<p>需要注意的是 i &lt; j &lt; k 并不是所想象的 j 处在 i 和 k 的中间值得意思，表达式是左结合的<br>\n所以原式式 (i &lt; j) &lt; k  先对 i &lt; j 进行判定，输出 0 或者 1 来和 k 进行比较</p>\n<h5 id=\"判等运算符\"><a class=\"markdownIt-Anchor\" href=\"#判等运算符\">#</a> 判等运算符</h5>\n<p><a href=\"https://imgtu.com/i/IQ9esS\"><img src=\"https://z3.ax1x.com/2021/11/06/IQ9esS.png\" alt=\"IQ9esS.png\"></a></p>\n<p>i &lt;j == j &lt; k 等价于 (i &lt; j) == (j &lt; k)<br>\n 只有当 两边同为真或者同为假的时候 输出结果为真</p>\n<h5 id=\"运算顺序\"><a class=\"markdownIt-Anchor\" href=\"#运算顺序\">#</a> 运算顺序</h5>\n<p>C 语言对括号的运算顺序没有进行规定，所以因为编译器的不同可能出现不同的结果<br>\n例如 a = 5 ;<br>\nc = (b = a + 2 ) - ( a = 1 )<br>\n 先算 b = a + 2 还是先算 a = 1 不同的编译器有着不一样的算法，所以如果编译器不同，可能产生不一样的结果</p>\n<p>注意不要依赖特定的运算顺序</p>\n<p>例如: i = 2 ;  j = i * i++;<br>\n 大部分人可能会认为输出的结果是 4，其实也可能为 6，不同的编译器有时候会出现不同的结果<br>\n最好的方法就是将长的运算表达式转化为短的运算表达式，如此就可以适应不同的编译器.</p>\n<h4 id=\"if语句\"><a class=\"markdownIt-Anchor\" href=\"#if语句\">#</a> if 语句</h4>\n<blockquote>\n<p>if (表达式) 语句</p>\n</blockquote>\n<p>注意表达式两边的括号是必须的<br>\n计算时先计算括号内表达式的值，如果表达式的值非零也就是真值，那么接着执行括号后面的语句.<br>\n 一定要注意区分 ==(判等) 和 =(赋值)<br>\n 前面我们说了例如 i &lt; j &lt; k 这样的写法是不行的，为了判定变量是否落在某个数值范围内，例如为了判定 0≤ i &lt; n 我们可以写成</p>\n<blockquote>\n<p>if (0 &lt;= i &amp;&amp; i&lt; n) …</p>\n</blockquote>\n<p>|| 运算符也是相同的道理</p>\n<h5 id=\"复合语句\"><a class=\"markdownIt-Anchor\" href=\"#复合语句\">#</a> 复合语句</h5>\n<p>在 if 语句模板中，语句是一条语句而不是多条语句，如果想用 if 语句处理多条语句，我们引入了复合语句.<br>\n 复合语句由一对花括号和语句混合而成，可以有多个声明和多个语句，也可以什么都没有<br>\n为了表示清楚，通常将一条语句放在多行内，每行有一条语句，如下所示:<br>\n{<br>\nline_num = 0;<br>\npage_num++;<br>\n}<br>\n 注意，每条内部语句依然以<strong>分号</strong>结尾</p>\n<h5 id=\"else子句\"><a class=\"markdownIt-Anchor\" href=\"#else子句\">#</a> else 子句</h5>\n<p>if 语句可以有 else 子句</p>\n<blockquote>\n<p>if (表达式) 语句 else 语句</p>\n</blockquote>\n<p>注意，出现的语句末尾都要以<strong>分号</strong>结尾</p>\n<p>通常来说为了布局美观，和清楚显示代码，我们将 if 和 else 放在同一列，其内的内部语句同样进行缩进<br>\n可以为复合语句增加花括号，这不是必需的但是能够使复合语句更加清楚.</p>\n<h4 id=\"条件表达式\"><a class=\"markdownIt-Anchor\" href=\"#条件表达式\">#</a> 条件表达式</h4>\n<blockquote>\n<p>表达式 1 ? 表达式 2 : 表达式 3</p>\n</blockquote>\n<p>表达式 1,2,3 可以是任何类型的表达式，同时条件表达式被经常称为三元运算符.</p>\n<p>条件表达式读作 如果表达式 1 成立，那么表达式 2，否则表达式 3<br>\n 求值步骤为：首先计算出表达式 1 的值，如果此值不为 0，那么计算表达式 2 的值，并且计算出来的值就是整个表达式的值，如果表达式 1 的值为 0，那么表达式 3 的值是整个条件表达式的值</p>\n<p>条件表达式通常运用于 printf 中进行简化代码</p>\n<p>例如 if (i&gt; j ) printf (\"% d \\n\",i); else printf (\"% d \\n\",j);<br>\n 可以简化为  printf (\"% d \\n\",i&gt;j?i:j);<br>\n 同时在 return 中也经常使用，使用场景类似</p>\n<h4 id=\"switch语句\"><a class=\"markdownIt-Anchor\" href=\"#switch语句\">#</a> switch 语句</h4>\n<p>通常来说可以用 switch 语句来代替级联式 if 语句</p>\n<blockquote>\n<p>switch (表达式) {<br>\ncase 常量表达式：语句<br>\n…<br>\ncase 常量表达式：语句<br>\n default : 语句<br>\n}</p>\n</blockquote>\n<p>同样这里的语句也要以<strong>分号</strong>结尾<br>\n<a href=\"https://imgtu.com/i/IQ9mqg\"><img src=\"https://z3.ax1x.com/2021/11/06/IQ9mqg.jpg\" alt=\"IQ9mqg.jpg\"></a></p>\n<p>switch 语句实际上是一种给予计算的跳转。对控制表达式求值时， 控制会跳转到与 switch 表达式的值相匹配的分支标号处。在执行完一个分支后，程序控制向下跳转到下一个分支的第一条语句上，如果没有 break 语句，控制将从一个分支继续流向下一个分支。例如<br>\n switch (grade) {<br>\ncase 4 :printf (“Excellent”);<br>\ncase 3 :printf (“Good”);<br>\ncase 2 :printf (“Average”);<br>\ncase 1 :printf (“poor”);<br>\ncase 0 :printf (“Falling”);<br>\ndefault : printf (“Illegal grade”)<br>\n}<br>\n 当你输入 3 时，显示的消息是：GoodAveragePoorFailingIllegal grade</p>\n<h3 id=\"循环\"><a class=\"markdownIt-Anchor\" href=\"#循环\">#</a> 循环</h3>\n<h4 id=\"while语句\"><a class=\"markdownIt-Anchor\" href=\"#while语句\">#</a> while 语句</h4>\n<blockquote>\n<pre><code>[while语句]:    while (表达式) 语句\n例如: while(i&lt;n) i=i*2;\n</code></pre>\n</blockquote>\n<p>因为 while 语句中有循环，为了让循环更简单，我们可以将 i++ 或者 i–直接加到 printf 中来使代码更加简洁</p>\n<blockquote>\n<pre><code>例如: while(i&gt;0) printf(\"%d \\n\",i--)\n这串代码可以一直输出0~i的数字，是不是这样更加简洁\n</code></pre>\n</blockquote>\n<h4 id=\"do语句\"><a class=\"markdownIt-Anchor\" href=\"#do语句\">#</a> do 语句</h4>\n<p>do 语句在本质上其实就是 while 语句只不过其控制表达式是在每次执行完循环体之后进行判定.</p>\n<blockquote>\n<pre><code>[do语句]: do 语句  while(表达式):\n</code></pre>\n</blockquote>\n<p>do 语句的循环体必须是一条语句和 while 一样，当然如果想用多条语句可以用复合语句.</p>\n<p>执行 do 语句时，先执行循环体，再计算控制表达式的值</p>\n<h4 id=\"for语句\"><a class=\"markdownIt-Anchor\" href=\"#for语句\">#</a> for 语句</h4>\n<blockquote>\n<pre><code>[for语句]    for(表达式1或者声明;表达式2;表达式3)\n</code></pre>\n</blockquote>\n<p><a href=\"https://imgtu.com/i/IQpd8P\"><img src=\"https://z3.ax1x.com/2021/11/06/IQpd8P.png\" alt=\"IQpd8P.png\"></a></p>\n<p>对于向上增或向下减的循环来说，for 语句通常是最好的选择</p>\n<p>从 0 向上加到 n-1</p>\n<blockquote>\n<pre><code>for (i=0;i&lt;n;i++)\n</code></pre>\n</blockquote>\n<p>从 1 向上加到 n</p>\n<blockquote>\n<pre><code>for(i=1;i&lt;=n,i++)\n</code></pre>\n</blockquote>\n<p>等等同理</p>\n<p>如果所需要的语句没有那么多，for 语句允许省略语句，注意，即使省略了表达式，括号中也许有两个<strong>分号</strong><br>\n当 for 语句同时省略第一个和第三个表达式时，那么他和 while 语句没有任何区别<br>\n省略第一个语句时，程序会默认为真值，会一直循环下去</p>\n<p>在 C99 中第一个表达式可以替换成一个声明，但在 for 语言中的声明，仅可以在 for 语句内部使用，在 for 循环的外部不可用</p>\n<p>同时 for 语言中可以声明多个变量，但是他们的类型需要相同</p>\n<h4 id=\"逗号运算符\"><a class=\"markdownIt-Anchor\" href=\"#逗号运算符\">#</a> 逗号运算符</h4>\n<blockquote>\n<pre><code>[逗号表达式] 表达式1,表达式2\n</code></pre>\n</blockquote>\n<p>第一步计算出表达式 1 的值，抛弃。第二部计算出表达式 2 的值，并将表达式 2 的值作为整个表达式的值，需要注意的是这里并不是说表达式 1 的值并没有用，表达式 1 中例如 i++，i–等仍然会对表达式 2 中的 i 和 j 造成一定的影响</p>\n<p>逗号运算符是左结合的，并且逗号运算符的优先级比其他所有运算符的优先级都更低</p>\n<p>for 语句是唯一可以发现逗号运算符的地方.<br>\nfor 语句可以利用逗号表达式来声明更多的变量</p>\n<h3 id=\"跳出循环\"><a class=\"markdownIt-Anchor\" href=\"#跳出循环\">#</a> 跳出循环</h3>\n<h4 id=\"break语句\"><a class=\"markdownIt-Anchor\" href=\"#break语句\">#</a> break 语句</h4>\n<p>前面讨论过 break 语句跳出 switch 语句，同时 break 语句还可以用于跳出 while,do,for 循环</p>\n<p>需要注意的时，如果有嵌套的情况存在，break 语句只能跳出一层循环</p>\n<h4 id=\"continue语句\"><a class=\"markdownIt-Anchor\" href=\"#continue语句\">#</a> continue 语句</h4>\n<p>continue 语句与 break 语句的区别在于，break 语句把程序控制转移到循环体末尾之后，而 continue 语句刚好把程序控制转移到循环体末尾之前.<br>\ncontinue 语句会把程序控制留在循环内，而 break 语句会使程序控制跳出循环<br>\n continue 语句只能用于循环，而 break 语句可以用于 switch 语句和循环</p>\n<p>continue 语句不会跳出循环，但会直接跳过 continue 之后的一系列语句，重新开始循环</p>\n<h4 id=\"goto语句\"><a class=\"markdownIt-Anchor\" href=\"#goto语句\">#</a> goto 语句</h4>\n<p>goto 语句可以跳转到函数中任何有<strong>标号</strong>的语句处</p>\n<blockquote>\n<pre><code>[标号语句]  标识符:语句\n[goto语句]  goto 标识符;\n</code></pre>\n</blockquote>\n<p>两个语句必须在同一个函数中<br>\n goto 语句对于嵌套循环的退出是很有用的</p>\n<h4 id=\"空语句\"><a class=\"markdownIt-Anchor\" href=\"#空语句\">#</a> 空语句</h4>\n<blockquote>\n<pre><code>eg:for(XX;XX;XX);\n</code></pre>\n</blockquote>\n<p>空语句的一个好处：编写空循环体的循环.<br>\nC 程序员习惯性地把空语句单独放置在一行</p>\n<h3 id=\"基本类型\"><a class=\"markdownIt-Anchor\" href=\"#基本类型\">#</a> 基本类型</h3>\n<p>C 语言支持两种根本的数据类型 分别是 整数类型 和浮点数类型  简单来说 整数和其他数 (包括小数等等) 的区别</p>\n<h4 id=\"整数类型\"><a class=\"markdownIt-Anchor\" href=\"#整数类型\">#</a> 整数类型</h4>\n<p>正说类型 分为 有符号整数和无符号整数</p>\n<p>有符号整数：如果整数为正数或者 0 那么最左边的符号位为 0; 如果为负数 那么最左边的符号位为 1 储存的时候都是按有符号整数来储存 如果要当成无符号整数来储存 需要声明整数类型为 unsigned<br>\n 无符号整数：最左边的位是数值的一部分</p>\n<p>C 语言的整数类型 有着不同的大小 int 类型通常为 32 位   有些数字很大 所以 C 语言还提供了 长整型 和 需要很小空间来储存的数 这样的数称为短整型</p>\n<p>整型分为 4 种 long short signed unsigned 他们之间可以互相组合</p>\n<blockquote>\n<pre><code>short int\nunsigned short int\nint\nunsigned int\nlong int\nunsigned long int\n</code></pre>\n</blockquote>\n<p>其他组合都是上述组合的同义词<br>\n C 语言允许通过省略单词 int 来缩写整数类型的名字<br>\n但很多基于 c 语言的程序 甚至不允许程序员写 short int 这样的名字 而必须写成 short 或者 long<br>\n 不同类型的取值范围也可能一样<br>\n eg: long int 可能和 int 有相同的取值范围  但是 long int 永远不可能比 int 的取值范围短<br>\n<a href=\"https://imgtu.com/i/IQpcUs\"><img src=\"https://z3.ax1x.com/2021/11/06/IQpcUs.png\" alt=\"IQpcUs.png\"></a><br>\n<a href=\"https://imgtu.com/i/IQpsbQ\"><img src=\"https://z3.ax1x.com/2021/11/06/IQpsbQ.png\" alt=\"IQpsbQ.png\"></a><br>\n<a href=\"https://imgtu.com/i/IQp0v8\"><img src=\"https://z3.ax1x.com/2021/11/06/IQp0v8.png\" alt=\"IQp0v8.png\"></a><br>\n 但是这种范围会随着编译器的不同而不同 好的解决方法是检查 &lt;limis.h&gt; 头文件定义了每种整数类型的最大值和最小值的宏<br>\n C99 新增了 2 个 long long int 和 unsigned long long int</p>\n<h5 id=\"整数常量\"><a class=\"markdownIt-Anchor\" href=\"#整数常量\">#</a> 整数常量</h5>\n<p>常量：在程序中以文本形式出现的数，而不是读，写，计算出来的数.C 语言允许用十进制，八进制，十六进制来表示常量</p>\n<p>十进制不能以 0 开头 八进制必须以 0 开头 十六进制总是以 0x 开头<br>\n这里需要注意的是  这些只是书写数的方式 并不会对数的储存方式产生英雄 数都是以二进制储存的 所以我们进行计算的时候甚至可以将他们三个混合使用 程序仍然能够识别 并且计算出值<br>\n十进制整数常量的类型同城为 nit 但如果常量的值大得无法储存在 int 型中 那就用 long int 类型。如果出现 long int 还不够用的罕见情况 编译器会用 unsigned long int 做最后的尝试<br>\n八进制和十六进制 会从范围最小的整数型开始尝试 直至找到能表示该常量的类型</p>\n<p>要强制编译器把常量作为长整数来处理，只需要在后边加上一个字母 L/l  <strong>大小写无所谓</strong><br>\n同样 要指明是无符号变量 可以在常量后边加上字母 U/u<br>\n<strong>L 和 U 可以混合使用 顺序和大小都无所谓</strong></p>\n<h5 id=\"c99中的整型变量\"><a class=\"markdownIt-Anchor\" href=\"#c99中的整型变量\">#</a> C99 中的整型变量</h5>\n<p>在 C99 中 出现了 LL (long long) 在 ll 前面 U 的通常是 unsigned long long  需要注意的是 <strong>这里两个 l 的大小写需要一致</strong><br>\n十进制储存 按照 int      long int   long long int 中的最小的能适合的方式储存<br>\n而八进制和十六进制 按照 int        unsigned int          long int           unsigned long int   ……</p>\n<h5 id=\"整数溢出\"><a class=\"markdownIt-Anchor\" href=\"#整数溢出\">#</a> 整数溢出</h5>\n<p>对整数执行算数运算时，其结果有可能因为太大而无法显示，这时候就会发生整数溢出<br>\n有符号整数溢出时 会出现没有定义的情况 无法预估最后会发生的情况<br>\n无符号整数溢出时 结果会有定义的：正确答案对 2 的 n 次方取模 例如 65535+1 的结果 (能够被 2 除尽) 其结果可以保证为 0</p>\n<h5 id=\"读写整数\"><a class=\"markdownIt-Anchor\" href=\"#读写整数\">#</a> 读 / 写整数</h5>\n<p>通常我们发生整数溢出时，会马上去更换整数类型 但单单这样做是不够的 我们还必须检查数据类型的改变对程序其他部分的影响</p>\n<p>读写无符号整数时 使用 u,o,x 代替转换说明中的 d<br>\nu 表示十进制 o 表示八进制 x 表示十六进制</p>\n<p>读写短整数时 在 d,o,x 或者 u 前面加上字母 h</p>\n<p>读写长整数时，在 d,o,x 或者 u 前面加上字母 l</p>\n<p>读写尝尝整数时，在 d,o,x 或者 u 前面加上字母 ll</p>\n<h4 id=\"浮点类型\"><a class=\"markdownIt-Anchor\" href=\"#浮点类型\">#</a> 浮点类型</h4>\n<p>float: 单精度浮点数<br>\n double: 双精度浮点数<br>\n long double: 扩展精度浮点数</p>\n<p>C 语言没有明确的说明精度到底是多少 不同的计算机可以以不同的方法储存浮点数</p>\n<p>数值是由三部分组成：符号，指数和小数 指数部分的位数说明了数值可能大小程度 而小数部分的位数说明了精度<br>\n<a href=\"https://imgtu.com/i/IQpwgf\"><img src=\"https://z3.ax1x.com/2021/11/06/IQpwgf.png\" alt=\"IQpwgf.png\"></a><br>\nlong double 类型没有出现在表中 因为它的长度随着机器的不同而变化 最常见的大小是 80 位和 128 位</p>\n<p>C99 中 浮点类型分为两种 一种是实浮点类型 包括 float,double,long double 类型<br>\n另一种是 C99 新增的复数类型  包括 float ,_Complex ,double ,_Complex ,long double _Complex</p>\n<h5 id=\"浮点常量\"><a class=\"markdownIt-Anchor\" href=\"#浮点常量\">#</a> 浮点常量</h5>\n<p>浮点常量必须包括小数点或者指数 其中指数指明了对前面的数进行缩放所需的 10 的幂次 如果有指数 则需要在指数数值前放置字母 E 或者 e 可选符号 + 或者 - 可以出现在字母 E 或者 e 的后边 为了表明只需要单精度 可以在常量的末尾处加上字母 F/f; 而为了说明常量必须以 long double 的形式储存可以在常量的末尾处 加上字母 L 或者 l</p>\n<h5 id=\"读写浮点数\"><a class=\"markdownIt-Anchor\" href=\"#读写浮点数\">#</a> 读写浮点数</h5>\n<p>前面已讨论过，转换说明 % e,% f 和 % g 用于读写单精度浮点数 读写 double 和 long double 类型的值所需的转换说明略有不同<br>\n读写 double 类型的值时，在 e,f,g 前面放置字母 l   <strong>注意只能在字符串 scanf 中使用 在 printf 函数调用中使用额 e,f,g 可以用来写 float 类型或者 double 类型的值</strong><br>\n读写 long double 类型时，在 e,f,g 前面放置字母 L<br>\n<strong> 注意 double 和 long double 这里有字母大小写的区别</strong></p>\n<h4 id=\"字符类型char\"><a class=\"markdownIt-Anchor\" href=\"#字符类型char\">#</a> 字符类型 char</h4>\n<p>当前最常用的字符集是 ASCII 字符集，用 7 位代码表示 128 个字符<br>\n char 类型的变量可以用任意单字符赋值</p>\n<h5 id=\"字符操作\"><a class=\"markdownIt-Anchor\" href=\"#字符操作\">#</a> 字符操作</h5>\n<p>C 语言将字符当做整数进行处理 毕竟所有的字符都是以二进制的形式进行编码的</p>\n<blockquote>\n<pre><code>char ch;\nch = 65      此时ch是A\nch = ch+1    此时ch是B\n</code></pre>\n</blockquote>\n<h5 id=\"有符号字符和无符号字符\"><a class=\"markdownIt-Anchor\" href=\"#有符号字符和无符号字符\">#</a> 有符号字符和无符号字符</h5>\n<p>char 类型像整数类型一样存在符号性和无符号性两种 通常有符号型的取值是 - 128~127 而无符号字符的取值是 0~255<br>\n 所有 C 语言允许单词 signed 和 unsigned 来修饰 char 类型</p>\n<h4 id=\"算数类型\"><a class=\"markdownIt-Anchor\" href=\"#算数类型\">#</a> 算数类型</h4>\n<p><a href=\"https://imgtu.com/i/IQp6Ej\"><img src=\"https://z3.ax1x.com/2021/11/06/IQp6Ej.png\" alt=\"IQp6Ej.png\"></a></p>\n<h4 id=\"转义序列-2\"><a class=\"markdownIt-Anchor\" href=\"#转义序列-2\">#</a> 转义序列</h4>\n<p>转义序列分为字符转义序列和数字转义序列</p>\n<h5 id=\"字符转义序列\"><a class=\"markdownIt-Anchor\" href=\"#字符转义序列\">#</a> 字符转义序列</h5>\n<p><a href=\"https://imgtu.com/i/IQprDg\"><img src=\"https://z3.ax1x.com/2021/11/06/IQprDg.png\" alt=\"IQprDg.png\"></a></p>\n<h5 id=\"数字转义序列\"><a class=\"markdownIt-Anchor\" href=\"#数字转义序列\">#</a> 数字转义序列</h5>\n<p>字符转义序列没有包含所有无法打印的 ASCII 字符 字符转义序列也无法包含 128 个 ASICC 字符以外的字符 而数字转义字符可以表示任何字符 所有它可以解决上述问题</p>\n<p>作为字符常量来使用时，<strong> 转义序列必须用一堆单引号括起来</strong></p>\n<h4 id=\"字符处理函数\"><a class=\"markdownIt-Anchor\" href=\"#字符处理函数\">#</a> 字符处理函数</h4>\n<p>例如 toupper 函数可以将小写字母转化为大写字母 但要调用这类使用的字符处理函数 需要在顶部放置 #include &lt;ctype.h&gt; 这一条指令</p>\n<h5 id=\"用scanf-和printf读写字符\"><a class=\"markdownIt-Anchor\" href=\"#用scanf-和printf读写字符\">#</a> 用 scanf 和 printf 读写字符</h5>\n<p>scanf 读写字符时 并不会跳过空白字符 为了强制 scanf 在读入字符前跳过空白字符，需要在格式串中的转换说明 % C 前面加上一个空格</p>\n<h5 id=\"用getchar和putchar用于读写字符\"><a class=\"markdownIt-Anchor\" href=\"#用getchar和putchar用于读写字符\">#</a> 用 getchar 和 putchar 用于读写字符</h5>\n<p>getchar 函数和 putchar 函数可以用来取代 scanf 和 printf 函数 putchar 函数用于写单个字符<br>\n每次调用时他会读写一个字符并将其返回 为了保存这个字符 必须使用赋值操作将其储存在变量中<br>\n当混用 getchar 函数和 scanf 函数要小心 scanf 函数仅消耗掉匹配的输入数据 其余部分仍然留在缓冲区 (包括换行符)</p>\n<h4 id=\"类型转换\"><a class=\"markdownIt-Anchor\" href=\"#类型转换\">#</a> 类型转换</h4>\n<h5 id=\"隐式类型转换规则\"><a class=\"markdownIt-Anchor\" href=\"#隐式类型转换规则\">#</a> 隐式类型转换规则</h5>\n<p>较低级向较高级转换 (按存储长度)<br>\n 其中有一个操作数是浮点型时 把整型操作数往浮点型转换 而浮点型往精度更高的浮点型转换<br>\n两个操作数都不是浮点数时，如果有 char 或者 short int 类型 首先对两个操作数进行整型提升<br>\n<strong>特例</strong>:long int 和 unsigned int 数据类型长度相同时 则两个操作数均转换为 unsigned long<br>\n<a href=\"https://imgtu.com/i/IQ9FPI\"><img src=\"https://z3.ax1x.com/2021/11/06/IQ9FPI.png\" alt=\"IQ9FPI.png\"></a><br>\n 赋值中的类型转换：把赋值运算符右侧表达式的值转换为左侧变量的类型.</p>\n<h5 id=\"强制类型转换\"><a class=\"markdownIt-Anchor\" href=\"#强制类型转换\">#</a> 强制类型转换</h5>\n<blockquote>\n<pre><code>(类型)变量   eg(char)i  表示把i的类型强制转换为char的类型\n(类型)(表达式)\n</code></pre>\n</blockquote>\n<p>这些转换类型只是一次有效的 不会改变变量定义时的数据类型<br>\n C 语言把类型名视为一元运算符</p>\n<h4 id=\"类型定义\"><a class=\"markdownIt-Anchor\" href=\"#类型定义\">#</a> 类型定义</h4>\n<blockquote>\n<pre><code>typedef 数据类型 别名\n</code></pre>\n</blockquote>\n<p>用于对另一个数据类型创建一个别名<br>\n注意并没有创建一个新的类型 仅仅是对某个已有的类型增加一个别名<br>\n可以让程序更加易于理解 可读性更高</p>\n<h4 id=\"sizeof-运算符\"><a class=\"markdownIt-Anchor\" href=\"#sizeof-运算符\">#</a> sizeof 运算符</h4>\n<p>取数据类型 常量 变量或者表达式值得存储长度的运算符 (以字节为单位)</p>\n<blockquote>\n<pre><code>sizeof(数据类型说明符/表达式)\n用于类型名 sizeof(类型名)\n用于表达式 sizeof 表达式\n</code></pre>\n</blockquote>\n<h3 id=\"第八章-字符输入输出和输入验证\"><a class=\"markdownIt-Anchor\" href=\"#第八章-字符输入输出和输入验证\">#</a> 第八章 字符输入 / 输出和输入验证</h3>\n<h4 id=\"单字符io-getchar和putchar\"><a class=\"markdownIt-Anchor\" href=\"#单字符io-getchar和putchar\">#</a> 单字符 I/O getchar () 和 putchar ();</h4>\n<h4 id=\"缓冲区\"><a class=\"markdownIt-Anchor\" href=\"#缓冲区\">#</a> 缓冲区</h4>\n<p>用户输入的字符被收集并存储在一个被称为缓冲区的临时存储区 按下 enter 键后 程序才可以使用用户输入的字符<br>\n某些交互式系统无缓冲区 比如游戏中按下一个键需要立即执行按下的操作<br>\n缓冲区分为完全缓冲和行缓冲</p>\n<blockquote>\n<pre><code>完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区\n行缓冲指的是在出现换行时刷新缓冲区(键盘输入)\n</code></pre>\n</blockquote>\n<p>是否能进行无缓冲输入取决于计算机系统 大部分直接规定输入都会缓冲输入</p>\n<h4 id=\"结束键盘输入\"><a class=\"markdownIt-Anchor\" href=\"#结束键盘输入\">#</a> 结束键盘输入</h4>\n<h5 id=\"文件流和键盘输入\"><a class=\"markdownIt-Anchor\" href=\"#文件流和键盘输入\">#</a> 文件，流和键盘输入</h5>\n<h5 id=\"文件结尾\"><a class=\"markdownIt-Anchor\" href=\"#文件结尾\">#</a> 文件结尾</h5>\n<p>方法 1 文件末尾放置一个特殊字符 来标记末尾<br>\n方法 2 存储文件大小的信息。如果程序有 3000 字节 那么程序在读到 3000 字节的时候便达到文件末尾</p>\n<p>在 C 语言中 用 getchar 或者 scanf 检测文件末尾时都将放回一个特殊值 即 EOF</p>\n<h3 id=\"第九章函数\"><a class=\"markdownIt-Anchor\" href=\"#第九章函数\">#</a> 第九章函数</h3>\n<h4 id=\"复习函数\"><a class=\"markdownIt-Anchor\" href=\"#复习函数\">#</a> 复习函数</h4>\n<h5 id=\"创建并使用简单函数\"><a class=\"markdownIt-Anchor\" href=\"#创建并使用简单函数\">#</a> 创建并使用简单函数</h5>\n<blockquote>\n<pre><code>#include &lt;stdio.h&gt;\n#define NAME \"GIGATHINK,INC\"\n#define ADDRESS \"101 Megabuck plaza\"\n#define PLACE \"MEGAPOLIS,CA 94904\"\n#define WIDTH 40\n\nvoid starbar(void);\n\nint main(void)\n{\n    starbar();\n    printf(\"%s \\n\", NAME);\n    printf(\"%s \\n\", ADDRESS);\n    printf(\"%s \\n\", PLACE);\n    starbar(); //使用函数\n    return 0;\n}\n\nvoid starbar(void) //定义函数\n{\n    int count;\n    for (count = 1; count &lt;= WIDTH; count++)\n    {\n        putchar('*');\n    }\n    putchar('\\n');\n}\n</code></pre>\n</blockquote>\n<h5 id=\"分析程序\"><a class=\"markdownIt-Anchor\" href=\"#分析程序\">#</a> 分析程序</h5>\n<p>函数原型：告诉编译器函数的类型<br>\n函数调用：表明在此处执行函数<br>\n函数定义：明确地指出函数要做什么</p>\n<p>函数和变量有一样有多种类型 任何程序在使用函数之前都要声明该函数的类型</p>\n<blockquote>\n<pre><code>void starbar(void);\n圆括号表示starbar是一个函数名 第一个void是函数类型 void类型表明函数没有返回值 第二个void(圆括号中)表明该函数不带参数。分号表示这是在申明函数不是在定义函数 \n这行表明了程序将使用一个名为starbar(),没有返回值,没有参数的函数,并告诉编译器在别处查找该函数的定义\n</code></pre>\n</blockquote>\n<p>一般而言 函数原型指明了函数的返回值类型和函数接受的参数类型 这些信息称为函数的<strong>签名</strong><br>\n这里对于 starbar () 函数而言 其签名是该函数没有返回值，没有参数<br>\n starbar () 原型放在任何位置都可以<br>\n执行顺序:<br>\n 在 main () 中 当计算机执行到 starbar () 函数时，会找到该函数的定义并执行其中的内容，执行完 starbar () 中的代码后，计算机返回主调函数继续执行下一行<br>\n函数头包括函数类型，函数名和圆括号，接着是左花括号，变量声明，函数表达式语句，最后以又花括号结束<br>\n ** 注意函数头中的 starbar () 没有分号 这是在告诉编译器这是定义 starbar ()，而不是调用函数或者声明函数类型<br>\n starbar () 函数中的 count 变量是局部变量，意思是该变量只属于 starbar () 函数，可以在程序中的其他地方使用 count 这并不会引起名称冲突 他们是同名的不同函数</p>\n<h5 id=\"函数参数\"><a class=\"markdownIt-Anchor\" href=\"#函数参数\">#</a> 函数参数</h5>\n<blockquote>\n<pre><code>void show_n_char(char ch,int num);   \nshou_n_char('*',12)\n</code></pre>\n</blockquote>\n<h5 id=\"定义带形式参数的函数\"><a class=\"markdownIt-Anchor\" href=\"#定义带形式参数的函数\">#</a> 定义带形式参数的函数</h5>\n<p>第一行告知编译器 show_n_char 使用两个参数 ch 和 num,ch 是 char 类型 num 是 int 类型。这两个变量被称为形式参数，简称形参。和定义在函数中变量一样 形参也是局部变量属于该函数私有。这以为着在其他函数中使用同名变量不会引起名称冲突 每次调用函数 就会给这些变量赋值<br>\n值得一提的是 虽然 show_n_char () 接受来自 main () 的值 但是它没有返回值。因此，show_n_char () 的类型是 void</p>\n<h5 id=\"声明带形式参数函数的原型\"><a class=\"markdownIt-Anchor\" href=\"#声明带形式参数函数的原型\">#</a> 声明带形式参数函数的原型</h5>\n<p>使用函数之前要声明函数原型: void shou_n_char (char ch,int num) 当然根据个人喜好 你也可以省略变量名<br>\n在原型中使用变量名并没有实际创建变量，char 仅代表了一个 char 类型的变量</p>\n<h5 id=\"调用带实际参数的函数\"><a class=\"markdownIt-Anchor\" href=\"#调用带实际参数的函数\">#</a> 调用带实际参数的函数</h5>\n<p>在函数的调用中 实际参数 (简称实参) 提供了 ch 和 num 的值 比如 show_n_char (’*’,12); 这两个值被赋值给函数中的形式参数<br>\n简而言之形式参数是被调函数中的变量 实际参数是主调函数赋值给被调函数的具体值 实际参数可以是常量变量甚至是更复杂的表达式 无论实际参数是何种形式都要被求值 然后该值被拷贝给被调函数相应的形式参数.</p>\n<h5 id=\"使用return从函数中返回值\"><a class=\"markdownIt-Anchor\" href=\"#使用return从函数中返回值\">#</a> 使用 return 从函数中返回值</h5>\n<blockquote>\n<pre><code>int imin(int n , int m)\nint imin(int n , int m)\n{\nint min ;\nif (n&lt;m) min=n;\nelse min = m;\nreturn min;\n}\nint a = imin(1,2)\n</code></pre>\n</blockquote>\n<p>关键字 return</p>\n<h3 id=\"数组\"><a class=\"markdownIt-Anchor\" href=\"#数组\">#</a> 数组</h3>\n<h4 id=\"一维数组\"><a class=\"markdownIt-Anchor\" href=\"#一维数组\">#</a> 一维数组</h4>\n<p>数组：含有多个数据值的数据结构<br>\n每个数据值具有相同的数据类型<br>\n这些数据值被称为元素<br>\n属猪内可以根据元素所处的位置对其进行单独访问</p>\n<p>声明一个数组</p>\n<blockquote>\n<pre><code>类型定衣服 数组名 [常量表达式]; eg: int score[10] 1个含有10个整型数据类型的score数组\n</code></pre>\n</blockquote>\n<p>数组的元素可以使任何类型<br>\n数组名使用标识符表示<br>\n用方括号将常量表达式括起<br>\n数组的长度可以用任何整型常量表达式说明<br>\n常量表达式定义了数组元素的个数<br>\n<strong>数组下标从 0 开始</strong></p>\n<p>如果一个数组所包含的元素类型为 T 则数组的每个元素都可以被当做一个类型为 T 的变量来对待<br>\n当下标超出范围时 程序可坑执行不可预知的行为</p>\n<h4 id=\"数组的初始化\"><a class=\"markdownIt-Anchor\" href=\"#数组的初始化\">#</a> 数组的初始化</h4>\n<blockquote>\n<pre><code>eg int a[10] = {1,2,3,4,5,6,7,8,9,10}\n</code></pre>\n</blockquote>\n<p>列表用大括号括起来 并且内部数组用逗号进行分隔<br>\n如果初始化式比数组端 那么数组中剩余的元素赋值为 0<br>\n 利用这一特性 可以很容易地将全部数组元素初始为 0</p>\n<p>初始化完全为空是非法的，所以要在大括号内放上一个单独的 0<br>\n 初始化式比目标数组长也是非法的</p>\n<p>如果声明数组的同时对其进行初始化，则在生命是忽略掉数组的长度</p>\n<blockquote>\n<pre><code>如果数组中只有较少的元素需要初始化 其他元素进行默认赋值\neg: int a[15] = {[2]=29,[3]=22};\n</code></pre>\n</blockquote>\n<h5 id=\"对数组使用sizeof运算符\"><a class=\"markdownIt-Anchor\" href=\"#对数组使用sizeof运算符\">#</a> 对数组使用 sizeof 运算符</h5>\n<p>运算符 sizeof 可以确定数组的大小 (字节数)<br>\n eg 如果数组 a 包含 10 4 字节存储的整数 那个 sizeof (a) = 40<br>\n 进阶：用数组的大小除以数组元素的大小 可以得到数组的长度 sizeof (a)/sizeof (a [0])</p>\n",
            "tags": [
                "C语言"
            ]
        }
    ]
}